# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/nbs/utils/13_aggr.ipynb.

# %% auto 0
__all__ = ['nb_aggregate']

# %% ../../../nbs/nbs/utils/13_aggr.ipynb 4
import os, warnings, nbformat as nbf

from nbformat import NotebookNode
from typing import List, Optional

from tqdm.auto import tqdm

from atyp import IntQ, StrQ, Strs, BoolQ

# %% ../../../nbs/nbs/utils/13_aggr.ipynb 5
from .cons import (CELLS, NBDEV_SHOWDOC, NBDEV_EXPORT,)
from .node import nb_add_head, nb_add_section, nb_add_tail
from .file import read_nb, dir_nbs
from .name import new_nbout

# %% ../../../nbs/nbs/utils/13_aggr.ipynb 7
def nb_aggregate(
    path: str, 
    name: StrQ = None,
    prefix: StrQ = None, 
    add_prefix: BoolQ = True,
    prefix_dir: StrQ = None,
    output: StrQ = None,
    ignore: Optional[Strs] = None,
    maximum: BoolQ = False, 
    pad: IntQ = 2,
) -> NotebookNode:
    '''Aggregate Jupyter notebooks from a directory into a single notebook.
    
    Parameters
    ----------
    path : str
        The path to the directory containing the notebooks to be aggregated.
        
    name : str, optional
        The name of the module, by default None.
        
    prefix : str, optional
        A specific prefix to prepend to the notebook file name, by default None.
        
    add_prefix : bool, default: True
        Whether or not to add a prefix to the notebook file name, by default True.
        
    prefix_dir : str, optional
        Directory to search for existing notebook filenames, by default None.
        
    output : str, optional
        The path to the output notebook file, by default None.
        
    ignore : List[str], optional
        A list of notebook filenames to ignore, by default None.
        
    maximum : bool, default: False
        If True, returns the next maximum prefix. If False, returns the smallest missing prefix.
        
    pad : int, default: 2
        Number of digits to pad the notebook number with, by default 2.
        
    Returns
    -------
    NotebookNode
        The aggregated notebook as a NotebookNode object.
    '''
    new_nb = nbf.v4.new_notebook()
    new_nb[CELLS] = []

    basename = os.path.basename(path)
    dirname  = os.path.dirname(path)

    output = new_nbout(
        module=(name or basename), dirname=dirname, 
        prefix=prefix, prefix_dir=(prefix_dir or dirname), add_prefix=add_prefix, 
        maximum=maximum, pad=pad
    )

    notebooks = sorted([file for file in dir_nbs(path) if file not in ignore])
    

    new_nb = nb_add_head(new_nb, name or basename, notebooks)

    # Iterate over the notebooks
    for nb_name in tqdm(notebooks, desc='Aggregating notebooks'):

        # Read the notebook
        nb = read_nb(os.path.join(path, nb_name))

        # Find the beginning and end cells
        beg_cell = next(i for i, cell in enumerate(nb.cells) if cell.source.strip() == NBDEV_SHOWDOC)
        end_cell = next(i for i, cell in enumerate(nb.cells) if cell.source.strip() == NBDEV_EXPORT)

        new_nb = nb_add_section(new_nb, nb_name, path)

        # Add the cells to the new notebook
        new_nb.cells.extend(nb.cells[beg_cell + 1 : end_cell])

    new_nb = nb_add_tail(new_nb)
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        # Normalize the notebook
        changes, new_nb = nbf.validator.normalize(new_nb)

    # Write the new notebook
    with open(output, 'w') as f:
        nbf.write(new_nb, f)
    
    return new_nb
