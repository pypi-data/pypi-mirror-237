# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/nbs/utils/08_file.ipynb.

# %% auto 0
__all__ = ['find_nb', 'read_nb', 'read_cell', 'nbdev_nbs', 'dir_nbs', 'dir_nbdev', 'drop_prefix', 'prefix_int', 'filenum',
           'next_prefix', 'next_nbnum']

# %% ../../../nbs/nbs/utils/08_file.ipynb 4
import os, io, nbformat as nbf
from nbformat import NotebookNode, read

from typing import List, Union, Optional
from atyp import StrQ

from nchr.core import DOT, NIL, SPACE, SUNDER
from nlit.exts import EXT_IPYNB
from pstr.filt import endpart, justnum, prepart

# %% ../../../nbs/nbs/utils/08_file.ipynb 5
from .bool import is_ipy, is_nbdev
from .nums import str2int, int2str, nextint
# from nbkit.bool import has__

# %% ../../../nbs/nbs/utils/08_file.ipynb 8
def find_nb(file: str, paths: Optional[Union[str, List[str]]] = None) -> StrQ:
    '''Find a Jupyter Notebook file with the given `file` in the specified `paths`.

    Parameters
    ----------
    file : str
        The name of the notebook to find. If it is part of a module, this should be the last part of the module name.

    paths : List[str], optional
        The directories to look for the notebook. If `None`, defaults to the current directory.

    Returns
    -------
    nb_path : StrQ
        The full path to the notebook file if found, otherwise returns `None`.

    Notes
    -----
    This turns `"foo.bar"` into `"foo/bar.ipynb"` and tries turning `"Foo_Bar"` 
        into `"Foo Bar"` if `"Foo_Bar"` does not exist.

    Examples
    --------
    >>> find_notebook('my_notebook')
    '/path/to/my_notebook.ipynb'
    
    >>> find_notebook('another_notebook', paths=['./notebooks'])
    '/path/to/notebooks/another_notebook.ipynb'

    >>> find_notebook('not_found')
    None
    '''
    name = file.rsplit(DOT, 1)[-1]
    paths = paths or ([path] if isinstance(paths, str) else [NIL])

    for path in paths:        
        nb_path = os.path.join(path, f'{name}{EXT_IPYNB}')
        if os.path.isfile(nb_path): return nb_path
        
        # let import Notebook_Name find "Notebook Name.ipynb"
        nb_path = nb_path.replace(SUNDER, SPACE)
        if os.path.isfile(nb_path): return nb_path

# %% ../../../nbs/nbs/utils/08_file.ipynb 10
def read_nb(path: str) -> NotebookNode:
    '''
    Read a Jupyter Notebook from a given path.

    Parameters
    ----------
    path : str
        File path to the Jupyter Notebook.

    Returns
    -------
    NotebookNode
        A NotebookNode object.
    '''
    with io.open(path, 'r', encoding='utf-8') as f: 
        nb: NotebookNode = read(f, 4)
    return nb

def read_cell(path: str, idx: int) ->  Optional[str]:
    '''
    Read a specific cell from a Jupyter Notebook.

    Parameters
    ----------
    path : str
        File path to the Jupyter Notebook.
    idx : int
        Index of the cell to be read.

    Returns
    -------
    Optional[str]
        Content of the cell or None if not found.
    '''
    nb = read_nb(path)
    return nb.cells[idx]

# %% ../../../nbs/nbs/utils/08_file.ipynb 13
def nbdev_nbs(notebooks: List[str]) -> List[str]:
    '''Filter notebooks following the nbdev naming convention.

    Parameters
    ----------
    notebooks : List[str]
        A list of notebook filenames.

    Returns
    -------
    List[str]
        A list of notebook filenames that follow the nbdev naming convention.

    Examples
    --------
    >>> nbdev_nbs(['01_notebook.ipynb', 'temp.ipynb'])
    ['01_notebook.ipynb']
    '''
    # Filter out non-convention notebooks
    notebooks = [file for file in notebooks if is_nbdev(file)]
    return notebooks


# %% ../../../nbs/nbs/utils/08_file.ipynb 15
def dir_nbs(path: str) -> List[str]:
    '''List all notebook files in a directory.

    Parameters
    ----------
    path : str
        The directory path to search for notebook files.

    Returns
    -------
    List[str]
        A list of notebook filenames found in the directory.

    Examples
    --------
    >>> dir_nbs('/path/to/notebooks')
    ['01_notebook.ipynb', '02_notebook.ipynb']
    '''
    notebooks = [file for file in os.listdir(path) if is_ipy(file)]
    return notebooks


# %% ../../../nbs/nbs/utils/08_file.ipynb 17
def dir_nbdev(path: str) -> List[str]:
    '''List all notebook files in a directory that follow the nbdev naming convention.

    Parameters
    ----------
    path : str
        The directory path to search for notebook files.

    Returns
    -------
    List[str]
        A list of notebook filenames found in the directory.

    Examples
    --------
    >>> dir_nbs('/path/to/notebooks')
    ['01_notebook.ipynb', '02_notebook.ipynb', 'temp.ipynb']

    >>> dir_nbdev('/path/to/notebooks')
    ['01_notebook.ipynb', '02_notebook.ipynb']
    '''
    return nbdev_nbs(dir_nbs(path))


# %% ../../../nbs/nbs/utils/08_file.ipynb 20
def drop_prefix(file: str) -> str:
    '''
    Remove the prefix from a file name.

    Parameters
    ----------
    file : str
        The file name.

    Returns
    -------
    str
        The file name without the prefix.
    '''
    return endpart(file, '_') if '_' in file and justnum(prepart(file, '_')) else file

# %% ../../../nbs/nbs/utils/08_file.ipynb 22
def prefix_int(file: str) -> int:
    '''Extract integer prefix from file name.

    Parameters
    ----------
    file : str
        File name to extract prefix from.
        
    Returns
    -------
    int
        Extracted integer prefix.
    '''
    prefix, *_ = file.partition('_')
    return str2int(prefix)


# %% ../../../nbs/nbs/utils/08_file.ipynb 25
def filenum(
    file: str, path: Optional[str] = None, 
    notebooks: Optional[List[str]] = None, pad: int = 2, **kwargs
) -> Optional[str]:
    '''Get the notebook file's number prefix given a file's name.
    For example if  the notebook file is `01_notebook.ipynb` and `name = "notebook"` 
    returns `01`.

    Parameters
    ----------
    file : str
        The notebook name / file to search for (without prefix).

    path : str, optional
        The directory path to search within. If None, only uses the provided list of notebooks.

    notebooks : List[str], optional
        A list of notebook filenames to search within.

    pad : int, optional
        Number of digits to pad the notebook number with.

    Returns
    -------
    Optional[str]
        The notebook number if found, otherwise None.

    Examples
    --------
    >>> filenum('01_notebook.ipynb', '/path/to/notebooks')
    '01'
    '''
    # Check if a file is provided
    if file is None: return None

    filename = drop_prefix(file).replace(EXT_IPYNB, NIL)    
    if is_nbdev(file):
        nbprefix = int2str(prefix_int(nb_name), pad)
        return nbprefix
    
    # Get the list of notebooks in the directory
    notebooks = notebooks or []    
    notebooks.extend(dir_nbs(path))

    # Filter out non-convention notebooks
    notebooks = nbdev_nbs(notebooks)

    # Check if there is a notebook that matches the name
    for nb_file in notebooks:
        nb_name = drop_prefix(nb_file).replace(EXT_IPYNB, NIL)

        if filename == nb_name:
            nbprefix = int2str(prefix_int(nb_file), pad)
            return nbprefix
        
    return None

# %% ../../../nbs/nbs/utils/08_file.ipynb 27
def next_prefix(notebooks: List[str], maximum: bool = False, pad: int = 2) -> str:
    '''Get the next available notebook prefix for a list of notebooks

    Parameters
    ----------
    notebooks : List[str]
        A list of notebook filenames.

    maximum : bool, optional
        If True, returns the next maximum prefix. If False, returns the smallest missing prefix.

    pad : int, optional
        Number of digits to pad the notebook number with.

    Returns
    -------
    str
        The next available notebook prefix.

    Examples
    --------
    >>> next_prefix(['01_notebook.ipynb', '02_notebook.ipynb'])
    '03'
    '''
    # Filter out non-convention notebooks
    notebooks = nbdev_nbs(notebooks)

    # Extract the prefixes
    prefixes = sorted([prefix_int(file) for file in notebooks])

    if maximum: # Return the maximum prefix + 1
        return int2str(max(prefixes) + 1, pad)
    
    else: # Return the smallest missing prefix
        return int2str(nextint(prefixes), pad)
            
    # Can't find a smaller prefix so return the next one    
    return next_prefix(notebooks, maximum=True, pad=pad)


# %% ../../../nbs/nbs/utils/08_file.ipynb 29
def next_nbnum(
    path: str, name: Optional[str] = None, 
    maximum: Optional[bool] = False, pad: Optional[int] = 2, **kwargs
) -> int:
    '''Get the next available notebook number in a given directory.

    Parameters
    ----------
    path : str
        The directory path to search for notebook files.

    name : Optional[str], optional
        A specific notebook name to search for.

    maximum : bool, optional
        If True, returns the next maximum prefix. If False, returns the smallest missing prefix.

    pad : int, optional
        Number of digits to pad the notebook number with.

    Returns
    -------
    int
        The next available or specific notebook number.

    Examples
    --------
    >>> next_filenum('/path/to/notebooks')
    '03'
    >>> next_filenum('/path/to/notebooks', maximum=True)
    '04'
    >>> next_filenum('/path/to/notebooks', name='my_notebook')
    '02'
    '''
    # Get the list of notebooks in the directory and filter out non-convention notebooks
    notebooks = dir_nbdev(path)

    # If a name is provided return the prefix of the notebook that matches the name
    if name is not None: 
        num = filenum(name, path, notebooks, pad=pad)
        if num: return num
    
    # Otherwise the next available prefix
    return next_prefix(notebooks, maximum=maximum, pad=pad)
