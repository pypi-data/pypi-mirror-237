# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic

from ..core.datetime_utils import serialize_datetime
from .client_facing_source import ClientFacingSource
from .client_facing_sport import ClientFacingSport


class ClientFacingWorkout(pydantic.BaseModel):
    user_id: str = pydantic.Field(
        description=(
            "User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.\n"
        )
    )
    id: str
    title: typing.Optional[str] = pydantic.Field(description=("Title given for the workout\n"))
    timezone_offset: typing.Optional[int] = pydantic.Field(
        description=(
            "Timezone offset from UTC as seconds. For example, EEST (Eastern European Summer Time, +3h) is 10800. PST (Pacific Standard Time, -8h) is -28800::seconds\n"
        )
    )
    average_hr: typing.Optional[int] = pydantic.Field(description=("Average heart rate during workout::bpm\n"))
    max_hr: typing.Optional[int] = pydantic.Field(description=("Max heart rate during workout::bpm\n"))
    distance: typing.Optional[float] = pydantic.Field(description=("Distance travelled during workout::meters\n"))
    calendar_date: str = pydantic.Field(
        description=(
            "Date of the workout summary in the YYYY-mm-dd format. This generally matches the workout start date.\n"
        )
    )
    time_start: dt.datetime = pydantic.Field(description=("Start time of the workout::time\n"))
    time_end: dt.datetime = pydantic.Field(description=("End time of the workout::time\n"))
    calories: typing.Optional[float] = pydantic.Field(description=("Calories burned during the workout::kCal\n"))
    sport: typing.Optional[ClientFacingSport] = pydantic.Field(description=("Sport's name\n"))
    hr_zones: typing.Optional[typing.List[int]] = pydantic.Field(
        description=(
            "Time in seconds spent in different heart rate zones <50%, 50-60%, 60-70%, 70-80%, 80-90%, 90%+. Due to rounding errors, it's possible that summing all values is different than the total time of the workout. Not available for all providers::seconds\n"
        )
    )
    moving_time: typing.Optional[int] = pydantic.Field(description=("Time spent active during the workout::seconds\n"))
    total_elevation_gain: typing.Optional[float] = pydantic.Field(
        description=("Elevation gain during the workout::meters\n")
    )
    elev_high: typing.Optional[float] = pydantic.Field(description=("Highest point of elevation::meters\n"))
    elev_low: typing.Optional[float] = pydantic.Field(description=("Lowest point of elevation::meters\n"))
    average_speed: typing.Optional[float] = pydantic.Field(
        description=("Average speed during workout in m/s::meters/sec\n")
    )
    max_speed: typing.Optional[float] = pydantic.Field(description=("Max speed during workout in m/s::meters/sec\n"))
    average_watts: typing.Optional[float] = pydantic.Field(
        description=("Average watts burned during exercise::watts\n")
    )
    device_watts: typing.Optional[float] = pydantic.Field(description=("Watts burned during exercise::watts\n"))
    max_watts: typing.Optional[float] = pydantic.Field(description=("Max watts burned during exercise::watts\n"))
    weighted_average_watts: typing.Optional[float] = pydantic.Field(
        description=("Weighted average watts burned during exercise::watts\n")
    )
    map: typing.Optional[typing.Dict[str, typing.Any]] = pydantic.Field(
        description=("Map of workouts encoded as polyline\n")
    )
    provider_id: str = pydantic.Field(description=("Provider ID given for that specific workout\n"))
    source: ClientFacingSource = pydantic.Field(description=("Source the data has come from.\n"))

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        json_encoders = {dt.datetime: serialize_datetime}
