# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx
import pydantic

from ...core.api_error import ApiError
from ...core.datetime_utils import serialize_datetime
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_headers import remove_none_from_headers
from ...environment import VitalEnvironment
from ...errors.unprocessable_entity_error import UnprocessableEntityError
from ...types.auth_type import AuthType
from ...types.connection_status import ConnectionStatus
from ...types.demo_connection_status import DemoConnectionStatus
from ...types.demo_providers import DemoProviders
from ...types.email_providers import EmailProviders
from ...types.http_validation_error import HttpValidationError
from ...types.link_token_exchange_response import LinkTokenExchangeResponse
from ...types.manual_providers import ManualProviders
from ...types.o_auth_providers import OAuthProviders
from ...types.password_providers import PasswordProviders
from ...types.provider_link_response import ProviderLinkResponse
from ...types.providers import Providers
from ...types.region import Region
from ...types.source import Source
from ...types.source_link import SourceLink
from ...types.vital_token_created_response import VitalTokenCreatedResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class LinkClient:
    def __init__(self, *, environment: VitalEnvironment = VitalEnvironment.PRODUCTION, api_key: str):
        self._environment = environment
        self.api_key = api_key

    def token(
        self,
        *,
        user_key: str,
        provider: typing.Optional[Providers] = OMIT,
        redirect_url: typing.Optional[str] = OMIT,
        filter_on_providers: typing.Optional[typing.List[Providers]] = OMIT,
    ) -> LinkTokenExchangeResponse:
        _request: typing.Dict[str, typing.Any] = {"user_key": user_key}
        if provider is not OMIT:
            _request["provider"] = provider
        if redirect_url is not OMIT:
            _request["redirect_url"] = redirect_url
        if filter_on_providers is not OMIT:
            _request["filter_on_providers"] = filter_on_providers
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/token"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(LinkTokenExchangeResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def is_token_valid(
        self,
        *,
        token: str,
        is_used: typing.Optional[bool] = OMIT,
        oauth_info: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> typing.Dict[str, typing.Any]:
        _request: typing.Dict[str, typing.Any] = {"token": token}
        if is_used is not OMIT:
            _request["is_used"] = is_used
        if oauth_info is not OMIT:
            _request["oauth_info"] = oauth_info
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/token/isValid"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def code_create(
        self, *, user_id: str, expires_at: typing.Optional[dt.datetime] = None
    ) -> VitalTokenCreatedResponse:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/code/create"),
            params={
                "user_id": user_id,
                "expires_at": serialize_datetime(expires_at) if expires_at is not None else None,
            },
            headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VitalTokenCreatedResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def connect_oauth_provider(
        self, provider: str, *, vital_sdk_no_redirect: typing.Optional[str] = None
    ) -> typing.Dict[str, typing.Any]:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", f"v2/link/connect/{provider}"),
            headers=remove_none_from_headers(
                {"x-vital-sdk-no-redirect": vital_sdk_no_redirect, "x-vital-api-key": self.api_key}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def start_connect(self, *, link_token: str, provider: Providers) -> typing.Dict[str, typing.Any]:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/start"),
            json=jsonable_encoder({"link_token": link_token, "provider": provider}),
            headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def token_state(self) -> typing.Dict[str, typing.Any]:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/state"),
            headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def email_auth(
        self, *, email: str, provider: Providers, auth_type: AuthType, region: typing.Optional[Region] = OMIT
    ) -> ConnectionStatus:
        _request: typing.Dict[str, typing.Any] = {"email": email, "provider": provider, "auth_type": auth_type}
        if region is not OMIT:
            _request["region"] = region
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/auth/email"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConnectionStatus, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def password_auth(
        self,
        *,
        username: str,
        password: str,
        provider: Providers,
        auth_type: AuthType,
        vital_link_client_region: typing.Optional[str] = None,
    ) -> ConnectionStatus:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/auth"),
            json=jsonable_encoder(
                {"username": username, "password": password, "provider": provider, "auth_type": auth_type}
            ),
            headers=remove_none_from_headers(
                {"x-vital-link-client-region": vital_link_client_region, "x-vital-api-key": self.api_key}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConnectionStatus, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate_oauth_link(self, oauth_provider: OAuthProviders) -> Source:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", f"v2/link/provider/oauth/{oauth_provider}"),
            headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Source, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def connect_password_provider(
        self,
        provider: PasswordProviders,
        *,
        username: str,
        password: str,
        vital_link_client_region: typing.Optional[str] = None,
    ) -> ProviderLinkResponse:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", f"v2/link/provider/password/{provider}"),
            json=jsonable_encoder({"username": username, "password": password}),
            headers=remove_none_from_headers(
                {"x-vital-link-client-region": vital_link_client_region, "x-vital-api-key": self.api_key}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProviderLinkResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def connect_email_auth_provider(
        self,
        provider: EmailProviders,
        *,
        email: str,
        email_provider_auth_link_provider: typing.Optional[Providers] = OMIT,
        region: typing.Optional[Region] = OMIT,
    ) -> ConnectionStatus:
        _request: typing.Dict[str, typing.Any] = {"email": email}
        if email_provider_auth_link_provider is not OMIT:
            _request["provider"] = email_provider_auth_link_provider
        if region is not OMIT:
            _request["region"] = region
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", f"v2/link/provider/email/{provider}"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConnectionStatus, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_providers(self) -> typing.List[SourceLink]:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/providers"),
            headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[SourceLink], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def connect_manual_provider(
        self, provider: ManualProviders, *, user_id: str, provider_id: typing.Optional[str] = OMIT
    ) -> typing.Dict[str, bool]:
        _request: typing.Dict[str, typing.Any] = {"user_id": user_id}
        if provider_id is not OMIT:
            _request["provider_id"] = provider_id
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", f"v2/link/provider/manual/{provider}"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, bool], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def connect_demo_provider(self, *, user_id: str, provider: DemoProviders) -> DemoConnectionStatus:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/connect/demo"),
            json=jsonable_encoder({"user_id": user_id, "provider": provider}),
            headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DemoConnectionStatus, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncLinkClient:
    def __init__(self, *, environment: VitalEnvironment = VitalEnvironment.PRODUCTION, api_key: str):
        self._environment = environment
        self.api_key = api_key

    async def token(
        self,
        *,
        user_key: str,
        provider: typing.Optional[Providers] = OMIT,
        redirect_url: typing.Optional[str] = OMIT,
        filter_on_providers: typing.Optional[typing.List[Providers]] = OMIT,
    ) -> LinkTokenExchangeResponse:
        _request: typing.Dict[str, typing.Any] = {"user_key": user_key}
        if provider is not OMIT:
            _request["provider"] = provider
        if redirect_url is not OMIT:
            _request["redirect_url"] = redirect_url
        if filter_on_providers is not OMIT:
            _request["filter_on_providers"] = filter_on_providers
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/token"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(LinkTokenExchangeResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def is_token_valid(
        self,
        *,
        token: str,
        is_used: typing.Optional[bool] = OMIT,
        oauth_info: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> typing.Dict[str, typing.Any]:
        _request: typing.Dict[str, typing.Any] = {"token": token}
        if is_used is not OMIT:
            _request["is_used"] = is_used
        if oauth_info is not OMIT:
            _request["oauth_info"] = oauth_info
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/token/isValid"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def code_create(
        self, *, user_id: str, expires_at: typing.Optional[dt.datetime] = None
    ) -> VitalTokenCreatedResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/code/create"),
                params={
                    "user_id": user_id,
                    "expires_at": serialize_datetime(expires_at) if expires_at is not None else None,
                },
                headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VitalTokenCreatedResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def connect_oauth_provider(
        self, provider: str, *, vital_sdk_no_redirect: typing.Optional[str] = None
    ) -> typing.Dict[str, typing.Any]:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", f"v2/link/connect/{provider}"),
                headers=remove_none_from_headers(
                    {"x-vital-sdk-no-redirect": vital_sdk_no_redirect, "x-vital-api-key": self.api_key}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def start_connect(self, *, link_token: str, provider: Providers) -> typing.Dict[str, typing.Any]:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/start"),
                json=jsonable_encoder({"link_token": link_token, "provider": provider}),
                headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def token_state(self) -> typing.Dict[str, typing.Any]:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/state"),
                headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def email_auth(
        self, *, email: str, provider: Providers, auth_type: AuthType, region: typing.Optional[Region] = OMIT
    ) -> ConnectionStatus:
        _request: typing.Dict[str, typing.Any] = {"email": email, "provider": provider, "auth_type": auth_type}
        if region is not OMIT:
            _request["region"] = region
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/auth/email"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConnectionStatus, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def password_auth(
        self,
        *,
        username: str,
        password: str,
        provider: Providers,
        auth_type: AuthType,
        vital_link_client_region: typing.Optional[str] = None,
    ) -> ConnectionStatus:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/auth"),
                json=jsonable_encoder(
                    {"username": username, "password": password, "provider": provider, "auth_type": auth_type}
                ),
                headers=remove_none_from_headers(
                    {"x-vital-link-client-region": vital_link_client_region, "x-vital-api-key": self.api_key}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConnectionStatus, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate_oauth_link(self, oauth_provider: OAuthProviders) -> Source:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", f"v2/link/provider/oauth/{oauth_provider}"),
                headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Source, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def connect_password_provider(
        self,
        provider: PasswordProviders,
        *,
        username: str,
        password: str,
        vital_link_client_region: typing.Optional[str] = None,
    ) -> ProviderLinkResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", f"v2/link/provider/password/{provider}"),
                json=jsonable_encoder({"username": username, "password": password}),
                headers=remove_none_from_headers(
                    {"x-vital-link-client-region": vital_link_client_region, "x-vital-api-key": self.api_key}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ProviderLinkResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def connect_email_auth_provider(
        self,
        provider: EmailProviders,
        *,
        email: str,
        email_provider_auth_link_provider: typing.Optional[Providers] = OMIT,
        region: typing.Optional[Region] = OMIT,
    ) -> ConnectionStatus:
        _request: typing.Dict[str, typing.Any] = {"email": email}
        if email_provider_auth_link_provider is not OMIT:
            _request["provider"] = email_provider_auth_link_provider
        if region is not OMIT:
            _request["region"] = region
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", f"v2/link/provider/email/{provider}"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConnectionStatus, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_providers(self) -> typing.List[SourceLink]:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/providers"),
                headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[SourceLink], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def connect_manual_provider(
        self, provider: ManualProviders, *, user_id: str, provider_id: typing.Optional[str] = OMIT
    ) -> typing.Dict[str, bool]:
        _request: typing.Dict[str, typing.Any] = {"user_id": user_id}
        if provider_id is not OMIT:
            _request["provider_id"] = provider_id
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", f"v2/link/provider/manual/{provider}"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, bool], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def connect_demo_provider(self, *, user_id: str, provider: DemoProviders) -> DemoConnectionStatus:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "v2/link/connect/demo"),
                json=jsonable_encoder({"user_id": user_id, "provider": provider}),
                headers=remove_none_from_headers({"x-vital-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DemoConnectionStatus, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
