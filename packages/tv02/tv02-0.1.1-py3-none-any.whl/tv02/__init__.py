import pyperclip as pc


def n0():
    s = '''
команды n1() - n11()
в каждой лежит по 1 номеру
принтом выводится задание, а в буфер копируется ответ
P.S. там есть одинаковые задания - смотрите что требуется найти
    '''
    return pc.copy(s)


def n1():
    print('''
В группе учится 29 студентов. Ими были получены следующие 100-балльные оценки: 
90, 79, 53, 62, 66, 68, 75, 0, 82, 29, 0, 29, 68, 90, 0, 60, 44, 44, 70, 68, 70, 89, 0, 68, 0, 66, 0, 59, 70. 
Найдите: 1) А - среднюю положительную оценку в группе; 
2) М - медиану положительных оценок в группе; 
3) Н - среднее гармоническое и G - среднее геометрическое оценок, которые не менее М; 
4) Q - медианную оценку в той части группы, в которой студенты набрали не менее М баллов; 
5) N - количество студентов, оценки которых оказались между Н и Q (включая границы).
    ''')
    s = '''
marks = np.array([90, 79, 53, 62, 66, 68, 75, 0, 82, 29, 0, 29, 68, 90, 0, 60, 44, 44, 70, 68, 70, 89, 0, 68, 0, 66, 0, 59, 70])

print(marks[marks>0].mean())

M = np.median(marks[marks!=0])
print(M)

H = scs.hmean(marks[marks>=M])
print(H)

G = scs.gmean(marks[marks>=M])
print(G)

Q = np.median(marks[marks>=M])
print(Q)

print(len(marks[(marks >= min(H,Q)) & (marks <= max(H,Q))]))    
    '''
    return pc.copy(s)


def n2():
    print('''
Следующие 28 чисел - это умноженные на 10000 и округленные до ближайшего целого дневные логарифмические доходности акции компании АВС:-9, 9, -138, -145, 186, 78, 34, -37, - 19, -68, -82, 158, 96, -189, 24, 84, -99, 125, -39, 26, 62, -91, 239, -211, 2, 129, 2, -16. Будем называть их преобразованными доходностями (ПД). Финансовый аналитик Глеб предполагает, что преобразованные доходности (как и исходные) приближенно распределены по нормальному закону. Чтобы проверить свое предположение Глеб нашел нижнюю квартиль L и верхнюю квартиль Н нормального распределения N(м,0?), для которого и - это среднее арифметическое ПД, а о - эмпирическое стандартное отклонение ПД. Затем Глеб подсчитал количество ПД, попавших в интервал от L до Н (надеясь, что в этот интервал попадет половина ПД). Результат этого вычисления показался ему недостаточно убедительным. Чтобы окончательно развеять сомнения относительно нормальности пд, гиеб построил на одном рисунке графики функций: Ê(х) и F (х), где F (х) - эмпирическая функция распределения ПД, а F (х) - функция распределения N(м,0%). В качестве меры совпадения двух графиков Глеб решил использовать расстояние между функциями F(*) и F(х), которое он вычислил, исходя из определения: d = sup F(x) — F (х)|. 
В ответе укажите результаты вычислений Глеба: 
1) среднее арифметическое ПД; 
2) эмпирическое стандартное отклонение ПД; 
3) квартили L и H; 
4) количество ПД, попавших в интервал от L до Н; 
5) расстояние между функциями F (х) и F (x).
    ''')
    s = '''
vals = np.array([-9, 9, -138, -145, 186, 78, 34, -37, -19, -68, -82, 158, 96, -189, 24, 84, -99, 125, -39, 26, 62, -91, 239, \
                -211, 2, 129, 2, -16])

v_mean = vals.mean()
v_std = vals.std()
print(v_mean, v_std)

X = scs.norm(v_mean, v_std)
L = X.ppf(0.25)
H = X.ppf(0.75)
print(L, H)

print(len(vals[(vals >= L) & (vals <= H)]))

xsort=sorted(vals)
n=len(xsort)

res_d = float('-inf')
for i in range(len(xsort)):
    maxx=max(abs((i+1)/n-X.cdf(xsort[i])),abs((i)/n-X.cdf(xsort[i])))
    if maxx > res_d:
        res_d = maxx
        d_ind = i
print(res_d)
    '''
    return pc.copy(s)


def n3():
    print('''
Ω
В группе Ω учатся студенты: w1,..., w30. Пусть Х и У - 100-бальные экзаменационные оценки по математическому анализу и теории вероятностей. Оценки студента wi; обозначаются: х; = X(wi) и уі = Y(wі),
i= 1,.,30. все оценки известны: 21 = 71,31 = 71,22 = 52,02 = 58, 23 = 72,03 = 81, 24 = 87,04 = 92, 25 = 81,95 = 81, 26 = 100,96 594, 27 = 90, 87 = 96, 28 = 54, U8 = 46, 20 = 54, 29 = 60, 210 = 58,810 = 62, 211 = 56,311 = 49, 212 = 70,812 = 60, 213 = 93,813 = 86, 214 = 46, 814 = 48, 215 = 56, 915 = 61, 216 = 59,916 = 52, 217 = 42,217 = 40, 218 = 60, 318 = 60, 219 = 33, 019 = 37, 220 = 83,020 =92
221 = 50,821 = 57, 222 = 93, 322 = 93, 223 = 41,823 = 42, 224 = 55,824 = 64, 225 = 60, 825 = 59, 226 = 37,026 30, 227 = 71,227 = 71, 228 = 42, 28 = 44, 229 = 85,029 = 82, 230 = 39,030 = 39. 
Требуется найти следующие условные эмпирические характеристики: 
1) ковариацию Х и У при условии, что одновременно Х ≥ 50 и У > 50; 
2) коэффициент корреляции Х и У при том же условии.
    ''')
    s = '''
import re

s = '' 'x1=71,y1=71
 , x2=52,y2=58
, x3=72,y3=81
, x4=87,y4=92
, x5=81,y5=81
, x6=100,y6=94
, x7=90,y7=96
, x8=54,y8=46
, x9=54,y9=60
, x10=58,y10=62
, x11=56,y11=49
, x12=70,y12=60
, x13=93,y13=86
, x14=46,y14=48
, x15=56,y15=61
, x16=59,y16=52
, x17=42,y17=40
, x18=60,y18=60
, x19=33,y19=37
, x20=83,y20=92
, x21=50,y21=57
, x22=93,y22=93
, x23=41,y23=42
, x24=55,y24=64
, x25=60,y25=59
, x26=37,y26=30
, x27=71,y27=71
, x28=42,y28=44
, x29=85,y29=82
, x30=39,y30=39
'' '
match = re.findall(r'=(\d+)', s)
x_all = list(map(int, match[::2]))
y_all = list(map(int, match[1::2]))

x = []
y = []

for x_t, y_t in zip(x_all, y_all):
    if x_t >= 50 and y_t >= 50:
        x.append(x_t)
        y.append(y_t)
        
x = np.array(x)
y = np.array(y)

cov = (x * y).mean() - x.mean() * y.mean()
print(cov)
print(cov/np.sqrt(x.var()*y.var()))
    '''
    return pc.copy(s)


def n4():
    print('''
Поток Ω состоит из k групп: 521, ..., Як, k = 3. На потоке учатся п = 1+... +пк студентов, где п - число студентов в группе 0;, і = 1,...,k. Пусть Х(ш) - 100-балльная оценка студента ш € 52. Далее
используются следующие обозначения: х; - среднее значение, о - (эмпирическое) стандартное отклонение признака Х на группе 52 • Дано: n1 = 24, п2 = 26, пз = 30, Х1 = 70, Х2 = 76, 73 = 77, 01 = 4, 02 = 6, 03 = 8. 
Требуется найти: 
1) среднее значение Х на потоке ; 
2) (эмпирическое) стандартное отклонение Х на потоке S
    ''')
    s = '''
n1=24
n2=26
n3=30
xm1=70
xm2=76
xm3=77
si1=4
si2=6
si3=8

M = (n1 * xm1 + n2 * xm2 + n3 * xm3)/(n1 + n2 + n3)
print(M)

var_all = (n1 * (xm1 - M)**2 + n2 * (xm2 - M)**2 + n3 * (xm3 - M)**2)/(n1 + n2 + n3)
var_mean_all = (n1 * si1**2 + n2 * si2**2 + n3 * si3**2)/(n1 + n2 + n3)
print(np.sqrt(var_all + var_mean_all))
    '''
    return pc.copy(s)


def n5():
    print('''
В группе Ω учатся 27 студентов, Ω = {1,2,..., 27). Пусть Х(г) - 100-балльная оценка студента і € 52. Из группы 52 случайным образом 7 раз выбирается студент w € . Повторный выбор допускается. Пусть ш; -
студент, полученный после выбора j = 1,...,7, X(w;) - его оценка. Среднюю оценку на случайной выборке обозначим Х = 7 L X(w;). Оценки в группе даны: 100, 86, 51, 100, 95, 100, 12, 61, 0, 0, 12, 86, 0, 52, 62, 76, 91, 91, 62, 91, 65, 91, 9, 83, 67, 58, 56. 
Требуется найти: 
1) дисперсию Var(X); 
2) центральный момент из (Х).
    ''')
    s = '''
vals = np.array([100, 86, 51, 100, 95, 100, 12, 61, 0, 0, 12, 86, 0, 52, 62, 76, 91, 91, 62, 91, 65, 91, 9, 83, 67, 58, 56])
N = 27
n = 7

print(vals.var()/n)
print((1/N * sum((vals-vals.mean())**3))/n**2)
    '''
    return pc.copy(s)


def n6():
    print('''
В группе Ω учатся 27 студентов, Ω = {1,2,...,27}. Пусть Х(і) - 100-бальная оценка студента і є 2. Из группы 5 случайным образом 6 раз выбирается студент ш € Я. Повторный выбор не допускается. Пусть ш;
- студент, полученный после выбора j = 1,..., 6, X(w;) - его оценка. Среднюю оценку на случайной выборке обозначим X = $ 2 X(;). Оценки в группе даны: 100, 78, 77, 51, 82, 100, 73, 53, 78, 55, 7, 0, 81, 15, 96, 12, 71, 70, 53, 0, 73, 100, 55, 100, 59, 89, 81. 
Требуется найти: 
1) математическое ожидание E(X); 
2) дисперсию Var(X).
    ''')
    s = '''
vals = np.array([100, 78, 77, 51, 82, 100, 73, 53, 78, 55, 7, 0, 81, 15, 96, 12, 71, 70, 53, 0, 73, 100, 55, 100, 59, 89, 81])
N = 27
n = 6

print(vals.mean())
print(vals.var()/n * (N - n)/(N - 1))
    '''
    return pc.copy(s)


def n7():
    print('''
Распределение баллов на экзамене до перепроверки задано таблицей

Оценка работы | 2  3  4  5
Число работ   | 7 48  8 105

Работы будут перепроверять 6 преподавателей, которые разделили все работы между собой поровну случайным образом. Пусть Х - средний балл (до перепроверки) работ, попавших к одному из преподавателей. 
Требуется найти: 
1) математическое ожидание E(X); 
2) стандартное отклонение о(Х).
    ''')
    s = '''
N = sum([7, 48, 8, 105])
n = N / 6

vals = np.array([2, 3, 4, 5])
prob = np.array([7, 48, 8, 105])
prob = prob/sum(prob)

print(sum(vals * prob))
print(np.sqrt((sum(vals**2 * prob) - sum(vals * prob)**2) / n * (N - n) / (N - 1)))
    '''
    return pc.copy(s)


def n8():
    print('''
Две игральные кости, красная и синяя, подбрасываются до тех пор, пока не выпадет 19 различных (с учетом цвета) комбинаций очков. Пусть R; - число очков на красной кости, а В; - число очков на синей кости
в комбинации с номером і. Случайные величины Х; задаются соотношениями: Х; = 11R; - 9B;, і = 1,..., 19. Среднее арифметическое этих величин обозначим Х = 1/19 [ Х. 
Требуется найти:
1)математическое ожидание E(X); 
2) стандартное отклонение о(Х).
    ''')
    s = '''
N = 36
n = 19

vals = []

for r in range(1, 7):
    for b in range(1, 7):
        vals.append(11 * r - 9 * b)
vals = np.array(vals)

print(vals.mean())
print(np.sqrt(vals.var() / n * (N - n)/(N - 1)))
    '''
    return pc.copy(s)


def n9():
    print('''
Имеется 11 пронумерованных монет. Монеты подбрасываются до тех пор, пока не выпадет 257 различных (с учетом номера монеты) комбинаций орел-решка. Пусть Хі - число орлов в комбинации с номером і; a X = 1/257 [ X, - среднее число орлов в полученных таким образом комбинациях. 
Требуется найти: 
1) математическое ожидание E(X);
2) дисперсию Var (X).
    ''')
    s = '''
import itertools as it
N = 2 ** 11
n = 257
q = 11

combs = np.array(list(it.product([0, 1], repeat=q)))
print(combs.mean() * q)
print(combs.var() * q / n * (N - n)/(N - 1))
    '''
    return pc.copy(s)


def n10():
    print('''
Эмпирическое распределение признаков X и У на генеральной совокупности Ω = {1, 2,..., 100} задано таблицей частот

///// y=1 | y=2 | y=3
x=100  11    32    11
x=400  24    11    11

Из Ω случайным образом без возвращения извлекаются 7 элементов. Пусть X и У - средние значения признаков на выбранных элементах. 
Требуется найти: 
1) математическое ожидание E(X); 
2) дисперсию Var (Y); 
3) коэффициент корреляции р(Х, У).
    ''')
    s = '''
vals = [(100, 1)] * 11 + [(100, 2)] * 32 + [(100, 3)] * 11 + \
[(400, 1)] * 24 + [(400, 2)] * 11 + [(400, 3)] * 11
n = 7

vals = np.array(vals)
N = len(vals)
E_X = vals.mean(axis=0)[0]
print(E_X)

Var_Y = vals.var(axis=0)[1]
Var_Y = Var_Y / n * (N - n) / (N - 1)
print(Var_Y)

cov = ((vals[:, 0] * vals[:, 1]).mean() - vals[:, 0].mean() * vals[:, 1].mean()) / n * (N - n) / (N - 1)
Var_X = vals.var(axis=0)[0]
Var_X = Var_X / n * (N - n) / (N - 1)

print(cov/np.sqrt(Var_Y * Var_X))
    '''
    return pc.copy(s)


def n11():
    print('''
Эмпирическое распределение признаков X и У на генеральной совокупности Ω = {1,2,..,100} задано таблицей частот

///// y=1 | y=2 | y=4
x=100  21    17    12
x=300  10    27    13

Из Ω случайным образом без возвращения извлекаются 6 элементов. Пусть Х и У - средние значения признаков на выбранных элементах. 
Требуется найти: 
1) математическое ожидание E(Y); 
2) стандартное отклонение о(Х); 
3) ковариацию Cov(X,Y).
    ''')
    s = '''
vals = [(100, 1)] * 21 + [(100, 2)] * 17 + [(100, 4)] * 12 + \
[(300, 1)] * 10 + [(300, 2)] * 27 + [(300, 4)] * 13

n = 6
N = len(vals)
vals= np.array(vals)

print(vals.mean(axis=0)[1])
Var_X = vals.var(axis=0)[0]
Var_X = Var_X / n * (N - n)/(N - 1)
print(np.sqrt(Var_X))
print(((vals[:, 0] * vals[:, 1]).mean()- vals.mean(axis=0)[0] * vals.mean(axis=0)[1])/ n * (N - n)/(N - 1))
    '''
    return pc.copy(s)
