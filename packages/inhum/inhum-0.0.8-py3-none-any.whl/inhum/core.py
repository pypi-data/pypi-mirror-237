# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['InhEnumMeta', 'InhEnum', 'Mixin', 'enumdict', 'vvalue', 'get_inherited_members', 'InhumMeta', 'Inhum']

# %% ../nbs/00_core.ipynb 4
import copy
from enum import Enum, EnumMeta, _EnumDict, member
from typing import Any, Type, Callable, Optional, NamedTuple

# %% ../nbs/00_core.ipynb 5
from chck import isdunder
from nlit import (NAME, VALUE, MIXINS, ASMEMBER, __MEMBERS__, __METACLASS__, OVERWRITABLE)

# %% ../nbs/00_core.ipynb 7
class Mixin(NamedTuple):
    '''NamedTuple for storing Enum Mixin information. 
    The `fnc` is only called if the enum value is an instance of the `cls` type.

    Attributes
    ----------
    cls : type
        The type to be called upon.

    fnc : Callable
        The function for applying the mixin.
    '''
    cls: type
    fnc: Callable

# %% ../nbs/00_core.ipynb 9
def enumdict(name: str) -> _EnumDict:
    '''Create and return a new enumeration dictionary.

    Parameters
    ----------
    name : str
        The name of the enumeration.

    Returns
    -------
    _EnumDict
        The new enumeration dictionary.
    ''' 
    newdict = _EnumDict()
    newdict._cls_name = name
    return newdict

def vvalue(v: Any) -> Any:
    '''Enum `member` value getter. 
    Useful if you do not know if you are working with an Enum's member or an Enum's member value.
    
    Parameters
    ----------
    v : Any
        The object to check.

    Returns
    -------
    Any
        The `value` attribute or the object itself.

    '''
    return v.value if hasattr(v, VALUE) else v

def get_inherited_members(bases: tuple) -> dict:
    '''Get members inherited from base classes.

    Parameters
    ----------
    bases : tuple
        Tuple of base classes i.e. `inspect.getmro(cls)`.

    Returns
    -------
    dict
        Dictionary of inherited members.
    '''
    members = dict()
    for base in bases: 
        members.update(**getattr(base, __MEMBERS__, {}))
    return members

# %% ../nbs/00_core.ipynb 11
class InhumMeta(EnumMeta):
    '''Custom metaclass for enumerations that support inheritance.

    Attributes
    ----------
    None

    Methods
    -------
    haskey(clsdict, key)
        Check if a key exists.

    delkey(clsdict, key)
        Delete a key.

    dupval(clsdict, val, *args, **kwargs)
        Duplicate a value.

    setval(clsdict, key, val)
        Set a value.

    setmem(clsdict, key, val = None, *args, **kwargs)
        Set a member.

    __copydict__(clsdict, *args, **kwargs)
        Create a copy of the dictionary.

    __prepare__(name, bases, **kwargs)
        Prepare the class dictionary.

    __new__(metacls, name, bases, clsdict, **kwargs)
        Create a new instance.

    _missing_(cls, value)
        Handle missing values.

    __contains__(self, key)
        Check if a key exists.

    update(cls, update: Callable = identity, *args, inplace: bool = False, **kwargs)
        Update members.
    
    '''
    @classmethod
    def haskey(metacls, clsdict: _EnumDict, key: str) -> bool:
        '''Check if a key exists in the enumeration dictionary or in member names.

        Parameters
        ----------
        clsdict : _EnumDict
            The enumeration dictionary.

        key : str
            The key to check.

        Returns
        -------
        bool
            True if the key exists, False otherwise.        
        '''
        return key in clsdict or key in clsdict._member_names
    
    @classmethod
    def delkey(metacls, clsdict: _EnumDict, key: str):
        '''Delete a key from the enumeration dictionary and member names if it exists.

        Parameters
        ----------
        clsdict : _EnumDict
            The enumeration dictionary.

        key : str
            The key to delete.
        '''
        if not metacls.haskey(clsdict, key): return
        clsdict.__delitem__(key)
        clsdict._member_names.pop(key)
    @classmethod
    def dupval(metacls, clsdict: _EnumDict, val: Any, *args, **kwargs) -> any:
        '''Duplicate a value within the enumeration dictionary.

        Parameters
        ----------
        clsdict : _EnumDict
            The enumeration dictionary.

        val : Any
            The value to duplicate.

        args : tuple
            Additional arguments.

        kwargs : dict
            Additional keyword arguments. Supports `mixins` and `asmember`.

        Other Parameters
        ----------------
        mixins : list, optional
            List of `Mixin` named tuples. Used to apply mixins to the value if the value is
            an instance of the `Mixin.cls` attribute.

        asmember : bool, optional
            Whether to return the value as a member. Defaults to False.

        Returns
        -------
        Any
            The duplicated value. 
        '''
        mixins = kwargs.get(MIXINS, []) or getattr(metacls, MIXINS, [])
        asmemb = kwargs.get(ASMEMBER, False)
        newval = copy.deepcopy(vvalue(val))
        for (mix, hook) in mixins:
            if isinstance(newval, mix):
                newval = hook(newval, *args, **kwargs)
        return member(newval) if asmemb else newval
    
    @classmethod
    def setval(metacls, clsdict: _EnumDict, key: str, val: Any):
        '''Set a value for a given key within the enumeration dictionary.

        Parameters
        ----------
        clsdict : _EnumDict
            The enumeration dictionary.

        key : str
            The key to set.

        val : Any
            The value to set.
        '''
        clsdict.__setitem__(key, val)
        clsdict._member_names[key] = clsdict[key]
    
    @classmethod
    def setmem(metacls, clsdict: _EnumDict, key: str, val: Optional[Any] = None, *args, **kwargs) -> _EnumDict:
        '''Set a member in the enumeration dictionary.

        Parameters
        ----------
        clsdict : _EnumDict
            The enumeration dictionary.

        key : str
            The key for the member.

        val : Any, optional
            The value for the member. Defaults to None.

        args : tuple
            Additional arguments.

        kwargs : dict
            Additional keyword arguments. Expects `asmember`.

        Other Parameters
        ----------------
        mixins : list, optional
            List of `Mixin` named tuples. Used to apply mixins to the value if the value is
            an instance of the `Mixin.cls` attribute.

        asmember : bool, optional
            Whether to return the value as a member. Defaults to False.

        Returns
        -------
        _EnumDict
            The updated enumeration dictionary.        
        '''
        if metacls.haskey(clsdict, key): 
            if val is None: val = clsdict.__getitem__(key)            
            try: metacls.delkey(clsdict, key)
            except AttributeError: pass
        kwargs.update(asmember=True)
        metacls.setval(clsdict, key, metacls.dupval(clsdict, val, *args, **kwargs))
        return clsdict

    @classmethod
    def __copydict__(metacls, clsdict: _EnumDict, *args, **kwargs) -> _EnumDict:
        '''
        Create a deep copy of the enumeration dictionary.

        Parameters
        ----------
        clsdict : _EnumDict
            The enumeration dictionary.

        args : tuple
            Additional arguments.

        kwargs : dict
            Additional keyword arguments. Expects `asmember`.

        Other Parameters
        ----------------
        mixins : list, optional
            List of `Mixin` named tuples. Used to apply mixins to the value if the value is
            an instance of the `Mixin.cls` attribute.

        asmember : bool, optional
            Whether to return the value as a member. Defaults to False.

        Returns
        -------
        _EnumDict
            The copied enumeration dictionary.
        '''        
        newdict = enumdict(clsdict._cls_name)
        kwargs.setdefault(ASMEMBER, False)
        for k, v in clsdict.items():
            newdict[k] = metacls.dupval(clsdict, v, *args, **kwargs)
        return newdict
    
    def _check_for_existing_members_(class_name, bases):
        '''Check for existing members in base classes.

        Parameters
        ----------
        class_name : str
            The name of the enumeration class being created.

        bases : tuple
            Base classes.
        '''
        pass
    
    @classmethod
    def __prepare__(metacls, name: str, bases: tuple, **kwargs: Any) -> _EnumDict:
        '''Prepare the enumeration dictionary before class creation.

        Parameters
        ----------
        name : str
            The name of the enumeration.
            
        bases : tuple
            Base classes.

        kwargs : dict
            Keyword arguments.

        Returns
        -------
        _EnumDict
            The prepared enumeration dictionary.
        '''
        clsdict = enumdict(name)
        # NOTE: this does inheritance
        members = get_inherited_members(bases)        
        for key, val in members.items():
            if isdunder(key): continue
            clsdict = metacls.setmem(clsdict, key, val, **kwargs)

        okeys = kwargs.get(OVERWRITABLE, [])
        for okey in okeys: metacls.delkey(clsdict, okey)
        return clsdict
    
    def __new__(metacls, name, bases, clsdict, **kwargs):
        '''Create a new enumeration class.

        Parameters
        ----------
        name : str
            The name of the enumeration.

        bases : tuple
            Base classes.

        clsdict : _EnumDict
            The enumeration dictionary.

        kwargs : dict
            Additional keyword arguments.

        Returns
        -------
        Type[Enum]
            The newly created enumeration class.        
        '''
        newdict = metacls.__copydict__(clsdict, **kwargs)
        newcls = super().__new__(metacls, name, bases, newdict)
        return newcls
    
    @classmethod
    def _missing_(cls, value):
        '''
        Method called for missing members during lookup.

        Parameters
        ----------
        value : Any
            The missing value.

        Returns
        -------
        None
            Always returns None.        
        '''
        return None
    
    def __contains__(self, key):
        '''
        Check if the key exists in the enumeration's members.

        Parameters
        ----------
        key : str
            The key to check.

        Returns
        -------
        bool
            True if the key exists, otherwise False.
        '''
        return key in self._member_map_ or key in self._member_names_

    
    def update(cls: Type[Enum], update: Callable[..., Any], *args: Any, inplace: bool = False, **kwargs: Any) -> Optional[Type[Enum]]:
        '''Update the enumeration class members.

        Parameters
        ----------
        update : Callable
            The update function to apply to each member.

        args : tuple
            Additional arguments to pass to the `update` function.

        inplace : bool, optional
            Whether to modify the class in-place. Defaults to False.

        kwargs : dict
            Additional keyword arguments to pass to the `update` function.
            Of note is that the following keyword argumentsa are passed in for the
            user's convenience.
            `__key`
                The member name.
            `__val`
                The member value.
            `inplace`
                Whether to modify the class in-place.


        Returns
        -------
        Type[Enum]
            The updated enumeration class if `inplace` is False, otherwise None.
        '''
        if inplace:
            kls = copy.deepcopy(cls)
            for n, v in kls.__members__.items():
                update(v, *args, __key=n, __val=v, inplace=inplace, **kwargs)
        else:
            clsname = kwargs.get(NAME, cls.__name__)
            clsdict = enumdict(clsname)
            memdict = {mem.name: member(copy.deepcopy(mem.value)) for mem in cls}        
            for n, v in memdict.items():
                clsdict[n] = update(v, *args, __key=n, __val=v, inplace=inplace, **kwargs)
            clsdict[__METACLASS__] = type(cls)
            kls = type(clsname, (cls, ), clsdict)
        return kls
    
InhEnumMeta = InhumMeta

# %% ../nbs/00_core.ipynb 13
class Inhum(Enum, metaclass=InhumMeta):
    ...

InhEnum = Inhum
