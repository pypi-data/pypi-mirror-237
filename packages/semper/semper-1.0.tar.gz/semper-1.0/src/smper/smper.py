import os.path


class norm:


    def rvs(number, search=0):
        sklad = {
0:
        """
В группе учится 29 студентов. Ими были получены следующие 100-балльные оценки: 90, 79, 53, 62, 66, 68, 75, 0, 82, 29, 0, 29, 68, 90, 0, 60, 44, 44, 70, 68, 70, 89, 0, 68, 0, 66, 0, 59, 70. Найдите: 1) A – среднюю положительную оценку в группе; 2) M – медиану положительных оценок в группе; 3) H – среднее гармоническое и G – среднее геометрическое оценок, которые не менее M; 4) Q – медианную оценку в той части группы, в которой студенты набрали не менее M баллов; 5) N – количество студентов, оценки которых оказались между H и Q (включая границы).


sample = np.array([90, 79, 53, 62, 66, 68,75, 0, 82, 29, 0, 29, 68,90, 0, 60, 44, 44, 70, 68,70, 89, 0, 68, 0, 66, 0, 59,70])

A = np.mean(sample[sample > 0])
M = np.median(sample[sample > 0])
H = stats.hmean(sample[sample >= M])
G = stats.gmean(sample[sample >= M])
Q = np.median(sample[sample >= M])
N = sample[(sample >= min(H,Q))*(sample <= max(H,Q))].shape[0]

A,M,H,G,Q,N
""",
1:
"""
Следующие 28 чисел – это умноженные на 10000 и округленные до ближайшего целого дневные логарифмические доходности акции компании АВС: -9, 9, -138, -145, 186, 78, 34, -37, -19, -68, -82, 158, 96, -189, 24, 84, -99, 125, -39, 26, 62, -91, 239, -211, 2, 129, 2, -16. Будем называть их преобразованными доходностями (ПД). Финансовый аналитик Глеб предполагает, что преобразованные доходности (как и исходные) приближенно распределены по нормальному закону. Чтобы проверить свое предположение Глеб нашел нижнюю квартиль L и верхнюю квартиль H нормального распределения N(μ,σ2) , для которого μ – это среднее арифметическое ПД, а σ – эмпирическое стандартное отклонение ПД. Затем Глеб подсчитал количество ПД, попавших в интервал от L до H (надеясь, что в этот интервал попадет половина ПД). Результат этого вычисления показался ему недостаточно убедительным. Чтобы окончательно развеять сомнения относительно нормальности ПД, Глеб построил на одном рисунке графики функций: F̂ (x) и F(x) , где F̂ (x) – эмпирическая функция распределения ПД, а F(x) – функция распределения N(μ,σ2) . В качестве меры совпадения двух графиков Глеб решил использовать расстояние d между функциями F̂ (x) и F(x) , которое он вычислил, исходя из определения: d=sup|F̂ (x)−F(x)| . В ответе укажите результаты вычислений Глеба: 1) среднее арифметическое ПД; 2) эмпирическое стандартное отклонение ПД; 3) квартили L и H; 4) количество ПД, попавших в интервал от L до H; 5) расстояние между функциями F̂ (x) и F(x) .

def F(x,sample):
    return sum(sample<=x)/sample.shape[0]
sample = np.array([-9, 9, -138, -145, 186,78, 34, -37, -19, -68,-82, 158, 96, -189, 24,84, -99, 125, -39, 26,62, -91, 239, -211, 2,129, 2, -16])

mu = np.mean(sample)
std = np.std(sample)
N = stats.norm(mu,std)
L = N.ppf(0.25)
H = N.ppf(0.75)
L_H = sample[(sample >= L)*(sample <= H)]
D = max([abs(F(x,sample) - N.cdf(x)) for x in sample])

mu,std,L,H,L_H.shape[0],D
""",
2:
"""
В группе Ω учатся студенты: ω1,...,ω30 . Пусть X и Y – 100-балльные экзаменационные оценки по математическому анализу и теории вероятностей. Оценки студента ωi обозначаются: xi=X(ωi) и yi=Y(ωi) , i=1,...,30 . Все оценки известны: x1=71,y1=71 , x2=52,y2=58 , x3=72,y3=81 , x4=87,y4=92 , x5=81,y5=81 , x6=100,y6=94 , x7=90,y7=96 , x8=54,y8=46 , x9=54,y9=60 , x10=58,y10=62 , x11=56,y11=49 , x12=70,y12=60 , x13=93,y13=86 , x14=46,y14=48 , x15=56,y15=61 , x16=59,y16=52 , x17=42,y17=40 , x18=60,y18=60 , x19=33,y19=37 , x20=83,y20=92 , x21=50,y21=57 , x22=93,y22=93 , x23=41,y23=42 , x24=55,y24=64 , x25=60,y25=59 , x26=37,y26=30 , x27=71,y27=71 , x28=42,y28=44 , x29=85,y29=82 , x30=39,y30=39 . Требуется найти следующие условные эмпирические характеристики: 1) ковариацию X и Y при условии, что одновременно X⩾50 и Y⩾50 ; 2) коэффициент корреляции X и Y при том же условии.
x = [71, 52, 72, 87, 81, 100, 90, 54, 54, 58, 56, 70, 93, 46, 56, 59, 42, 60, 33, 83, 50, 93, 41, 55, 60, 37, 71, 42, 85, 39]
y = [71, 58, 81, 92, 81, 94, 96, 46, 60, 62, 49, 60, 86, 48, 61, 52, 40, 60, 37, 92, 57, 93, 42, 64, 59, 30, 71, 44, 82, 39]

f_x = [xi for xi, yi in zip(x, y) if xi >= 50 and yi >= 50]
f_y = [yi for xi, yi in zip(x, y) if xi >= 50 and yi >= 50]

mean_x = np.mean(f_x)
mean_y = np.mean(f_y)

var_x = np.var(f_x)
var_y = np.var(f_y)

cov = sum([(xi - mean_x) * (yi - mean_y) for xi, yi in zip(f_x, f_y)]) / (len(f_x))
corr = cov / (var_x**0.5 * var_y**0.5)

cov,corr
""",
3:
"""
Поток Ω состоит из k групп: Ω1,...,Ωk , k=3 . На потоке учатся n=n1+...+nk студентов, где ni – число студентов в группе Ωi , i=1,...,k . Пусть X(ω) – 100-балльная оценка студента ω∈Ω . Далее используются следующие обозначения: xi – среднее значение, σi – (эмпирическое) стандартное отклонение признака X на группе Ωi . Дано: n1=24 , n2=26 , n3=30 , x1=70 , x2=76 , x3=77 , σ1=4 , σ2=6 , σ3=8 . Требуется найти: 1) среднее значение X на потоке Ω ; 2) (эмпирическое) стандартное отклонение X на потоке Ω .

n1, n2, n3 = 24, 26, 30
x_1, x_2, x_3 = 70, 76, 77
sigma_1, sigma_2, sigma_3 = 4, 6, 8

n = n1 + n2 + n3

# Вычисление матожидания X для всего потока Ω
x_b = (n1 * x_1 + n2 * x_2 + n3 * x_3) / n

# Вычисление эмпирического стандартного отклонения X для всего потока Ω


#Формула: (1/n)*sum(n_i * sigma_i**2) + (1/n)*(sum(ni*(x_i-x_b)**2)). Для того чтобы при разных k (3 или 4) можно было обощить код
var = (1/n) * (n1 * sigma_1**2 + n2 * sigma_2**2 + n3 * sigma_3**2) + (1/n) * (n1 * (x_1 - x_b)**2 + n2 * (x_2 - x_b)**2 + n3 * (x_3 - x_b)**2)
sigma = var**0.5

x_b, sigma

""",
4:
"""
Поток Ω состоит из k групп: Ω1,...,Ωk , k=4 . На потоке учатся n=n1+...+nk студентов, где ni – число студентов в группе Ωi , i=1,...,k . Пусть X(ω) – 100-балльная оценка студента ω∈Ω . Далее используются следующие обозначения: xi – среднее значение, σi – (эмпирическое) стандартное отклонение признака X на группе Ωi . Дано: n1=29 , n2=21 , n3=22 , n4=28 , x1=74 , x2=75 , x3=76 , x4=77 , σ1=6 , σ2=7 , σ3=9 , σ4=5 . Требуется найти: 1) среднее значение X на потоке Ω ; 2) (эмпирическое) стандартное отклонение X на потоке Ω .

n1, n2, n3, n4 = 29, 21, 22, 28
x_bar_1, x_bar_2, x_bar_3, x_bar_4 = 74, 75, 76, 77
sigma_1, sigma_2, sigma_3, sigma_4 = 6, 7, 9, 5

n = n1 + n2 + n3 + n4

x_bar = (n1 * x_bar_1 + n2 * x_bar_2 + n3 * x_bar_3 + n4 * x_bar_4) / n

#Формула: (1/n)*sum(n_i * sigma_i**2) + (1/n)*(sum(ni*(x_i-x_b)**2)). Для того чтобы при разных k (3 или 4) можно было обощить код

variance = (1/n) * (n1 * sigma_1**2 + n2 * sigma_2**2 + n3 * sigma_3**2 + n4 * sigma_4**2) + (1/n) * (n1 * (x_bar_1 - x_bar)**2 + n2 * (x_bar_2 - x_bar)**2 + n3 * (x_bar_3 - x_bar)**2 + n4 * (x_bar_4 - x_bar)**2)

# Extracting the standard deviation from the variance
sigma_new = variance**0.5

x_bar, sigma_new
""",
5:
"""
В группе Ω учатся 27 студентов, Ω={1,2,...,27} . Пусть X(i) – 100-балльная оценка студента i∈Ω . Из группы Ω случайным образом 7 раз выбирается студент ω∈Ω . Повторный выбор допускается. Пусть ωj – студент, полученный после выбора j=1,...,7 , X(ωj) – его оценка. Среднюю оценку на случайной выборке обозначим X⎯⎯⎯⎯=17∑X(ωj) . Оценки в группе даны: 100, 86, 51, 100, 95, 100, 12, 61, 0, 0, 12, 86, 0, 52, 62, 76, 91, 91, 62, 91, 65, 91, 9, 83, 67, 58, 56. Требуется найти: 1) дисперсию Var(X⎯⎯⎯⎯) ; 2) центральный момент μ3(X⎯⎯⎯⎯) .

marks = np.array([100, 86, 51, 100, 95, 100, 12, 61, 0, 0, 12, 86, 0, 52, 62, 76, 91, 91, 62, 91, 65, 91, 9, 83, 67, 58, 56])
n = 7
E_x = marks.mean()
var_x = marks.var()
var_ = var_x / n
mu3 = 1 / len(marks) * sum((marks - E_x) ** 3)
mu3_ = mu3 / n ** 2

var_,mu3_
""",
6:
"""
В группе Ω учатся 27 студентов, Ω={1,2,...,27} . Пусть X(i) – 100-балльная оценка студента i∈Ω . Из группы Ω случайным образом 6 раз выбирается студент ω∈Ω . Повторный выбор не допускается. Пусть ωj – студент, полученный после выбора j=1,...,6 , X(ωj) – его оценка. Среднюю оценку на случайной выборке обозначим X⎯⎯⎯⎯=16∑X(ωj) . Оценки в группе даны: 100, 78, 77, 51, 82, 100, 73, 53, 78, 55, 7, 0, 81, 15, 96, 12, 71, 70, 53, 0, 73, 100, 55, 100, 59, 89, 81. Требуется найти: 1) математическое ожидание E(X⎯⎯⎯⎯) ; 2) дисперсию Var(X⎯⎯⎯⎯) .

marks = np.array([100, 78, 77, 51, 82, 100, 73, 53, 78, 55, 7, 0, 81, 15, 96, 12, 71, 70, 53, 0, 73, 100, 55, 100, 59, 89, 81])
E_X = marks.mean()
Var_X = marks.var()
N = len(marks)
n = 6
E_X_ = E_X
Var_X_ = Var_X * (N - n) / (n * (N - 1))
E_X_, Var_X_
""",
7:
"""
Распределение баллов на экзамене до перепроверки задано таблицей. Работы будут перепроверять 6 преподавателей, которые разделили все работы между собой поровну случайным образом. Пусть X⎯⎯⎯⎯ – средний балл (до перепроверки) работ, попавших к одному из преподавателей. Требуется найти: 1) математическое ожидание E(X⎯⎯⎯⎯) ; 2) стандартное отклонение σ(X⎯⎯⎯⎯) .
marks = np.array([2] * 7 + [3] * 48 + [4] * 8 + [5] * 105)
E_X = marks.mean()
Var_X = marks.var()
N = len(marks)
n = N / 6
E_X_ = E_X
sigma_X_ = np.sqrt(Var_X * (N - n) / (n * (N - 1)))
E_X_,sigma_X_
""",
8:
"""
Две игральные кости, красная и синяя, подбрасываются до тех пор, пока не выпадет 19 различных (с учетом цвета) комбинаций очков. Пусть Ri – число очков на красной кости, а Bi – число очков на синей кости в комбинации с номером i . Случайные величины Xi задаются соотношениями: Xi=11Ri−9Bi,i=1,...,19 . Среднее арифметическое этих величин обозначим X⎯⎯⎯⎯=119∑Xi . Требуется найти: 1) математическое ожидание E(X⎯⎯⎯⎯) ; 2) стандартное отклонение σ(X⎯⎯⎯⎯) .
E_R = 3.5 # стандартные значения для монетки
E_B = 3.5
Var_R = 35 / 12
Var_B = 35 / 12
N = 36
n = 19
E_X_ = 11 * E_R - 9 * E_B
Var_X = 11 ** 2 * Var_R + 9 ** 2 * Var_B
sigma_X_ = np.sqrt(Var_X * (N - n) / (n * (N - 1)))
E_X_, sigma_X_
""",
9:
"""
Имеется 10 пронумерованных монет. Монеты подбрасываются до тех пор, пока не выпадет 20 различных (с учетом номера монеты) комбинаций орел-решка. Пусть Xi – число орлов в комбинации с номером i ; а X⎯⎯⎯⎯=120∑Xi – среднее число орлов в полученных таким образом комбинациях. Требуется найти: 1) математическое ожидание E(X⎯⎯⎯⎯) ; 2) дисперсию Var(X⎯⎯⎯⎯) .
N = 2 ** 11
n = 257
p = 1/2
q = 1 - p
E_X = 11 * p # биномиальное распределение
Var_X = 11 * p * q # биномиальное распределение
E_X_ = E_X
Var_X_ = Var_X * (N - n) / (n * (N - 1))
E_X_, Var_X_
""",
10:
"""
Эмпирическое распределение признаков X и Y на генеральной совокупности Ω={1,2,...,100} задано таблицей частот. Из Ω случайным образом без возвращения извлекаются 10 элементов. Пусть X⎯⎯⎯⎯ и Y⎯⎯⎯⎯ – средние значения признаков на выбранных элементах. Требуется найти: 1) математическое ожидание E(X⎯⎯⎯⎯) ; 2) дисперсию Var(Y⎯⎯⎯⎯) ; 3) коэффициент корреляции ρ(X⎯⎯⎯⎯,Y⎯⎯⎯⎯) .
N = 100
n = 7
X = np.array([100] * (11 + 32 + 11) + [400] * (24 + 11 + 11))
Y = np.array([1] * (11) + [2] * (32) + [3] * (11) + [1] * 24 + [2] * 11 + [3] * 11)
E_X = X.mean()
E_X_ = E_X
Var_Y = Y.var()
Var_Y_ = Var_Y * (N - n) / (n * (N - 1))
cov_XY = np.cov([X, Y], bias=True)[0][1]
cov_X_Y_ = cov_XY * (N - n) / (n * (N - 1))
Var_X_ = X.var() * (N - n) / (n * (N - 1))
po = cov_X_Y_ / np.sqrt(Var_X_ * Var_Y_)
E_X_,Var_Y_,po
""",
11:
"""
Эмпирическое распределение признаков X и Y на генеральной совокупности Ω={1,2,...,100} задано таблицей частот.Из Ω случайным образом без возвращения извлекаются 6 элементов. Пусть X⎯⎯⎯⎯ и Y⎯⎯⎯⎯ – средние значения признаков на выбранных элементах. Требуется найти: 1) математическое ожидание E(Y⎯⎯⎯⎯) ; 2) стандартное отклонение σ(X⎯⎯⎯⎯) ; 3) ковариацию Cov(X⎯⎯⎯⎯,Y⎯⎯⎯⎯) .
N = 100
n = 6
X = np.array([100] * (21 + 17 + 12) + [300] * (10 + 27 + 13))
Y = np.array([1] * (21) + [2] * (17) + [4] * (12) + [1] * 10 + [2] * 27 + [4] * 13)
E_Y = Y.mean()
E_Y_ = E_Y
sigma_X_ = np.sqrt(X.var() * (N - n) / (n * (N - 1)))
cov_X_Y_ = np.cov([X, Y], bias=True)[0, 1] * (N - n) / (n * (N - 1))
E_X_,sigma_X_,cov_X_Y_
"""
                 }
        if search:
            numbers = []
            for i, j in sklad.items():
                if search in j[0]:
                    numbers.append(i)
            return 'есть в этих номерах: ', numbers
        
        return sklad[number]

