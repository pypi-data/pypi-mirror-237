from typing import Optional, Any, List, TypeVar, Type, cast, Callable
from enum import Enum


T = TypeVar("T")
EnumT = TypeVar("EnumT", bound=Enum)


def from_str(x: Any) -> str:
    assert isinstance(x, str)
    return x


def from_none(x: Any) -> Any:
    assert x is None
    return x


def from_union(fs, x):
    for f in fs:
        try:
            return f(x)
        except:
            pass
    assert False


def from_float(x: Any) -> float:
    assert isinstance(x, (float, int)) and not isinstance(x, bool)
    return float(x)


def to_float(x: Any) -> float:
    assert isinstance(x, float)
    return x


def to_class(c: Type[T], x: Any) -> dict:
    assert isinstance(x, c)
    return cast(Any, x).to_dict()


def from_list(f: Callable[[Any], T], x: Any) -> List[T]:
    assert isinstance(x, list)
    return [f(y) for y in x]


def to_enum(c: Type[EnumT], x: Any) -> EnumT:
    assert isinstance(x, c)
    return x.value


def from_int(x: Any) -> int:
    assert isinstance(x, int) and not isinstance(x, bool)
    return x


def from_bool(x: Any) -> bool:
    assert isinstance(x, bool)
    return x


class DeleteApisAPIIDResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteApisAPIIDResponse403:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDResponse403(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteApisAPIIDResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteApisAPIIDResponse422:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDResponse422':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDResponse422(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteApisAPIIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse400:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse400(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse403:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse403(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse422:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse422':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse422(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteApisAPIIDVersionsVersionIDResponse400Error:
    """Information about the error."""
    """Details about the error message."""
    message: Optional[str]
    """The type of error."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDVersionsVersionIDResponse400Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteApisAPIIDVersionsVersionIDResponse400Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteApisAPIIDVersionsVersionIDResponse400:
    """Information about the error."""
    error: Optional[DeleteApisAPIIDVersionsVersionIDResponse400Error]

    def __init__(self, error: Optional[DeleteApisAPIIDVersionsVersionIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDVersionsVersionIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([DeleteApisAPIIDVersionsVersionIDResponse400Error.from_dict, from_none], obj.get("error"))
        return DeleteApisAPIIDVersionsVersionIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteApisAPIIDVersionsVersionIDResponse400Error, x), from_none], self.error)
        return result


class DeleteApisAPIIDVersionsVersionIDResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDVersionsVersionIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDVersionsVersionIDResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteApisAPIIDVersionsVersionIDResponse403:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDVersionsVersionIDResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDVersionsVersionIDResponse403(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteApisAPIIDVersionsVersionIDResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDVersionsVersionIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDVersionsVersionIDResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteApisAPIIDVersionsVersionIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteApisAPIIDVersionsVersionIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteApisAPIIDVersionsVersionIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteCollectionsCollectionIDFoldersFolderIDResponseData:
    """The folder's information."""
    """The folder's ID."""
    id: Optional[str]
    """The user ID of the folder's owner."""
    owner: Optional[str]

    def __init__(self, id: Optional[str], owner: Optional[str]) -> None:
        self.id = id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDFoldersFolderIDResponseData':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return DeleteCollectionsCollectionIDFoldersFolderIDResponseData(id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class DeleteCollectionsCollectionIDFoldersFolderIDResponse:
    """The folder's information."""
    data: Optional[DeleteCollectionsCollectionIDFoldersFolderIDResponseData]
    meta: Any
    """The folder's ID."""
    model_id: Optional[str]
    """An internal revision ID. Its value increments each time the resource changes. You can use
    this ID to track whether there were changes since the last time you fetched the resource.
    """
    revision: Optional[float]

    def __init__(self, data: Optional[DeleteCollectionsCollectionIDFoldersFolderIDResponseData], meta: Any, model_id: Optional[str], revision: Optional[float]) -> None:
        self.data = data
        self.meta = meta
        self.model_id = model_id
        self.revision = revision

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDFoldersFolderIDResponse':
        assert isinstance(obj, dict)
        data = from_union([DeleteCollectionsCollectionIDFoldersFolderIDResponseData.from_dict, from_none], obj.get("data"))
        meta = obj.get("meta")
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        revision = from_union([from_float, from_none], obj.get("revision"))
        return DeleteCollectionsCollectionIDFoldersFolderIDResponse(data, meta, model_id, revision)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDFoldersFolderIDResponseData, x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = self.meta
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.revision is not None:
            result["revision"] = from_union([to_float, from_none], self.revision)
        return result


class DeleteCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The folder's ID."""
    model_id: Optional[str]
    """The user ID of the folder's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return DeleteCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class DeleteCollectionsCollectionIDFoldersFolderIDResponse401Error:
    """Information about the error."""
    details: Optional[DeleteCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails]
    """The error's message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[DeleteCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDFoldersFolderIDResponse401Error':
        assert isinstance(obj, dict)
        details = from_union([DeleteCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteCollectionsCollectionIDFoldersFolderIDResponse401Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteCollectionsCollectionIDFoldersFolderIDResponse401:
    error: Optional[DeleteCollectionsCollectionIDFoldersFolderIDResponse401Error]

    def __init__(self, error: Optional[DeleteCollectionsCollectionIDFoldersFolderIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDFoldersFolderIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([DeleteCollectionsCollectionIDFoldersFolderIDResponse401Error.from_dict, from_none], obj.get("error"))
        return DeleteCollectionsCollectionIDFoldersFolderIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDFoldersFolderIDResponse401Error, x), from_none], self.error)
        return result


class DeleteCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The folder's ID."""
    model_id: Optional[str]
    """The user ID of the folder's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return DeleteCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class DeleteCollectionsCollectionIDFoldersFolderIDResponse404Error:
    """Information about the error."""
    details: Optional[DeleteCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[DeleteCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDFoldersFolderIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([DeleteCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteCollectionsCollectionIDFoldersFolderIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteCollectionsCollectionIDFoldersFolderIDResponse404:
    error: Optional[DeleteCollectionsCollectionIDFoldersFolderIDResponse404Error]

    def __init__(self, error: Optional[DeleteCollectionsCollectionIDFoldersFolderIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDFoldersFolderIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([DeleteCollectionsCollectionIDFoldersFolderIDResponse404Error.from_dict, from_none], obj.get("error"))
        return DeleteCollectionsCollectionIDFoldersFolderIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDFoldersFolderIDResponse404Error, x), from_none], self.error)
        return result


class DeleteCollectionsCollectionIDFoldersFolderIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDFoldersFolderIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteCollectionsCollectionIDFoldersFolderIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteCollectionsCollectionIDRequestsRequestIDResponseData:
    """The request's information."""
    """The request's ID."""
    id: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]

    def __init__(self, id: Optional[str], owner: Optional[str]) -> None:
        self.id = id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDRequestsRequestIDResponseData':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return DeleteCollectionsCollectionIDRequestsRequestIDResponseData(id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class DeleteCollectionsCollectionIDRequestsRequestIDResponse:
    """The request's information."""
    data: Optional[DeleteCollectionsCollectionIDRequestsRequestIDResponseData]
    meta: Any
    """The request's ID."""
    model_id: Optional[str]
    """An internal revision ID. Its value increments each time the resource changes. You can use
    this ID to track whether there were changes since the last time you fetched the resource.
    """
    revision: Optional[float]

    def __init__(self, data: Optional[DeleteCollectionsCollectionIDRequestsRequestIDResponseData], meta: Any, model_id: Optional[str], revision: Optional[float]) -> None:
        self.data = data
        self.meta = meta
        self.model_id = model_id
        self.revision = revision

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDRequestsRequestIDResponse':
        assert isinstance(obj, dict)
        data = from_union([DeleteCollectionsCollectionIDRequestsRequestIDResponseData.from_dict, from_none], obj.get("data"))
        meta = obj.get("meta")
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        revision = from_union([from_float, from_none], obj.get("revision"))
        return DeleteCollectionsCollectionIDRequestsRequestIDResponse(data, meta, model_id, revision)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDRequestsRequestIDResponseData, x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = self.meta
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.revision is not None:
            result["revision"] = from_union([to_float, from_none], self.revision)
        return result


class DeleteCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The request's ID."""
    model_id: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return DeleteCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class DeleteCollectionsCollectionIDRequestsRequestIDResponse401Error:
    """Information about the error."""
    details: Optional[DeleteCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails]
    """The error's message."""
    message: Optional[str]
    """The error's name."""
    name: Optional[str]

    def __init__(self, details: Optional[DeleteCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDRequestsRequestIDResponse401Error':
        assert isinstance(obj, dict)
        details = from_union([DeleteCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteCollectionsCollectionIDRequestsRequestIDResponse401Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteCollectionsCollectionIDRequestsRequestIDResponse401:
    error: Optional[DeleteCollectionsCollectionIDRequestsRequestIDResponse401Error]

    def __init__(self, error: Optional[DeleteCollectionsCollectionIDRequestsRequestIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDRequestsRequestIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([DeleteCollectionsCollectionIDRequestsRequestIDResponse401Error.from_dict, from_none], obj.get("error"))
        return DeleteCollectionsCollectionIDRequestsRequestIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDRequestsRequestIDResponse401Error, x), from_none], self.error)
        return result


class DeleteCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The request's ID."""
    model_id: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return DeleteCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class DeleteCollectionsCollectionIDRequestsRequestIDResponse404Error:
    """Information about the error."""
    details: Optional[DeleteCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[DeleteCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDRequestsRequestIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([DeleteCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteCollectionsCollectionIDRequestsRequestIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteCollectionsCollectionIDRequestsRequestIDResponse404:
    error: Optional[DeleteCollectionsCollectionIDRequestsRequestIDResponse404Error]

    def __init__(self, error: Optional[DeleteCollectionsCollectionIDRequestsRequestIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDRequestsRequestIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([DeleteCollectionsCollectionIDRequestsRequestIDResponse404Error.from_dict, from_none], obj.get("error"))
        return DeleteCollectionsCollectionIDRequestsRequestIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDRequestsRequestIDResponse404Error, x), from_none], self.error)
        return result


class DeleteCollectionsCollectionIDRequestsRequestIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDRequestsRequestIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteCollectionsCollectionIDRequestsRequestIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteCollectionsCollectionIDResponseCollection:
    """Information about the deleted collection."""
    """The deleted collection's ID."""
    id: Optional[str]
    """The deleted collection's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponseCollection':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return DeleteCollectionsCollectionIDResponseCollection(id, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class DeleteCollectionsCollectionIDResponse:
    """Information about the deleted collection."""
    collection: Optional[DeleteCollectionsCollectionIDResponseCollection]

    def __init__(self, collection: Optional[DeleteCollectionsCollectionIDResponseCollection]) -> None:
        self.collection = collection

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponse':
        assert isinstance(obj, dict)
        collection = from_union([DeleteCollectionsCollectionIDResponseCollection.from_dict, from_none], obj.get("collection"))
        return DeleteCollectionsCollectionIDResponse(collection)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDResponseCollection, x), from_none], self.collection)
        return result


class DeleteCollectionsCollectionIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteCollectionsCollectionIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteCollectionsCollectionIDResponse401:
    error: Optional[DeleteCollectionsCollectionIDResponse401Error]

    def __init__(self, error: Optional[DeleteCollectionsCollectionIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([DeleteCollectionsCollectionIDResponse401Error.from_dict, from_none], obj.get("error"))
        return DeleteCollectionsCollectionIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDResponse401Error, x), from_none], self.error)
        return result


class DeleteCollectionsCollectionIDResponse404ErrorDetails:
    """Information about the error."""
    """The collection ID."""
    id: Optional[str]
    """The instance item."""
    item: Optional[str]

    def __init__(self, id: Optional[str], item: Optional[str]) -> None:
        self.id = id
        self.item = item

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponse404ErrorDetails':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        item = from_union([from_str, from_none], obj.get("item"))
        return DeleteCollectionsCollectionIDResponse404ErrorDetails(id, item)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.item is not None:
            result["item"] = from_union([from_str, from_none], self.item)
        return result


class DeleteCollectionsCollectionIDResponse404Error:
    """Information about the error."""
    details: Optional[DeleteCollectionsCollectionIDResponse404ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[DeleteCollectionsCollectionIDResponse404ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([DeleteCollectionsCollectionIDResponse404ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteCollectionsCollectionIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDResponse404ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteCollectionsCollectionIDResponse404:
    error: Optional[DeleteCollectionsCollectionIDResponse404Error]

    def __init__(self, error: Optional[DeleteCollectionsCollectionIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([DeleteCollectionsCollectionIDResponse404Error.from_dict, from_none], obj.get("error"))
        return DeleteCollectionsCollectionIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDResponse404Error, x), from_none], self.error)
        return result


class DeleteCollectionsCollectionIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return DeleteCollectionsCollectionIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class DeleteCollectionsCollectionIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteCollectionsCollectionIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteCollectionsCollectionIDResponse500:
    error: Optional[DeleteCollectionsCollectionIDResponse500Error]

    def __init__(self, error: Optional[DeleteCollectionsCollectionIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([DeleteCollectionsCollectionIDResponse500Error.from_dict, from_none], obj.get("error"))
        return DeleteCollectionsCollectionIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDResponse500Error, x), from_none], self.error)
        return result


class DeleteCollectionsCollectionIDResponsesResponseIDResponseData:
    """The response's information."""
    """The response's ID."""
    id: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]

    def __init__(self, id: Optional[str], owner: Optional[str]) -> None:
        self.id = id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponsesResponseIDResponseData':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return DeleteCollectionsCollectionIDResponsesResponseIDResponseData(id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class DeleteCollectionsCollectionIDResponsesResponseIDResponse:
    """The response's information."""
    data: Optional[DeleteCollectionsCollectionIDResponsesResponseIDResponseData]
    meta: Any
    """The response's ID."""
    model_id: Optional[str]
    """An internal revision ID. Its value increments each time the resource changes. You can use
    this ID to track whether there were changes since the last time you fetched the resource.
    """
    revision: Optional[float]

    def __init__(self, data: Optional[DeleteCollectionsCollectionIDResponsesResponseIDResponseData], meta: Any, model_id: Optional[str], revision: Optional[float]) -> None:
        self.data = data
        self.meta = meta
        self.model_id = model_id
        self.revision = revision

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponsesResponseIDResponse':
        assert isinstance(obj, dict)
        data = from_union([DeleteCollectionsCollectionIDResponsesResponseIDResponseData.from_dict, from_none], obj.get("data"))
        meta = obj.get("meta")
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        revision = from_union([from_float, from_none], obj.get("revision"))
        return DeleteCollectionsCollectionIDResponsesResponseIDResponse(data, meta, model_id, revision)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDResponsesResponseIDResponseData, x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = self.meta
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.revision is not None:
            result["revision"] = from_union([to_float, from_none], self.revision)
        return result


class DeleteCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The response's ID."""
    model_id: Optional[str]
    """The user ID of the response's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return DeleteCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class DeleteCollectionsCollectionIDResponsesResponseIDResponse401Error:
    """Information about the error."""
    details: Optional[DeleteCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[DeleteCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponsesResponseIDResponse401Error':
        assert isinstance(obj, dict)
        details = from_union([DeleteCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteCollectionsCollectionIDResponsesResponseIDResponse401Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteCollectionsCollectionIDResponsesResponseIDResponse401:
    error: Optional[DeleteCollectionsCollectionIDResponsesResponseIDResponse401Error]

    def __init__(self, error: Optional[DeleteCollectionsCollectionIDResponsesResponseIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponsesResponseIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([DeleteCollectionsCollectionIDResponsesResponseIDResponse401Error.from_dict, from_none], obj.get("error"))
        return DeleteCollectionsCollectionIDResponsesResponseIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDResponsesResponseIDResponse401Error, x), from_none], self.error)
        return result


class DeleteCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The response's ID."""
    model_id: Optional[str]
    """The user ID of the response's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return DeleteCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class DeleteCollectionsCollectionIDResponsesResponseIDResponse404Error:
    """Information about the error."""
    details: Optional[DeleteCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[DeleteCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponsesResponseIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([DeleteCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteCollectionsCollectionIDResponsesResponseIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteCollectionsCollectionIDResponsesResponseIDResponse404:
    error: Optional[DeleteCollectionsCollectionIDResponsesResponseIDResponse404Error]

    def __init__(self, error: Optional[DeleteCollectionsCollectionIDResponsesResponseIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponsesResponseIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([DeleteCollectionsCollectionIDResponsesResponseIDResponse404Error.from_dict, from_none], obj.get("error"))
        return DeleteCollectionsCollectionIDResponsesResponseIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteCollectionsCollectionIDResponsesResponseIDResponse404Error, x), from_none], self.error)
        return result


class DeleteCollectionsCollectionIDResponsesResponseIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteCollectionsCollectionIDResponsesResponseIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return DeleteCollectionsCollectionIDResponsesResponseIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class DeleteEnvironmentsEnvironmentIDResponseEnvironment:
    """The deleted environment's ID."""
    id: Optional[str]
    """The deleted environment's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteEnvironmentsEnvironmentIDResponseEnvironment':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return DeleteEnvironmentsEnvironmentIDResponseEnvironment(id, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class DeleteEnvironmentsEnvironmentIDResponse:
    environment: Optional[DeleteEnvironmentsEnvironmentIDResponseEnvironment]

    def __init__(self, environment: Optional[DeleteEnvironmentsEnvironmentIDResponseEnvironment]) -> None:
        self.environment = environment

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteEnvironmentsEnvironmentIDResponse':
        assert isinstance(obj, dict)
        environment = from_union([DeleteEnvironmentsEnvironmentIDResponseEnvironment.from_dict, from_none], obj.get("environment"))
        return DeleteEnvironmentsEnvironmentIDResponse(environment)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.environment is not None:
            result["environment"] = from_union([lambda x: to_class(DeleteEnvironmentsEnvironmentIDResponseEnvironment, x), from_none], self.environment)
        return result


class DeleteEnvironmentsEnvironmentIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteEnvironmentsEnvironmentIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteEnvironmentsEnvironmentIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteEnvironmentsEnvironmentIDResponse401:
    error: Optional[DeleteEnvironmentsEnvironmentIDResponse401Error]

    def __init__(self, error: Optional[DeleteEnvironmentsEnvironmentIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteEnvironmentsEnvironmentIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([DeleteEnvironmentsEnvironmentIDResponse401Error.from_dict, from_none], obj.get("error"))
        return DeleteEnvironmentsEnvironmentIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteEnvironmentsEnvironmentIDResponse401Error, x), from_none], self.error)
        return result


class DeleteEnvironmentsEnvironmentIDResponse404Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteEnvironmentsEnvironmentIDResponse404Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteEnvironmentsEnvironmentIDResponse404Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteEnvironmentsEnvironmentIDResponse404:
    error: Optional[DeleteEnvironmentsEnvironmentIDResponse404Error]

    def __init__(self, error: Optional[DeleteEnvironmentsEnvironmentIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteEnvironmentsEnvironmentIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([DeleteEnvironmentsEnvironmentIDResponse404Error.from_dict, from_none], obj.get("error"))
        return DeleteEnvironmentsEnvironmentIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteEnvironmentsEnvironmentIDResponse404Error, x), from_none], self.error)
        return result


class DeleteEnvironmentsEnvironmentIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteEnvironmentsEnvironmentIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return DeleteEnvironmentsEnvironmentIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class DeleteEnvironmentsEnvironmentIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteEnvironmentsEnvironmentIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteEnvironmentsEnvironmentIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteEnvironmentsEnvironmentIDResponse500:
    error: Optional[DeleteEnvironmentsEnvironmentIDResponse500Error]

    def __init__(self, error: Optional[DeleteEnvironmentsEnvironmentIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteEnvironmentsEnvironmentIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([DeleteEnvironmentsEnvironmentIDResponse500Error.from_dict, from_none], obj.get("error"))
        return DeleteEnvironmentsEnvironmentIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteEnvironmentsEnvironmentIDResponse500Error, x), from_none], self.error)
        return result


class DeleteMocksMockIDResponseMock:
    """Information about the mock server."""
    """The mock server's ID."""
    id: Optional[str]
    """The mock server's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDResponseMock':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return DeleteMocksMockIDResponseMock(id, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class DeleteMocksMockIDResponse:
    """Information about the mock server."""
    mock: Optional[DeleteMocksMockIDResponseMock]

    def __init__(self, mock: Optional[DeleteMocksMockIDResponseMock]) -> None:
        self.mock = mock

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDResponse':
        assert isinstance(obj, dict)
        mock = from_union([DeleteMocksMockIDResponseMock.from_dict, from_none], obj.get("mock"))
        return DeleteMocksMockIDResponse(mock)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.mock is not None:
            result["mock"] = from_union([lambda x: to_class(DeleteMocksMockIDResponseMock, x), from_none], self.mock)
        return result


class DeleteMocksMockIDResponse400Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDResponse400Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMocksMockIDResponse400Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMocksMockIDResponse400:
    error: Optional[DeleteMocksMockIDResponse400Error]

    def __init__(self, error: Optional[DeleteMocksMockIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([DeleteMocksMockIDResponse400Error.from_dict, from_none], obj.get("error"))
        return DeleteMocksMockIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMocksMockIDResponse400Error, x), from_none], self.error)
        return result


class DeleteMocksMockIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMocksMockIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMocksMockIDResponse401:
    error: Optional[DeleteMocksMockIDResponse401Error]

    def __init__(self, error: Optional[DeleteMocksMockIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([DeleteMocksMockIDResponse401Error.from_dict, from_none], obj.get("error"))
        return DeleteMocksMockIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMocksMockIDResponse401Error, x), from_none], self.error)
        return result


class DeleteMocksMockIDResponse404Error:
    """Information about the error."""
    details: Optional[List[str]]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[List[str]], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([lambda x: from_list(from_str, x), from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMocksMockIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: from_list(from_str, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMocksMockIDResponse404:
    error: Optional[DeleteMocksMockIDResponse404Error]

    def __init__(self, error: Optional[DeleteMocksMockIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([DeleteMocksMockIDResponse404Error.from_dict, from_none], obj.get("error"))
        return DeleteMocksMockIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMocksMockIDResponse404Error, x), from_none], self.error)
        return result


class DeleteMocksMockIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return DeleteMocksMockIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class DeleteMocksMockIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMocksMockIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMocksMockIDResponse500:
    error: Optional[DeleteMocksMockIDResponse500Error]

    def __init__(self, error: Optional[DeleteMocksMockIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([DeleteMocksMockIDResponse500Error.from_dict, from_none], obj.get("error"))
        return DeleteMocksMockIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMocksMockIDResponse500Error, x), from_none], self.error)
        return result


class DeleteMocksMockIDServerResponsesServerResponseIDResponseHeadersItem:
    """The request header's key value."""
    key: Optional[str]
    """The request header's value."""
    value: Optional[str]

    def __init__(self, key: Optional[str], value: Optional[str]) -> None:
        self.key = key
        self.value = value

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDServerResponsesServerResponseIDResponseHeadersItem':
        assert isinstance(obj, dict)
        key = from_union([from_str, from_none], obj.get("key"))
        value = from_union([from_str, from_none], obj.get("value"))
        return DeleteMocksMockIDServerResponsesServerResponseIDResponseHeadersItem(key, value)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.key is not None:
            result["key"] = from_union([from_str, from_none], self.key)
        if self.value is not None:
            result["value"] = from_union([from_str, from_none], self.value)
        return result


class DeleteMocksMockIDServerResponsesServerResponseIDResponseLanguage(Enum):
    """The server response's body language type."""
    HTML = "html"
    JAVASCRIPT = "javascript"
    JSON = "json"
    TEXT = "text"
    XML = "xml"


class DeleteMocksMockIDServerResponsesServerResponseIDResponse:
    """Information about the deleted server response."""
    """The server response's body that returns when calling the mock server."""
    body: Optional[str]
    """The date and time at which the server response was created."""
    created_at: Optional[str]
    """The user ID of the user who created the server response."""
    created_by: Optional[str]
    """The server response's request headers, such as Content-Type, Accept, encoding, and other
    information.
    """
    headers: Optional[List[DeleteMocksMockIDServerResponsesServerResponseIDResponseHeadersItem]]
    """The server response's ID."""
    id: Optional[str]
    """The server response's body language type."""
    language: Optional[DeleteMocksMockIDServerResponsesServerResponseIDResponseLanguage]
    """The server response's name."""
    name: Optional[str]
    """The server response's 5xx HTTP response code."""
    status_code: Optional[float]
    """The user ID of the user who last updated the server response."""
    updated_by: Optional[str]

    def __init__(self, body: Optional[str], created_at: Optional[str], created_by: Optional[str], headers: Optional[List[DeleteMocksMockIDServerResponsesServerResponseIDResponseHeadersItem]], id: Optional[str], language: Optional[DeleteMocksMockIDServerResponsesServerResponseIDResponseLanguage], name: Optional[str], status_code: Optional[float], updated_by: Optional[str]) -> None:
        self.body = body
        self.created_at = created_at
        self.created_by = created_by
        self.headers = headers
        self.id = id
        self.language = language
        self.name = name
        self.status_code = status_code
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDServerResponsesServerResponseIDResponse':
        assert isinstance(obj, dict)
        body = from_union([from_str, from_none], obj.get("body"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_str, from_none], obj.get("createdBy"))
        headers = from_union([lambda x: from_list(DeleteMocksMockIDServerResponsesServerResponseIDResponseHeadersItem.from_dict, x), from_none], obj.get("headers"))
        id = from_union([from_str, from_none], obj.get("id"))
        language = from_union([DeleteMocksMockIDServerResponsesServerResponseIDResponseLanguage, from_none], obj.get("language"))
        name = from_union([from_str, from_none], obj.get("name"))
        status_code = from_union([from_float, from_none], obj.get("statusCode"))
        updated_by = from_union([from_str, from_none], obj.get("updatedBy"))
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse(body, created_at, created_by, headers, id, language, name, status_code, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.body is not None:
            result["body"] = from_union([from_str, from_none], self.body)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_str, from_none], self.created_by)
        if self.headers is not None:
            result["headers"] = from_union([lambda x: from_list(lambda x: to_class(DeleteMocksMockIDServerResponsesServerResponseIDResponseHeadersItem, x), x), from_none], self.headers)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.language is not None:
            result["language"] = from_union([lambda x: to_enum(DeleteMocksMockIDServerResponsesServerResponseIDResponseLanguage, x), from_none], self.language)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.status_code is not None:
            result["statusCode"] = from_union([to_float, from_none], self.status_code)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_str, from_none], self.updated_by)
        return result


class DeleteMocksMockIDServerResponsesServerResponseIDResponse400Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDServerResponsesServerResponseIDResponse400Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse400Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMocksMockIDServerResponsesServerResponseIDResponse400:
    error: Optional[DeleteMocksMockIDServerResponsesServerResponseIDResponse400Error]

    def __init__(self, error: Optional[DeleteMocksMockIDServerResponsesServerResponseIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDServerResponsesServerResponseIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([DeleteMocksMockIDServerResponsesServerResponseIDResponse400Error.from_dict, from_none], obj.get("error"))
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMocksMockIDServerResponsesServerResponseIDResponse400Error, x), from_none], self.error)
        return result


class DeleteMocksMockIDServerResponsesServerResponseIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDServerResponsesServerResponseIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMocksMockIDServerResponsesServerResponseIDResponse401:
    error: Optional[DeleteMocksMockIDServerResponsesServerResponseIDResponse401Error]

    def __init__(self, error: Optional[DeleteMocksMockIDServerResponsesServerResponseIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDServerResponsesServerResponseIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([DeleteMocksMockIDServerResponsesServerResponseIDResponse401Error.from_dict, from_none], obj.get("error"))
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMocksMockIDServerResponsesServerResponseIDResponse401Error, x), from_none], self.error)
        return result


class DeleteMocksMockIDServerResponsesServerResponseIDResponse404Error:
    """Information about the error."""
    details: Optional[List[str]]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[List[str]], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDServerResponsesServerResponseIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([lambda x: from_list(from_str, x), from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: from_list(from_str, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMocksMockIDServerResponsesServerResponseIDResponse404:
    error: Optional[DeleteMocksMockIDServerResponsesServerResponseIDResponse404Error]

    def __init__(self, error: Optional[DeleteMocksMockIDServerResponsesServerResponseIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDServerResponsesServerResponseIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([DeleteMocksMockIDServerResponsesServerResponseIDResponse404Error.from_dict, from_none], obj.get("error"))
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMocksMockIDServerResponsesServerResponseIDResponse404Error, x), from_none], self.error)
        return result


class DeleteMocksMockIDServerResponsesServerResponseIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDServerResponsesServerResponseIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class DeleteMocksMockIDServerResponsesServerResponseIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDServerResponsesServerResponseIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMocksMockIDServerResponsesServerResponseIDResponse500:
    error: Optional[DeleteMocksMockIDServerResponsesServerResponseIDResponse500Error]

    def __init__(self, error: Optional[DeleteMocksMockIDServerResponsesServerResponseIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDServerResponsesServerResponseIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([DeleteMocksMockIDServerResponsesServerResponseIDResponse500Error.from_dict, from_none], obj.get("error"))
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMocksMockIDServerResponsesServerResponseIDResponse500Error, x), from_none], self.error)
        return result


class DeleteMocksMockIDUnpublishResponseMock:
    """The mock server's ID."""
    id: Optional[str]

    def __init__(self, id: Optional[str]) -> None:
        self.id = id

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDUnpublishResponseMock':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        return DeleteMocksMockIDUnpublishResponseMock(id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        return result


class DeleteMocksMockIDUnpublishResponse:
    mock: Optional[DeleteMocksMockIDUnpublishResponseMock]

    def __init__(self, mock: Optional[DeleteMocksMockIDUnpublishResponseMock]) -> None:
        self.mock = mock

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDUnpublishResponse':
        assert isinstance(obj, dict)
        mock = from_union([DeleteMocksMockIDUnpublishResponseMock.from_dict, from_none], obj.get("mock"))
        return DeleteMocksMockIDUnpublishResponse(mock)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.mock is not None:
            result["mock"] = from_union([lambda x: to_class(DeleteMocksMockIDUnpublishResponseMock, x), from_none], self.mock)
        return result


class DeleteMocksMockIDUnpublishResponse400Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDUnpublishResponse400Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMocksMockIDUnpublishResponse400Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMocksMockIDUnpublishResponse400:
    error: Optional[DeleteMocksMockIDUnpublishResponse400Error]

    def __init__(self, error: Optional[DeleteMocksMockIDUnpublishResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDUnpublishResponse400':
        assert isinstance(obj, dict)
        error = from_union([DeleteMocksMockIDUnpublishResponse400Error.from_dict, from_none], obj.get("error"))
        return DeleteMocksMockIDUnpublishResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMocksMockIDUnpublishResponse400Error, x), from_none], self.error)
        return result


class DeleteMocksMockIDUnpublishResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDUnpublishResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMocksMockIDUnpublishResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMocksMockIDUnpublishResponse401:
    error: Optional[DeleteMocksMockIDUnpublishResponse401Error]

    def __init__(self, error: Optional[DeleteMocksMockIDUnpublishResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDUnpublishResponse401':
        assert isinstance(obj, dict)
        error = from_union([DeleteMocksMockIDUnpublishResponse401Error.from_dict, from_none], obj.get("error"))
        return DeleteMocksMockIDUnpublishResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMocksMockIDUnpublishResponse401Error, x), from_none], self.error)
        return result


class DeleteMocksMockIDUnpublishResponse404Error:
    """Information about the error."""
    details: Optional[List[str]]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[List[str]], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDUnpublishResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([lambda x: from_list(from_str, x), from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMocksMockIDUnpublishResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: from_list(from_str, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMocksMockIDUnpublishResponse404:
    error: Optional[DeleteMocksMockIDUnpublishResponse404Error]

    def __init__(self, error: Optional[DeleteMocksMockIDUnpublishResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDUnpublishResponse404':
        assert isinstance(obj, dict)
        error = from_union([DeleteMocksMockIDUnpublishResponse404Error.from_dict, from_none], obj.get("error"))
        return DeleteMocksMockIDUnpublishResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMocksMockIDUnpublishResponse404Error, x), from_none], self.error)
        return result


class DeleteMocksMockIDUnpublishResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDUnpublishResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return DeleteMocksMockIDUnpublishResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class DeleteMocksMockIDUnpublishResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDUnpublishResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMocksMockIDUnpublishResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMocksMockIDUnpublishResponse500:
    error: Optional[DeleteMocksMockIDUnpublishResponse500Error]

    def __init__(self, error: Optional[DeleteMocksMockIDUnpublishResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMocksMockIDUnpublishResponse500':
        assert isinstance(obj, dict)
        error = from_union([DeleteMocksMockIDUnpublishResponse500Error.from_dict, from_none], obj.get("error"))
        return DeleteMocksMockIDUnpublishResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMocksMockIDUnpublishResponse500Error, x), from_none], self.error)
        return result


class DeleteMonitorsMonitorIDResponseMonitor:
    """The monitor's ID."""
    id: Optional[str]
    """The monitor's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMonitorsMonitorIDResponseMonitor':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return DeleteMonitorsMonitorIDResponseMonitor(id, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class DeleteMonitorsMonitorIDResponse:
    monitor: Optional[DeleteMonitorsMonitorIDResponseMonitor]

    def __init__(self, monitor: Optional[DeleteMonitorsMonitorIDResponseMonitor]) -> None:
        self.monitor = monitor

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMonitorsMonitorIDResponse':
        assert isinstance(obj, dict)
        monitor = from_union([DeleteMonitorsMonitorIDResponseMonitor.from_dict, from_none], obj.get("monitor"))
        return DeleteMonitorsMonitorIDResponse(monitor)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.monitor is not None:
            result["monitor"] = from_union([lambda x: to_class(DeleteMonitorsMonitorIDResponseMonitor, x), from_none], self.monitor)
        return result


class DeleteMonitorsMonitorIDResponse400Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMonitorsMonitorIDResponse400Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMonitorsMonitorIDResponse400Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMonitorsMonitorIDResponse400:
    error: Optional[DeleteMonitorsMonitorIDResponse400Error]

    def __init__(self, error: Optional[DeleteMonitorsMonitorIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMonitorsMonitorIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([DeleteMonitorsMonitorIDResponse400Error.from_dict, from_none], obj.get("error"))
        return DeleteMonitorsMonitorIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMonitorsMonitorIDResponse400Error, x), from_none], self.error)
        return result


class DeleteMonitorsMonitorIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMonitorsMonitorIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMonitorsMonitorIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMonitorsMonitorIDResponse401:
    error: Optional[DeleteMonitorsMonitorIDResponse401Error]

    def __init__(self, error: Optional[DeleteMonitorsMonitorIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMonitorsMonitorIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([DeleteMonitorsMonitorIDResponse401Error.from_dict, from_none], obj.get("error"))
        return DeleteMonitorsMonitorIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMonitorsMonitorIDResponse401Error, x), from_none], self.error)
        return result


class DeleteMonitorsMonitorIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMonitorsMonitorIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return DeleteMonitorsMonitorIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class DeleteMonitorsMonitorIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMonitorsMonitorIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteMonitorsMonitorIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteMonitorsMonitorIDResponse500:
    error: Optional[DeleteMonitorsMonitorIDResponse500Error]

    def __init__(self, error: Optional[DeleteMonitorsMonitorIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteMonitorsMonitorIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([DeleteMonitorsMonitorIDResponse500Error.from_dict, from_none], obj.get("error"))
        return DeleteMonitorsMonitorIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteMonitorsMonitorIDResponse500Error, x), from_none], self.error)
        return result


class DeleteNetworkPrivateElementTypeElementIDResponseElementType:
    """The Private API Network element type. The name of the object is the element type."""
    """The element's ID."""
    id: Optional[str]

    def __init__(self, id: Optional[str]) -> None:
        self.id = id

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteNetworkPrivateElementTypeElementIDResponseElementType':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        return DeleteNetworkPrivateElementTypeElementIDResponseElementType(id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        return result


class DeleteNetworkPrivateElementTypeElementIDResponse:
    """The Private API Network element type. The name of the object is the element type."""
    element_type: Optional[DeleteNetworkPrivateElementTypeElementIDResponseElementType]

    def __init__(self, element_type: Optional[DeleteNetworkPrivateElementTypeElementIDResponseElementType]) -> None:
        self.element_type = element_type

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteNetworkPrivateElementTypeElementIDResponse':
        assert isinstance(obj, dict)
        element_type = from_union([DeleteNetworkPrivateElementTypeElementIDResponseElementType.from_dict, from_none], obj.get("elementType"))
        return DeleteNetworkPrivateElementTypeElementIDResponse(element_type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.element_type is not None:
            result["elementType"] = from_union([lambda x: to_class(DeleteNetworkPrivateElementTypeElementIDResponseElementType, x), from_none], self.element_type)
        return result


class DeleteNetworkPrivateElementTypeElementIDResponse400:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteNetworkPrivateElementTypeElementIDResponse400':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteNetworkPrivateElementTypeElementIDResponse400(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteNetworkPrivateElementTypeElementIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteNetworkPrivateElementTypeElementIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteNetworkPrivateElementTypeElementIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteNetworkPrivateElementTypeElementIDResponse401:
    error: Optional[DeleteNetworkPrivateElementTypeElementIDResponse401Error]

    def __init__(self, error: Optional[DeleteNetworkPrivateElementTypeElementIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteNetworkPrivateElementTypeElementIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([DeleteNetworkPrivateElementTypeElementIDResponse401Error.from_dict, from_none], obj.get("error"))
        return DeleteNetworkPrivateElementTypeElementIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteNetworkPrivateElementTypeElementIDResponse401Error, x), from_none], self.error)
        return result


class DeleteNetworkPrivateElementTypeElementIDResponse403Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteNetworkPrivateElementTypeElementIDResponse403Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteNetworkPrivateElementTypeElementIDResponse403Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteNetworkPrivateElementTypeElementIDResponse403:
    error: Optional[DeleteNetworkPrivateElementTypeElementIDResponse403Error]

    def __init__(self, error: Optional[DeleteNetworkPrivateElementTypeElementIDResponse403Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteNetworkPrivateElementTypeElementIDResponse403':
        assert isinstance(obj, dict)
        error = from_union([DeleteNetworkPrivateElementTypeElementIDResponse403Error.from_dict, from_none], obj.get("error"))
        return DeleteNetworkPrivateElementTypeElementIDResponse403(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteNetworkPrivateElementTypeElementIDResponse403Error, x), from_none], self.error)
        return result


class DeleteNetworkPrivateElementTypeElementIDResponse404Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteNetworkPrivateElementTypeElementIDResponse404Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteNetworkPrivateElementTypeElementIDResponse404Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteNetworkPrivateElementTypeElementIDResponse404:
    error: Optional[DeleteNetworkPrivateElementTypeElementIDResponse404Error]

    def __init__(self, error: Optional[DeleteNetworkPrivateElementTypeElementIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteNetworkPrivateElementTypeElementIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([DeleteNetworkPrivateElementTypeElementIDResponse404Error.from_dict, from_none], obj.get("error"))
        return DeleteNetworkPrivateElementTypeElementIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteNetworkPrivateElementTypeElementIDResponse404Error, x), from_none], self.error)
        return result


class DeleteNetworkPrivateElementTypeElementIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteNetworkPrivateElementTypeElementIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return DeleteNetworkPrivateElementTypeElementIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class DeleteNetworkPrivateElementTypeElementIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteNetworkPrivateElementTypeElementIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteNetworkPrivateElementTypeElementIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteNetworkPrivateElementTypeElementIDResponse500:
    error: Optional[DeleteNetworkPrivateElementTypeElementIDResponse500Error]

    def __init__(self, error: Optional[DeleteNetworkPrivateElementTypeElementIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteNetworkPrivateElementTypeElementIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([DeleteNetworkPrivateElementTypeElementIDResponse500Error.from_dict, from_none], obj.get("error"))
        return DeleteNetworkPrivateElementTypeElementIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteNetworkPrivateElementTypeElementIDResponse500Error, x), from_none], self.error)
        return result


class DeleteScimV2GroupsGroupIDResponse400:
    detail: Optional[str]
    schemas: Optional[List[str]]
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteScimV2GroupsGroupIDResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return DeleteScimV2GroupsGroupIDResponse400(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class DeleteScimV2GroupsGroupIDResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteScimV2GroupsGroupIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return DeleteScimV2GroupsGroupIDResponse401(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class DeleteScimV2GroupsGroupIDResponse403:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteScimV2GroupsGroupIDResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return DeleteScimV2GroupsGroupIDResponse403(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class DeleteScimV2GroupsGroupIDResponse404:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteScimV2GroupsGroupIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return DeleteScimV2GroupsGroupIDResponse404(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class DeleteScimV2GroupsGroupIDResponse429:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[float]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[float]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteScimV2GroupsGroupIDResponse429':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_float, from_none], obj.get("status"))
        return DeleteScimV2GroupsGroupIDResponse429(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        return result


class DeleteScimV2GroupsGroupIDResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteScimV2GroupsGroupIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return DeleteScimV2GroupsGroupIDResponse500(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class DeleteWorkspacesWorkspaceIDResponseWorkspace:
    """Information about the deleted workspace."""
    """The workspace's ID."""
    id: Optional[str]

    def __init__(self, id: Optional[str]) -> None:
        self.id = id

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteWorkspacesWorkspaceIDResponseWorkspace':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        return DeleteWorkspacesWorkspaceIDResponseWorkspace(id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        return result


class DeleteWorkspacesWorkspaceIDResponse:
    """Information about the deleted workspace."""
    workspace: Optional[DeleteWorkspacesWorkspaceIDResponseWorkspace]

    def __init__(self, workspace: Optional[DeleteWorkspacesWorkspaceIDResponseWorkspace]) -> None:
        self.workspace = workspace

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteWorkspacesWorkspaceIDResponse':
        assert isinstance(obj, dict)
        workspace = from_union([DeleteWorkspacesWorkspaceIDResponseWorkspace.from_dict, from_none], obj.get("workspace"))
        return DeleteWorkspacesWorkspaceIDResponse(workspace)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.workspace is not None:
            result["workspace"] = from_union([lambda x: to_class(DeleteWorkspacesWorkspaceIDResponseWorkspace, x), from_none], self.workspace)
        return result


class DeleteWorkspacesWorkspaceIDResponse400Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteWorkspacesWorkspaceIDResponse400Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteWorkspacesWorkspaceIDResponse400Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteWorkspacesWorkspaceIDResponse400:
    error: Optional[DeleteWorkspacesWorkspaceIDResponse400Error]

    def __init__(self, error: Optional[DeleteWorkspacesWorkspaceIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteWorkspacesWorkspaceIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([DeleteWorkspacesWorkspaceIDResponse400Error.from_dict, from_none], obj.get("error"))
        return DeleteWorkspacesWorkspaceIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteWorkspacesWorkspaceIDResponse400Error, x), from_none], self.error)
        return result


class DeleteWorkspacesWorkspaceIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteWorkspacesWorkspaceIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteWorkspacesWorkspaceIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteWorkspacesWorkspaceIDResponse401:
    error: Optional[DeleteWorkspacesWorkspaceIDResponse401Error]

    def __init__(self, error: Optional[DeleteWorkspacesWorkspaceIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteWorkspacesWorkspaceIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([DeleteWorkspacesWorkspaceIDResponse401Error.from_dict, from_none], obj.get("error"))
        return DeleteWorkspacesWorkspaceIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteWorkspacesWorkspaceIDResponse401Error, x), from_none], self.error)
        return result


class DeleteWorkspacesWorkspaceIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteWorkspacesWorkspaceIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return DeleteWorkspacesWorkspaceIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class DeleteWorkspacesWorkspaceIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteWorkspacesWorkspaceIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return DeleteWorkspacesWorkspaceIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class DeleteWorkspacesWorkspaceIDResponse500:
    error: Optional[DeleteWorkspacesWorkspaceIDResponse500Error]

    def __init__(self, error: Optional[DeleteWorkspacesWorkspaceIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'DeleteWorkspacesWorkspaceIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([DeleteWorkspacesWorkspaceIDResponse500Error.from_dict, from_none], obj.get("error"))
        return DeleteWorkspacesWorkspaceIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(DeleteWorkspacesWorkspaceIDResponse500Error, x), from_none], self.error)
        return result


class Schema(Enum):
    """The collection's JSON schema version."""
    HTTPS_SCHEMA_GETPOSTMAN_COM_JSON_COLLECTION_V2_10_COLLECTION_JSON = "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"


class GetApisAPIIDCollectionsCollectionIDResponseInfo:
    """Information about the collection."""
    """The collection's ID."""
    postman_id: Optional[str]
    """The collection's description."""
    description: Optional[str]
    """The collection's name."""
    name: Optional[str]
    """The collection's JSON schema version."""
    schema: Optional[Schema]
    """The date and time at which the collection was last updated."""
    updated_at: Optional[str]

    def __init__(self, postman_id: Optional[str], description: Optional[str], name: Optional[str], schema: Optional[Schema], updated_at: Optional[str]) -> None:
        self.postman_id = postman_id
        self.description = description
        self.name = name
        self.schema = schema
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDCollectionsCollectionIDResponseInfo':
        assert isinstance(obj, dict)
        postman_id = from_union([from_str, from_none], obj.get("_postman_id"))
        description = from_union([from_str, from_none], obj.get("description"))
        name = from_union([from_str, from_none], obj.get("name"))
        schema = from_union([Schema, from_none], obj.get("schema"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return GetApisAPIIDCollectionsCollectionIDResponseInfo(postman_id, description, name, schema, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.postman_id is not None:
            result["_postman_id"] = from_union([from_str, from_none], self.postman_id)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.schema is not None:
            result["schema"] = from_union([lambda x: to_enum(Schema, x), from_none], self.schema)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class GetApisAPIIDCollectionsCollectionIDResponseItemItem:
    """Information about the collection's contents. For a complete list of values, refer to the
    [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    """The collection's event information. For a complete list of values, refer to the
    `definitions.event` entry in the [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    event: Optional[List[Any]]
    """The collection item's ID."""
    id: Optional[str]
    """The collection item's human-readable identifier."""
    name: Optional[str]
    request: Any
    """The collection's response information. For a complete list of values, refer to the
    `definitions.response` entry in the [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    response: Optional[List[Any]]

    def __init__(self, event: Optional[List[Any]], id: Optional[str], name: Optional[str], request: Any, response: Optional[List[Any]]) -> None:
        self.event = event
        self.id = id
        self.name = name
        self.request = request
        self.response = response

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDCollectionsCollectionIDResponseItemItem':
        assert isinstance(obj, dict)
        event = from_union([lambda x: from_list(lambda x: x, x), from_none], obj.get("event"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        request = obj.get("request")
        response = from_union([lambda x: from_list(lambda x: x, x), from_none], obj.get("response"))
        return GetApisAPIIDCollectionsCollectionIDResponseItemItem(event, id, name, request, response)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.event is not None:
            result["event"] = from_union([lambda x: from_list(lambda x: x, x), from_none], self.event)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.request is not None:
            result["request"] = self.request
        if self.response is not None:
            result["response"] = from_union([lambda x: from_list(lambda x: x, x), from_none], self.response)
        return result


class GetApisAPIIDCollectionsCollectionIDResponse:
    """Information about the collection."""
    info: Optional[GetApisAPIIDCollectionsCollectionIDResponseInfo]
    item: Optional[List[GetApisAPIIDCollectionsCollectionIDResponseItemItem]]

    def __init__(self, info: Optional[GetApisAPIIDCollectionsCollectionIDResponseInfo], item: Optional[List[GetApisAPIIDCollectionsCollectionIDResponseItemItem]]) -> None:
        self.info = info
        self.item = item

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDCollectionsCollectionIDResponse':
        assert isinstance(obj, dict)
        info = from_union([GetApisAPIIDCollectionsCollectionIDResponseInfo.from_dict, from_none], obj.get("info"))
        item = from_union([lambda x: from_list(GetApisAPIIDCollectionsCollectionIDResponseItemItem.from_dict, x), from_none], obj.get("item"))
        return GetApisAPIIDCollectionsCollectionIDResponse(info, item)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.info is not None:
            result["info"] = from_union([lambda x: to_class(GetApisAPIIDCollectionsCollectionIDResponseInfo, x), from_none], self.info)
        if self.item is not None:
            result["item"] = from_union([lambda x: from_list(lambda x: to_class(GetApisAPIIDCollectionsCollectionIDResponseItemItem, x), x), from_none], self.item)
        return result


class GetApisAPIIDCollectionsCollectionIDResponse400:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDCollectionsCollectionIDResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDCollectionsCollectionIDResponse400(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDCollectionsCollectionIDResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDCollectionsCollectionIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDCollectionsCollectionIDResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDCollectionsCollectionIDResponse403:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDCollectionsCollectionIDResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDCollectionsCollectionIDResponse403(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDCollectionsCollectionIDResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDCollectionsCollectionIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDCollectionsCollectionIDResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDCollectionsCollectionIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDCollectionsCollectionIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDCollectionsCollectionIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDResponse422:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDResponse422':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDResponse422(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDFilesFilePathResponse:
    """Information about the schema file."""
    """The schema file's content."""
    content: Optional[str]
    """The date and time at which the file was created."""
    created_at: Optional[str]
    """The user Id of the user that created the file."""
    created_by: Optional[str]
    """The schema file's ID."""
    id: Optional[str]
    """The schema file's name."""
    name: Optional[str]
    """The file system path to the schema file."""
    path: Optional[str]
    """The date and time at which the file was last updated."""
    updated_at: Optional[str]
    """The user ID of the user that last updated the file."""
    updated_by: Optional[str]

    def __init__(self, content: Optional[str], created_at: Optional[str], created_by: Optional[str], id: Optional[str], name: Optional[str], path: Optional[str], updated_at: Optional[str], updated_by: Optional[str]) -> None:
        self.content = content
        self.created_at = created_at
        self.created_by = created_by
        self.id = id
        self.name = name
        self.path = path
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDFilesFilePathResponse':
        assert isinstance(obj, dict)
        content = from_union([from_str, from_none], obj.get("content"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_str, from_none], obj.get("createdBy"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        path = from_union([from_str, from_none], obj.get("path"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_str, from_none], obj.get("updatedBy"))
        return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse(content, created_at, created_by, id, name, path, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.content is not None:
            result["content"] = from_union([from_str, from_none], self.content)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_str, from_none], self.created_by)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.path is not None:
            result["path"] = from_union([from_str, from_none], self.path)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_str, from_none], self.updated_by)
        return result


class GetApisAPIIDSchemasSchemaIDFilesFilePathResponse400:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDFilesFilePathResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse400(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDFilesFilePathResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDFilesFilePathResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDFilesFilePathResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDFilesFilePathResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDFilesFilePathResponse422:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDFilesFilePathResponse422':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse422(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDFilesFilePathResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDFilesFilePathResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDFilesResponseFilesItem:
    """Information about the schema file."""
    """The date and time at which the file was created."""
    created_at: Optional[str]
    """The user Id of the user that created the file."""
    created_by: Optional[float]
    """The schema file's ID."""
    id: Optional[str]
    """The schema file's name."""
    name: Optional[str]
    """The file system path to the schema file."""
    path: Optional[str]
    """The date and time at which the file was last updated."""
    updated_at: Optional[str]
    """The user ID of the user that last updated the file."""
    updated_by: Optional[float]

    def __init__(self, created_at: Optional[str], created_by: Optional[float], id: Optional[str], name: Optional[str], path: Optional[str], updated_at: Optional[str], updated_by: Optional[float]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.id = id
        self.name = name
        self.path = path
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDFilesResponseFilesItem':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_float, from_none], obj.get("createdBy"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        path = from_union([from_str, from_none], obj.get("path"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_float, from_none], obj.get("updatedBy"))
        return GetApisAPIIDSchemasSchemaIDFilesResponseFilesItem(created_at, created_by, id, name, path, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([to_float, from_none], self.created_by)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.path is not None:
            result["path"] = from_union([from_str, from_none], self.path)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([to_float, from_none], self.updated_by)
        return result


class GetApisAPIIDSchemasSchemaIDFilesResponseMeta:
    """The schema's non-standard meta information."""
    """The pointer to the next record in the set of paginated results."""
    next_cursor: Optional[str]

    def __init__(self, next_cursor: Optional[str]) -> None:
        self.next_cursor = next_cursor

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDFilesResponseMeta':
        assert isinstance(obj, dict)
        next_cursor = from_union([from_str, from_none], obj.get("nextCursor"))
        return GetApisAPIIDSchemasSchemaIDFilesResponseMeta(next_cursor)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.next_cursor is not None:
            result["nextCursor"] = from_union([from_str, from_none], self.next_cursor)
        return result


class GetApisAPIIDSchemasSchemaIDFilesResponse:
    """Information about the schema files and its meta information."""
    """The schema's files."""
    files: Optional[List[GetApisAPIIDSchemasSchemaIDFilesResponseFilesItem]]
    """The schema's non-standard meta information."""
    meta: Optional[GetApisAPIIDSchemasSchemaIDFilesResponseMeta]

    def __init__(self, files: Optional[List[GetApisAPIIDSchemasSchemaIDFilesResponseFilesItem]], meta: Optional[GetApisAPIIDSchemasSchemaIDFilesResponseMeta]) -> None:
        self.files = files
        self.meta = meta

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDFilesResponse':
        assert isinstance(obj, dict)
        files = from_union([lambda x: from_list(GetApisAPIIDSchemasSchemaIDFilesResponseFilesItem.from_dict, x), from_none], obj.get("files"))
        meta = from_union([GetApisAPIIDSchemasSchemaIDFilesResponseMeta.from_dict, from_none], obj.get("meta"))
        return GetApisAPIIDSchemasSchemaIDFilesResponse(files, meta)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.files is not None:
            result["files"] = from_union([lambda x: from_list(lambda x: to_class(GetApisAPIIDSchemasSchemaIDFilesResponseFilesItem, x), x), from_none], self.files)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(GetApisAPIIDSchemasSchemaIDFilesResponseMeta, x), from_none], self.meta)
        return result


class GetApisAPIIDSchemasSchemaIDFilesResponse400:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDFilesResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDFilesResponse400(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDFilesResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDFilesResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDFilesResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDFilesResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDFilesResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDFilesResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDFilesResponse422:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDFilesResponse422':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDFilesResponse422(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDFilesResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDFilesResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDFilesResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDResponse400:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDResponse400(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDResponse403:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDResponse403(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDResponse422:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDResponse422':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDResponse422(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDSchemasSchemaIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDSchemasSchemaIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDSchemasSchemaIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDTagsResponseTagsItem:
    """Information about the tag."""
    """The tag's ID within a team or individual (non-team) user scope."""
    slug: Optional[str]

    def __init__(self, slug: Optional[str]) -> None:
        self.slug = slug

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDTagsResponseTagsItem':
        assert isinstance(obj, dict)
        slug = from_union([from_str, from_none], obj.get("slug"))
        return GetApisAPIIDTagsResponseTagsItem(slug)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.slug is not None:
            result["slug"] = from_union([from_str, from_none], self.slug)
        return result


class GetApisAPIIDTagsResponse:
    """A list of associated tags."""
    tags: Optional[List[GetApisAPIIDTagsResponseTagsItem]]

    def __init__(self, tags: Optional[List[GetApisAPIIDTagsResponseTagsItem]]) -> None:
        self.tags = tags

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDTagsResponse':
        assert isinstance(obj, dict)
        tags = from_union([lambda x: from_list(GetApisAPIIDTagsResponseTagsItem.from_dict, x), from_none], obj.get("tags"))
        return GetApisAPIIDTagsResponse(tags)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.tags is not None:
            result["tags"] = from_union([lambda x: from_list(lambda x: to_class(GetApisAPIIDTagsResponseTagsItem, x), x), from_none], self.tags)
        return result


class GetApisAPIIDTagsResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDTagsResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDTagsResponse401(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDTagsResponse403:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDTagsResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDTagsResponse403(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDTagsResponse404:
    """Information about the error."""
    detail: Optional[str]
    """The URI reference that identifies the specific occurrence of the problem."""
    instance: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDTagsResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDTagsResponse404(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDTagsResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The URI reference that identifies the specific occurrence of the problem."""
    instance: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDTagsResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDTagsResponse500(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class Action(Enum):
    """The task's action."""
    CREATE = "create"
    UPDATE = "update"


class Model(Enum):
    """The model for which the task is performing the operation."""
    API_VERSION = "api-version"
    COLLECTION = "collection"


class GetApisAPIIDTasksTaskIDResponseMeta:
    """The response's non-standard meta information."""
    """The task's action."""
    action: Optional[Action]
    """The model for which the task is performing the operation."""
    model: Optional[Model]
    """The endpoint URL that created the task."""
    url: Optional[str]

    def __init__(self, action: Optional[Action], model: Optional[Model], url: Optional[str]) -> None:
        self.action = action
        self.model = model
        self.url = url

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDTasksTaskIDResponseMeta':
        assert isinstance(obj, dict)
        action = from_union([Action, from_none], obj.get("action"))
        model = from_union([Model, from_none], obj.get("model"))
        url = from_union([from_str, from_none], obj.get("url"))
        return GetApisAPIIDTasksTaskIDResponseMeta(action, model, url)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.action is not None:
            result["action"] = from_union([lambda x: to_enum(Action, x), from_none], self.action)
        if self.model is not None:
            result["model"] = from_union([lambda x: to_enum(Model, x), from_none], self.model)
        if self.url is not None:
            result["url"] = from_union([from_str, from_none], self.url)
        return result


class GetApisAPIIDTasksTaskIDResponseStatus(Enum):
    """The task's current status."""
    COMPLETED = "completed"
    FAILED = "failed"
    PENDING = "pending"


class GetApisAPIIDTasksTaskIDResponse:
    """The date and time at which the task was created."""
    created_at: Optional[str]
    details: Any
    """The task's ID."""
    id: Optional[str]
    """The response's non-standard meta information."""
    meta: Optional[GetApisAPIIDTasksTaskIDResponseMeta]
    """The task's current status."""
    status: Optional[GetApisAPIIDTasksTaskIDResponseStatus]
    """The date and time at which the task was last updated."""
    updated_at: Optional[str]

    def __init__(self, created_at: Optional[str], details: Any, id: Optional[str], meta: Optional[GetApisAPIIDTasksTaskIDResponseMeta], status: Optional[GetApisAPIIDTasksTaskIDResponseStatus], updated_at: Optional[str]) -> None:
        self.created_at = created_at
        self.details = details
        self.id = id
        self.meta = meta
        self.status = status
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDTasksTaskIDResponse':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        details = obj.get("details")
        id = from_union([from_str, from_none], obj.get("id"))
        meta = from_union([GetApisAPIIDTasksTaskIDResponseMeta.from_dict, from_none], obj.get("meta"))
        status = from_union([GetApisAPIIDTasksTaskIDResponseStatus, from_none], obj.get("status"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return GetApisAPIIDTasksTaskIDResponse(created_at, details, id, meta, status, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.details is not None:
            result["details"] = self.details
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(GetApisAPIIDTasksTaskIDResponseMeta, x), from_none], self.meta)
        if self.status is not None:
            result["status"] = from_union([lambda x: to_enum(GetApisAPIIDTasksTaskIDResponseStatus, x), from_none], self.status)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class GetApisAPIIDTasksTaskIDResponse400:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDTasksTaskIDResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDTasksTaskIDResponse400(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDTasksTaskIDResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDTasksTaskIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDTasksTaskIDResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDTasksTaskIDResponse403:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDTasksTaskIDResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDTasksTaskIDResponse403(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDTasksTaskIDResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDTasksTaskIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDTasksTaskIDResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDVersionsResponseMeta:
    """The response's meta information for paginated results."""
    """The maximum number of records in the paginated response."""
    limit: Optional[float]
    """The Base64-encoded value that points to the next record in the results set."""
    next_cursor: Optional[str]
    """The number of records that match the defined criteria."""
    total: Optional[float]

    def __init__(self, limit: Optional[float], next_cursor: Optional[str], total: Optional[float]) -> None:
        self.limit = limit
        self.next_cursor = next_cursor
        self.total = total

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDVersionsResponseMeta':
        assert isinstance(obj, dict)
        limit = from_union([from_float, from_none], obj.get("limit"))
        next_cursor = from_union([from_str, from_none], obj.get("nextCursor"))
        total = from_union([from_float, from_none], obj.get("total"))
        return GetApisAPIIDVersionsResponseMeta(limit, next_cursor, total)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.limit is not None:
            result["limit"] = from_union([to_float, from_none], self.limit)
        if self.next_cursor is not None:
            result["nextCursor"] = from_union([from_str, from_none], self.next_cursor)
        if self.total is not None:
            result["total"] = from_union([to_float, from_none], self.total)
        return result


class GetApisAPIIDVersionsResponseVersionsItem:
    """Information about the API version."""
    """The date and time at which the version was created."""
    created_at: Optional[str]
    """The version's ID."""
    id: Optional[str]
    """The version's name."""
    name: Optional[str]
    """The version's release notes."""
    release_notes: Optional[str]
    """The date and time at which the version was last updated."""
    updated_at: Optional[str]

    def __init__(self, created_at: Optional[str], id: Optional[str], name: Optional[str], release_notes: Optional[str], updated_at: Optional[str]) -> None:
        self.created_at = created_at
        self.id = id
        self.name = name
        self.release_notes = release_notes
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDVersionsResponseVersionsItem':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        release_notes = from_union([from_str, from_none], obj.get("releaseNotes"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return GetApisAPIIDVersionsResponseVersionsItem(created_at, id, name, release_notes, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.release_notes is not None:
            result["releaseNotes"] = from_union([from_str, from_none], self.release_notes)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class GetApisAPIIDVersionsResponse:
    """Information about the API's versions."""
    """The response's meta information for paginated results."""
    meta: Optional[GetApisAPIIDVersionsResponseMeta]
    versions: Optional[List[GetApisAPIIDVersionsResponseVersionsItem]]

    def __init__(self, meta: Optional[GetApisAPIIDVersionsResponseMeta], versions: Optional[List[GetApisAPIIDVersionsResponseVersionsItem]]) -> None:
        self.meta = meta
        self.versions = versions

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDVersionsResponse':
        assert isinstance(obj, dict)
        meta = from_union([GetApisAPIIDVersionsResponseMeta.from_dict, from_none], obj.get("meta"))
        versions = from_union([lambda x: from_list(GetApisAPIIDVersionsResponseVersionsItem.from_dict, x), from_none], obj.get("versions"))
        return GetApisAPIIDVersionsResponse(meta, versions)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(GetApisAPIIDVersionsResponseMeta, x), from_none], self.meta)
        if self.versions is not None:
            result["versions"] = from_union([lambda x: from_list(lambda x: to_class(GetApisAPIIDVersionsResponseVersionsItem, x), x), from_none], self.versions)
        return result


class GetApisAPIIDVersionsResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDVersionsResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDVersionsResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDVersionsResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDVersionsResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDVersionsResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDVersionsResponse422:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDVersionsResponse422':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDVersionsResponse422(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDVersionsResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDVersionsResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDVersionsResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDVersionsVersionIDResponseVersionCollectionsItem:
    """The collection's ID."""
    id: Optional[str]
    """The collection's name."""
    type: Optional[str]

    def __init__(self, id: Optional[str], type: Optional[str]) -> None:
        self.id = id
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDVersionsVersionIDResponseVersionCollectionsItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDVersionsVersionIDResponseVersionCollectionsItem(id, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDVersionsVersionIDResponseVersionSchemasItem:
    """The schema's ID."""
    id: Optional[str]
    """The schema type."""
    type: Optional[str]

    def __init__(self, id: Optional[str], type: Optional[str]) -> None:
        self.id = id
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDVersionsVersionIDResponseVersionSchemasItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDVersionsVersionIDResponseVersionSchemasItem(id, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDVersionsVersionIDResponseVersion:
    """Information about the API version."""
    collections: Optional[List[GetApisAPIIDVersionsVersionIDResponseVersionCollectionsItem]]
    """The date and time at which the version was created."""
    created_at: Optional[str]
    """The version's ID."""
    id: Optional[str]
    """The version's name."""
    name: Optional[str]
    """The version's release notes."""
    release_notes: Optional[str]
    schemas: Optional[List[GetApisAPIIDVersionsVersionIDResponseVersionSchemasItem]]
    """The date and time at which the version was last updated."""
    updated_at: Optional[str]

    def __init__(self, collections: Optional[List[GetApisAPIIDVersionsVersionIDResponseVersionCollectionsItem]], created_at: Optional[str], id: Optional[str], name: Optional[str], release_notes: Optional[str], schemas: Optional[List[GetApisAPIIDVersionsVersionIDResponseVersionSchemasItem]], updated_at: Optional[str]) -> None:
        self.collections = collections
        self.created_at = created_at
        self.id = id
        self.name = name
        self.release_notes = release_notes
        self.schemas = schemas
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDVersionsVersionIDResponseVersion':
        assert isinstance(obj, dict)
        collections = from_union([lambda x: from_list(GetApisAPIIDVersionsVersionIDResponseVersionCollectionsItem.from_dict, x), from_none], obj.get("collections"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        release_notes = from_union([from_str, from_none], obj.get("releaseNotes"))
        schemas = from_union([lambda x: from_list(GetApisAPIIDVersionsVersionIDResponseVersionSchemasItem.from_dict, x), from_none], obj.get("schemas"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return GetApisAPIIDVersionsVersionIDResponseVersion(collections, created_at, id, name, release_notes, schemas, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collections is not None:
            result["collections"] = from_union([lambda x: from_list(lambda x: to_class(GetApisAPIIDVersionsVersionIDResponseVersionCollectionsItem, x), x), from_none], self.collections)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.release_notes is not None:
            result["releaseNotes"] = from_union([from_str, from_none], self.release_notes)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(lambda x: to_class(GetApisAPIIDVersionsVersionIDResponseVersionSchemasItem, x), x), from_none], self.schemas)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class GetApisAPIIDVersionsVersionIDResponse:
    """Information about the API version."""
    version: Optional[GetApisAPIIDVersionsVersionIDResponseVersion]

    def __init__(self, version: Optional[GetApisAPIIDVersionsVersionIDResponseVersion]) -> None:
        self.version = version

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDVersionsVersionIDResponse':
        assert isinstance(obj, dict)
        version = from_union([GetApisAPIIDVersionsVersionIDResponseVersion.from_dict, from_none], obj.get("version"))
        return GetApisAPIIDVersionsVersionIDResponse(version)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.version is not None:
            result["version"] = from_union([lambda x: to_class(GetApisAPIIDVersionsVersionIDResponseVersion, x), from_none], self.version)
        return result


class GetApisAPIIDVersionsVersionIDResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDVersionsVersionIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDVersionsVersionIDResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDVersionsVersionIDResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDVersionsVersionIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDVersionsVersionIDResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisAPIIDVersionsVersionIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisAPIIDVersionsVersionIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisAPIIDVersionsVersionIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisResponseApisItem:
    """The API's base data schema."""
    """The date and time at which the API was created."""
    created_at: Optional[str]
    """The Postman ID of the user that created the API."""
    created_by: Optional[float]
    """The API's description."""
    description: Optional[str]
    """The API's ID."""
    id: Optional[str]
    """The API's name."""
    name: Optional[str]
    """The API's short summary."""
    summary: Optional[str]
    """The date and time at which the API was updated."""
    updated_at: Optional[str]
    """The Postman ID of the user that updated the API."""
    updated_by: Optional[float]

    def __init__(self, created_at: Optional[str], created_by: Optional[float], description: Optional[str], id: Optional[str], name: Optional[str], summary: Optional[str], updated_at: Optional[str], updated_by: Optional[float]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.description = description
        self.id = id
        self.name = name
        self.summary = summary
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisResponseApisItem':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_float, from_none], obj.get("createdBy"))
        description = from_union([from_str, from_none], obj.get("description"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        summary = from_union([from_str, from_none], obj.get("summary"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_float, from_none], obj.get("updatedBy"))
        return GetApisResponseApisItem(created_at, created_by, description, id, name, summary, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([to_float, from_none], self.created_by)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.summary is not None:
            result["summary"] = from_union([from_str, from_none], self.summary)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([to_float, from_none], self.updated_by)
        return result


class GetApisResponseMeta:
    """The response's meta information for paginated results."""
    """The maximum number of records in the paginated response."""
    limit: Optional[float]
    """The Base64-encoded value that points to the next record in the results set."""
    next_cursor: Optional[str]
    """The number of records that match the defined criteria."""
    total: Optional[float]

    def __init__(self, limit: Optional[float], next_cursor: Optional[str], total: Optional[float]) -> None:
        self.limit = limit
        self.next_cursor = next_cursor
        self.total = total

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisResponseMeta':
        assert isinstance(obj, dict)
        limit = from_union([from_float, from_none], obj.get("limit"))
        next_cursor = from_union([from_str, from_none], obj.get("nextCursor"))
        total = from_union([from_float, from_none], obj.get("total"))
        return GetApisResponseMeta(limit, next_cursor, total)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.limit is not None:
            result["limit"] = from_union([to_float, from_none], self.limit)
        if self.next_cursor is not None:
            result["nextCursor"] = from_union([from_str, from_none], self.next_cursor)
        if self.total is not None:
            result["total"] = from_union([to_float, from_none], self.total)
        return result


class GetApisResponse:
    """Information about the API schema."""
    apis: Optional[List[GetApisResponseApisItem]]
    """The response's meta information for paginated results."""
    meta: Optional[GetApisResponseMeta]

    def __init__(self, apis: Optional[List[GetApisResponseApisItem]], meta: Optional[GetApisResponseMeta]) -> None:
        self.apis = apis
        self.meta = meta

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisResponse':
        assert isinstance(obj, dict)
        apis = from_union([lambda x: from_list(GetApisResponseApisItem.from_dict, x), from_none], obj.get("apis"))
        meta = from_union([GetApisResponseMeta.from_dict, from_none], obj.get("meta"))
        return GetApisResponse(apis, meta)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.apis is not None:
            result["apis"] = from_union([lambda x: from_list(lambda x: to_class(GetApisResponseApisItem, x), x), from_none], self.apis)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(GetApisResponseMeta, x), from_none], self.meta)
        return result


class GetApisResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetApisResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetApisResponse401:
    error: Optional[GetApisResponse401Error]

    def __init__(self, error: Optional[GetApisResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetApisResponse401Error.from_dict, from_none], obj.get("error"))
        return GetApisResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetApisResponse401Error, x), from_none], self.error)
        return result


class GetApisResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisResponse422:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisResponse422':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisResponse422(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetApisResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetApisResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetApisResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetAuditLogsResponseTrailsItemDataActor:
    """Information about the user who preformed the audit event."""
    """If true, the user is active. If false, the user is deactivated."""
    active: Optional[bool]
    """The user's email address."""
    email: Optional[str]
    id: Optional[float]
    """The user's name."""
    name: Optional[str]
    """The user's username."""
    username: Optional[str]

    def __init__(self, active: Optional[bool], email: Optional[str], id: Optional[float], name: Optional[str], username: Optional[str]) -> None:
        self.active = active
        self.email = email
        self.id = id
        self.name = name
        self.username = username

    @staticmethod
    def from_dict(obj: Any) -> 'GetAuditLogsResponseTrailsItemDataActor':
        assert isinstance(obj, dict)
        active = from_union([from_bool, from_none], obj.get("active"))
        email = from_union([from_str, from_none], obj.get("email"))
        id = from_union([from_float, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        username = from_union([from_str, from_none], obj.get("username"))
        return GetAuditLogsResponseTrailsItemDataActor(active, email, id, name, username)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.active is not None:
            result["active"] = from_union([from_bool, from_none], self.active)
        if self.email is not None:
            result["email"] = from_union([from_str, from_none], self.email)
        if self.id is not None:
            result["id"] = from_union([to_float, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.username is not None:
            result["username"] = from_union([from_str, from_none], self.username)
        return result


class GetAuditLogsResponseTrailsItemDataTeam:
    """The user's team information."""
    """The team's ID."""
    id: Optional[float]
    """The team's name."""
    name: Optional[str]

    def __init__(self, id: Optional[float], name: Optional[str]) -> None:
        self.id = id
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetAuditLogsResponseTrailsItemDataTeam':
        assert isinstance(obj, dict)
        id = from_union([from_float, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetAuditLogsResponseTrailsItemDataTeam(id, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([to_float, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetAuditLogsResponseTrailsItemDataUser:
    """Information about the user."""
    """The user's email address."""
    email: Optional[str]
    """The user's ID."""
    id: Optional[float]
    """The user's name."""
    name: Optional[str]
    """The user's username."""
    username: Optional[str]

    def __init__(self, email: Optional[str], id: Optional[float], name: Optional[str], username: Optional[str]) -> None:
        self.email = email
        self.id = id
        self.name = name
        self.username = username

    @staticmethod
    def from_dict(obj: Any) -> 'GetAuditLogsResponseTrailsItemDataUser':
        assert isinstance(obj, dict)
        email = from_union([from_str, from_none], obj.get("email"))
        id = from_union([from_float, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        username = from_union([from_str, from_none], obj.get("username"))
        return GetAuditLogsResponseTrailsItemDataUser(email, id, name, username)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.email is not None:
            result["email"] = from_union([from_str, from_none], self.email)
        if self.id is not None:
            result["id"] = from_union([to_float, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.username is not None:
            result["username"] = from_union([from_str, from_none], self.username)
        return result


class GetAuditLogsResponseTrailsItemData:
    """Information about the user who preformed the audit event."""
    actor: Optional[GetAuditLogsResponseTrailsItemDataActor]
    """The user's team information."""
    team: Optional[GetAuditLogsResponseTrailsItemDataTeam]
    """Information about the user."""
    user: Optional[GetAuditLogsResponseTrailsItemDataUser]
    variables: Any

    def __init__(self, actor: Optional[GetAuditLogsResponseTrailsItemDataActor], team: Optional[GetAuditLogsResponseTrailsItemDataTeam], user: Optional[GetAuditLogsResponseTrailsItemDataUser], variables: Any) -> None:
        self.actor = actor
        self.team = team
        self.user = user
        self.variables = variables

    @staticmethod
    def from_dict(obj: Any) -> 'GetAuditLogsResponseTrailsItemData':
        assert isinstance(obj, dict)
        actor = from_union([GetAuditLogsResponseTrailsItemDataActor.from_dict, from_none], obj.get("actor"))
        team = from_union([GetAuditLogsResponseTrailsItemDataTeam.from_dict, from_none], obj.get("team"))
        user = from_union([GetAuditLogsResponseTrailsItemDataUser.from_dict, from_none], obj.get("user"))
        variables = obj.get("variables")
        return GetAuditLogsResponseTrailsItemData(actor, team, user, variables)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.actor is not None:
            result["actor"] = from_union([lambda x: to_class(GetAuditLogsResponseTrailsItemDataActor, x), from_none], self.actor)
        if self.team is not None:
            result["team"] = from_union([lambda x: to_class(GetAuditLogsResponseTrailsItemDataTeam, x), from_none], self.team)
        if self.user is not None:
            result["user"] = from_union([lambda x: to_class(GetAuditLogsResponseTrailsItemDataUser, x), from_none], self.user)
        if self.variables is not None:
            result["variables"] = self.variables
        return result


class GetAuditLogsResponseTrailsItem:
    """The action performed by the user."""
    action: Optional[str]
    data: Optional[GetAuditLogsResponseTrailsItemData]
    """The audit event's ID."""
    id: Optional[float]
    """The IP address of the user that performed the action."""
    ip: Optional[str]
    """The audit event's description."""
    message: Optional[str]
    """The date and time at which the event occurred."""
    timestamp: Optional[str]
    """The user agent information."""
    user_agent: Optional[str]

    def __init__(self, action: Optional[str], data: Optional[GetAuditLogsResponseTrailsItemData], id: Optional[float], ip: Optional[str], message: Optional[str], timestamp: Optional[str], user_agent: Optional[str]) -> None:
        self.action = action
        self.data = data
        self.id = id
        self.ip = ip
        self.message = message
        self.timestamp = timestamp
        self.user_agent = user_agent

    @staticmethod
    def from_dict(obj: Any) -> 'GetAuditLogsResponseTrailsItem':
        assert isinstance(obj, dict)
        action = from_union([from_str, from_none], obj.get("action"))
        data = from_union([GetAuditLogsResponseTrailsItemData.from_dict, from_none], obj.get("data"))
        id = from_union([from_float, from_none], obj.get("id"))
        ip = from_union([from_str, from_none], obj.get("ip"))
        message = from_union([from_str, from_none], obj.get("message"))
        timestamp = from_union([from_str, from_none], obj.get("timestamp"))
        user_agent = from_union([from_str, from_none], obj.get("userAgent"))
        return GetAuditLogsResponseTrailsItem(action, data, id, ip, message, timestamp, user_agent)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.action is not None:
            result["action"] = from_union([from_str, from_none], self.action)
        if self.data is not None:
            result["data"] = from_union([lambda x: to_class(GetAuditLogsResponseTrailsItemData, x), from_none], self.data)
        if self.id is not None:
            result["id"] = from_union([to_float, from_none], self.id)
        if self.ip is not None:
            result["ip"] = from_union([from_str, from_none], self.ip)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.timestamp is not None:
            result["timestamp"] = from_union([from_str, from_none], self.timestamp)
        if self.user_agent is not None:
            result["userAgent"] = from_union([from_str, from_none], self.user_agent)
        return result


class GetAuditLogsResponse:
    trails: Optional[List[GetAuditLogsResponseTrailsItem]]

    def __init__(self, trails: Optional[List[GetAuditLogsResponseTrailsItem]]) -> None:
        self.trails = trails

    @staticmethod
    def from_dict(obj: Any) -> 'GetAuditLogsResponse':
        assert isinstance(obj, dict)
        trails = from_union([lambda x: from_list(GetAuditLogsResponseTrailsItem.from_dict, x), from_none], obj.get("trails"))
        return GetAuditLogsResponse(trails)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.trails is not None:
            result["trails"] = from_union([lambda x: from_list(lambda x: to_class(GetAuditLogsResponseTrailsItem, x), x), from_none], self.trails)
        return result


class GetAuditLogsResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetAuditLogsResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetAuditLogsResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetAuditLogsResponse401:
    error: Optional[GetAuditLogsResponse401Error]

    def __init__(self, error: Optional[GetAuditLogsResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetAuditLogsResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetAuditLogsResponse401Error.from_dict, from_none], obj.get("error"))
        return GetAuditLogsResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetAuditLogsResponse401Error, x), from_none], self.error)
        return result


class GetAuditLogsResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetAuditLogsResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetAuditLogsResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetAuditLogsResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetAuditLogsResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetAuditLogsResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetAuditLogsResponse500:
    error: Optional[GetAuditLogsResponse500Error]

    def __init__(self, error: Optional[GetAuditLogsResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetAuditLogsResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetAuditLogsResponse500Error.from_dict, from_none], obj.get("error"))
        return GetAuditLogsResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetAuditLogsResponse500Error, x), from_none], self.error)
        return result


class GetCollectionsCollectionIDFoldersFolderIDResponseData:
    """Information about the folder. For a complete list of properties, refer to the
    `definitions.folder` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    """The collection ID that the folder belongs to."""
    collection: Optional[str]
    """The folder's creation date and time."""
    created_at: Optional[str]
    """The folder's description."""
    description: Optional[str]
    """The folder's ID."""
    id: Optional[str]
    """An internal revision ID. Its value increments each time the resource changes. You can use
    this ID to track whether there were changes since the last time you fetched the resource.
    """
    last_revision: Optional[int]
    """The user ID of the user that last updated the folder."""
    last_updated_by: Optional[str]
    """The folder's name."""
    name: Optional[str]
    """The user ID of the folder's owner."""
    owner: Optional[str]
    """The date and time at which the folder was last updated."""
    updated_at: Optional[str]

    def __init__(self, collection: Optional[str], created_at: Optional[str], description: Optional[str], id: Optional[str], last_revision: Optional[int], last_updated_by: Optional[str], name: Optional[str], owner: Optional[str], updated_at: Optional[str]) -> None:
        self.collection = collection
        self.created_at = created_at
        self.description = description
        self.id = id
        self.last_revision = last_revision
        self.last_updated_by = last_updated_by
        self.name = name
        self.owner = owner
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDFoldersFolderIDResponseData':
        assert isinstance(obj, dict)
        collection = from_union([from_str, from_none], obj.get("collection"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        description = from_union([from_str, from_none], obj.get("description"))
        id = from_union([from_str, from_none], obj.get("id"))
        last_revision = from_union([from_int, from_none], obj.get("lastRevision"))
        last_updated_by = from_union([from_str, from_none], obj.get("lastUpdatedBy"))
        name = from_union([from_str, from_none], obj.get("name"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return GetCollectionsCollectionIDFoldersFolderIDResponseData(collection, created_at, description, id, last_revision, last_updated_by, name, owner, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([from_str, from_none], self.collection)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.last_revision is not None:
            result["lastRevision"] = from_union([from_int, from_none], self.last_revision)
        if self.last_updated_by is not None:
            result["lastUpdatedBy"] = from_union([from_str, from_none], self.last_updated_by)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class GetCollectionsCollectionIDFoldersFolderIDResponse:
    """Information about the folder. For a complete list of properties, refer to the
    `definitions.folder` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    data: Optional[GetCollectionsCollectionIDFoldersFolderIDResponseData]
    meta: Any
    """The folder's ID."""
    model_id: Optional[str]

    def __init__(self, data: Optional[GetCollectionsCollectionIDFoldersFolderIDResponseData], meta: Any, model_id: Optional[str]) -> None:
        self.data = data
        self.meta = meta
        self.model_id = model_id

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDFoldersFolderIDResponse':
        assert isinstance(obj, dict)
        data = from_union([GetCollectionsCollectionIDFoldersFolderIDResponseData.from_dict, from_none], obj.get("data"))
        meta = obj.get("meta")
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        return GetCollectionsCollectionIDFoldersFolderIDResponse(data, meta, model_id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: to_class(GetCollectionsCollectionIDFoldersFolderIDResponseData, x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = self.meta
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        return result


class GetCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The folder's ID."""
    model_id: Optional[str]
    """The user ID of the folder's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return GetCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class GetCollectionsCollectionIDFoldersFolderIDResponse401Error:
    """Information about the error."""
    details: Optional[GetCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails]
    """The error's message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[GetCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDFoldersFolderIDResponse401Error':
        assert isinstance(obj, dict)
        details = from_union([GetCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetCollectionsCollectionIDFoldersFolderIDResponse401Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(GetCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetCollectionsCollectionIDFoldersFolderIDResponse401:
    error: Optional[GetCollectionsCollectionIDFoldersFolderIDResponse401Error]

    def __init__(self, error: Optional[GetCollectionsCollectionIDFoldersFolderIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDFoldersFolderIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetCollectionsCollectionIDFoldersFolderIDResponse401Error.from_dict, from_none], obj.get("error"))
        return GetCollectionsCollectionIDFoldersFolderIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetCollectionsCollectionIDFoldersFolderIDResponse401Error, x), from_none], self.error)
        return result


class GetCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The folder's ID."""
    model_id: Optional[str]
    """The user ID of the folder's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return GetCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class GetCollectionsCollectionIDFoldersFolderIDResponse404Error:
    """Information about the error."""
    details: Optional[GetCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[GetCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDFoldersFolderIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([GetCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetCollectionsCollectionIDFoldersFolderIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(GetCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetCollectionsCollectionIDFoldersFolderIDResponse404:
    error: Optional[GetCollectionsCollectionIDFoldersFolderIDResponse404Error]

    def __init__(self, error: Optional[GetCollectionsCollectionIDFoldersFolderIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDFoldersFolderIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([GetCollectionsCollectionIDFoldersFolderIDResponse404Error.from_dict, from_none], obj.get("error"))
        return GetCollectionsCollectionIDFoldersFolderIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetCollectionsCollectionIDFoldersFolderIDResponse404Error, x), from_none], self.error)
        return result


class GetCollectionsCollectionIDFoldersFolderIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDFoldersFolderIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetCollectionsCollectionIDFoldersFolderIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetCollectionsCollectionIDRequestsRequestIDResponseData:
    """Information about the request. For a complete list of properties, refer to the
    `definitions.request` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    """The request's creation date and time."""
    created_at: Optional[str]
    """The request's ID."""
    id: Optional[str]
    """An internal revision ID. Its value increments each time the resource changes. You can use
    this ID to track whether there were changes since the last time you fetched the resource.
    """
    last_revision: Optional[int]
    """The user ID of the user that last updated the request."""
    last_updated_by: Optional[str]
    """The request's name."""
    name: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]
    """The date and time at which the request was last updated."""
    updated_at: Optional[str]

    def __init__(self, created_at: Optional[str], id: Optional[str], last_revision: Optional[int], last_updated_by: Optional[str], name: Optional[str], owner: Optional[str], updated_at: Optional[str]) -> None:
        self.created_at = created_at
        self.id = id
        self.last_revision = last_revision
        self.last_updated_by = last_updated_by
        self.name = name
        self.owner = owner
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDRequestsRequestIDResponseData':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        id = from_union([from_str, from_none], obj.get("id"))
        last_revision = from_union([from_int, from_none], obj.get("lastRevision"))
        last_updated_by = from_union([from_str, from_none], obj.get("lastUpdatedBy"))
        name = from_union([from_str, from_none], obj.get("name"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return GetCollectionsCollectionIDRequestsRequestIDResponseData(created_at, id, last_revision, last_updated_by, name, owner, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.last_revision is not None:
            result["lastRevision"] = from_union([from_int, from_none], self.last_revision)
        if self.last_updated_by is not None:
            result["lastUpdatedBy"] = from_union([from_str, from_none], self.last_updated_by)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class GetCollectionsCollectionIDRequestsRequestIDResponse:
    """Information about the request. For a complete list of properties, refer to the
    `definitions.request` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    data: Optional[GetCollectionsCollectionIDRequestsRequestIDResponseData]
    meta: Any
    """The request's ID."""
    model_id: Optional[str]

    def __init__(self, data: Optional[GetCollectionsCollectionIDRequestsRequestIDResponseData], meta: Any, model_id: Optional[str]) -> None:
        self.data = data
        self.meta = meta
        self.model_id = model_id

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDRequestsRequestIDResponse':
        assert isinstance(obj, dict)
        data = from_union([GetCollectionsCollectionIDRequestsRequestIDResponseData.from_dict, from_none], obj.get("data"))
        meta = obj.get("meta")
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        return GetCollectionsCollectionIDRequestsRequestIDResponse(data, meta, model_id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: to_class(GetCollectionsCollectionIDRequestsRequestIDResponseData, x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = self.meta
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        return result


class GetCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The request's ID."""
    model_id: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return GetCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class GetCollectionsCollectionIDRequestsRequestIDResponse401Error:
    """Information about the error."""
    details: Optional[GetCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails]
    """The error's message."""
    message: Optional[str]
    """The error's name."""
    name: Optional[str]

    def __init__(self, details: Optional[GetCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDRequestsRequestIDResponse401Error':
        assert isinstance(obj, dict)
        details = from_union([GetCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetCollectionsCollectionIDRequestsRequestIDResponse401Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(GetCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetCollectionsCollectionIDRequestsRequestIDResponse401:
    error: Optional[GetCollectionsCollectionIDRequestsRequestIDResponse401Error]

    def __init__(self, error: Optional[GetCollectionsCollectionIDRequestsRequestIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDRequestsRequestIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetCollectionsCollectionIDRequestsRequestIDResponse401Error.from_dict, from_none], obj.get("error"))
        return GetCollectionsCollectionIDRequestsRequestIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetCollectionsCollectionIDRequestsRequestIDResponse401Error, x), from_none], self.error)
        return result


class GetCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The request's ID."""
    model_id: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return GetCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class GetCollectionsCollectionIDRequestsRequestIDResponse404Error:
    """Information about the error."""
    details: Optional[GetCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[GetCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDRequestsRequestIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([GetCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetCollectionsCollectionIDRequestsRequestIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(GetCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetCollectionsCollectionIDRequestsRequestIDResponse404:
    error: Optional[GetCollectionsCollectionIDRequestsRequestIDResponse404Error]

    def __init__(self, error: Optional[GetCollectionsCollectionIDRequestsRequestIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDRequestsRequestIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([GetCollectionsCollectionIDRequestsRequestIDResponse404Error.from_dict, from_none], obj.get("error"))
        return GetCollectionsCollectionIDRequestsRequestIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetCollectionsCollectionIDRequestsRequestIDResponse404Error, x), from_none], self.error)
        return result


class GetCollectionsCollectionIDRequestsRequestIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDRequestsRequestIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetCollectionsCollectionIDRequestsRequestIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetCollectionsCollectionIDResponseCollectionInfo:
    """An object that contains basic information about the collection."""
    """The collection's Postman ID."""
    postman_id: Optional[str]
    """The collection's description."""
    description: Optional[str]
    """The collection's name."""
    name: Optional[str]
    """A URL to the collection's schema."""
    schema: Optional[str]
    """The collection's unique ID."""
    uid: Optional[str]
    """The date and time at which the collection was last updated."""
    updated_at: Optional[str]

    def __init__(self, postman_id: Optional[str], description: Optional[str], name: Optional[str], schema: Optional[str], uid: Optional[str], updated_at: Optional[str]) -> None:
        self.postman_id = postman_id
        self.description = description
        self.name = name
        self.schema = schema
        self.uid = uid
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponseCollectionInfo':
        assert isinstance(obj, dict)
        postman_id = from_union([from_str, from_none], obj.get("_postman_id"))
        description = from_union([from_str, from_none], obj.get("description"))
        name = from_union([from_str, from_none], obj.get("name"))
        schema = from_union([from_str, from_none], obj.get("schema"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return GetCollectionsCollectionIDResponseCollectionInfo(postman_id, description, name, schema, uid, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.postman_id is not None:
            result["_postman_id"] = from_union([from_str, from_none], self.postman_id)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.schema is not None:
            result["schema"] = from_union([from_str, from_none], self.schema)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class GetCollectionsCollectionIDResponseCollection:
    """For a complete list of this endpoint's possible values, use the [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    """An object that contains basic information about the collection."""
    info: Optional[GetCollectionsCollectionIDResponseCollectionInfo]

    def __init__(self, info: Optional[GetCollectionsCollectionIDResponseCollectionInfo]) -> None:
        self.info = info

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponseCollection':
        assert isinstance(obj, dict)
        info = from_union([GetCollectionsCollectionIDResponseCollectionInfo.from_dict, from_none], obj.get("info"))
        return GetCollectionsCollectionIDResponseCollection(info)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.info is not None:
            result["info"] = from_union([lambda x: to_class(GetCollectionsCollectionIDResponseCollectionInfo, x), from_none], self.info)
        return result


class GetCollectionsCollectionIDResponse:
    """For a complete list of this endpoint's possible values, use the [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    collection: Optional[GetCollectionsCollectionIDResponseCollection]

    def __init__(self, collection: Optional[GetCollectionsCollectionIDResponseCollection]) -> None:
        self.collection = collection

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponse':
        assert isinstance(obj, dict)
        collection = from_union([GetCollectionsCollectionIDResponseCollection.from_dict, from_none], obj.get("collection"))
        return GetCollectionsCollectionIDResponse(collection)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([lambda x: to_class(GetCollectionsCollectionIDResponseCollection, x), from_none], self.collection)
        return result


class GetCollectionsCollectionIDResponse400Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponse400Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetCollectionsCollectionIDResponse400Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetCollectionsCollectionIDResponse400:
    error: Optional[GetCollectionsCollectionIDResponse400Error]

    def __init__(self, error: Optional[GetCollectionsCollectionIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([GetCollectionsCollectionIDResponse400Error.from_dict, from_none], obj.get("error"))
        return GetCollectionsCollectionIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetCollectionsCollectionIDResponse400Error, x), from_none], self.error)
        return result


class GetCollectionsCollectionIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetCollectionsCollectionIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetCollectionsCollectionIDResponse401:
    error: Optional[GetCollectionsCollectionIDResponse401Error]

    def __init__(self, error: Optional[GetCollectionsCollectionIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetCollectionsCollectionIDResponse401Error.from_dict, from_none], obj.get("error"))
        return GetCollectionsCollectionIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetCollectionsCollectionIDResponse401Error, x), from_none], self.error)
        return result


class GetCollectionsCollectionIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetCollectionsCollectionIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetCollectionsCollectionIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetCollectionsCollectionIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetCollectionsCollectionIDResponse500:
    error: Optional[GetCollectionsCollectionIDResponse500Error]

    def __init__(self, error: Optional[GetCollectionsCollectionIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetCollectionsCollectionIDResponse500Error.from_dict, from_none], obj.get("error"))
        return GetCollectionsCollectionIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetCollectionsCollectionIDResponse500Error, x), from_none], self.error)
        return result


class GetCollectionsCollectionIDResponsesResponseIDResponseData:
    """Information about the response. For a complete list of properties, refer to the
    `request.responses` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    """The response's creation date and time."""
    created_at: Optional[str]
    """The response's ID."""
    id: Optional[str]
    """An internal revision ID. Its value increments each time the resource changes. You can use
    this ID to track whether there were changes since the last time you fetched the resource.
    """
    last_revision: Optional[int]
    """The user ID of the user that last updated the response."""
    last_updated_by: Optional[str]
    """The response's name."""
    name: Optional[str]
    """The user ID of the response's owner."""
    owner: Optional[str]
    """The ID of the request that the response belongs to."""
    request: Optional[str]
    """The date and time at which the response was last updated."""
    updated_at: Optional[str]

    def __init__(self, created_at: Optional[str], id: Optional[str], last_revision: Optional[int], last_updated_by: Optional[str], name: Optional[str], owner: Optional[str], request: Optional[str], updated_at: Optional[str]) -> None:
        self.created_at = created_at
        self.id = id
        self.last_revision = last_revision
        self.last_updated_by = last_updated_by
        self.name = name
        self.owner = owner
        self.request = request
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponsesResponseIDResponseData':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        id = from_union([from_str, from_none], obj.get("id"))
        last_revision = from_union([from_int, from_none], obj.get("lastRevision"))
        last_updated_by = from_union([from_str, from_none], obj.get("lastUpdatedBy"))
        name = from_union([from_str, from_none], obj.get("name"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        request = from_union([from_str, from_none], obj.get("request"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return GetCollectionsCollectionIDResponsesResponseIDResponseData(created_at, id, last_revision, last_updated_by, name, owner, request, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.last_revision is not None:
            result["lastRevision"] = from_union([from_int, from_none], self.last_revision)
        if self.last_updated_by is not None:
            result["lastUpdatedBy"] = from_union([from_str, from_none], self.last_updated_by)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.request is not None:
            result["request"] = from_union([from_str, from_none], self.request)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class GetCollectionsCollectionIDResponsesResponseIDResponse:
    """Information about the response. For a complete list of properties, refer to the
    `request.responses` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    data: Optional[GetCollectionsCollectionIDResponsesResponseIDResponseData]
    meta: Any
    """The response's ID."""
    model_id: Optional[str]

    def __init__(self, data: Optional[GetCollectionsCollectionIDResponsesResponseIDResponseData], meta: Any, model_id: Optional[str]) -> None:
        self.data = data
        self.meta = meta
        self.model_id = model_id

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponsesResponseIDResponse':
        assert isinstance(obj, dict)
        data = from_union([GetCollectionsCollectionIDResponsesResponseIDResponseData.from_dict, from_none], obj.get("data"))
        meta = obj.get("meta")
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        return GetCollectionsCollectionIDResponsesResponseIDResponse(data, meta, model_id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: to_class(GetCollectionsCollectionIDResponsesResponseIDResponseData, x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = self.meta
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        return result


class GetCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The response's ID."""
    model_id: Optional[str]
    """The user ID of the response's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return GetCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class GetCollectionsCollectionIDResponsesResponseIDResponse401Error:
    """Information about the error."""
    details: Optional[GetCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[GetCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponsesResponseIDResponse401Error':
        assert isinstance(obj, dict)
        details = from_union([GetCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetCollectionsCollectionIDResponsesResponseIDResponse401Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(GetCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetCollectionsCollectionIDResponsesResponseIDResponse401:
    error: Optional[GetCollectionsCollectionIDResponsesResponseIDResponse401Error]

    def __init__(self, error: Optional[GetCollectionsCollectionIDResponsesResponseIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponsesResponseIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetCollectionsCollectionIDResponsesResponseIDResponse401Error.from_dict, from_none], obj.get("error"))
        return GetCollectionsCollectionIDResponsesResponseIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetCollectionsCollectionIDResponsesResponseIDResponse401Error, x), from_none], self.error)
        return result


class GetCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The response's ID."""
    model_id: Optional[str]
    """The user ID of the response's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return GetCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class GetCollectionsCollectionIDResponsesResponseIDResponse404Error:
    """Information about the error."""
    details: Optional[GetCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[GetCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponsesResponseIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([GetCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetCollectionsCollectionIDResponsesResponseIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(GetCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetCollectionsCollectionIDResponsesResponseIDResponse404:
    error: Optional[GetCollectionsCollectionIDResponsesResponseIDResponse404Error]

    def __init__(self, error: Optional[GetCollectionsCollectionIDResponsesResponseIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponsesResponseIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([GetCollectionsCollectionIDResponsesResponseIDResponse404Error.from_dict, from_none], obj.get("error"))
        return GetCollectionsCollectionIDResponsesResponseIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetCollectionsCollectionIDResponsesResponseIDResponse404Error, x), from_none], self.error)
        return result


class GetCollectionsCollectionIDResponsesResponseIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDResponsesResponseIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetCollectionsCollectionIDResponsesResponseIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetCollectionsCollectionIDTagsResponseTagsItem:
    """Information about the tag."""
    """The tag's ID within a team or individual (non-team) user scope."""
    slug: Optional[str]

    def __init__(self, slug: Optional[str]) -> None:
        self.slug = slug

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDTagsResponseTagsItem':
        assert isinstance(obj, dict)
        slug = from_union([from_str, from_none], obj.get("slug"))
        return GetCollectionsCollectionIDTagsResponseTagsItem(slug)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.slug is not None:
            result["slug"] = from_union([from_str, from_none], self.slug)
        return result


class GetCollectionsCollectionIDTagsResponse:
    """A list of associated tags."""
    tags: Optional[List[GetCollectionsCollectionIDTagsResponseTagsItem]]

    def __init__(self, tags: Optional[List[GetCollectionsCollectionIDTagsResponseTagsItem]]) -> None:
        self.tags = tags

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDTagsResponse':
        assert isinstance(obj, dict)
        tags = from_union([lambda x: from_list(GetCollectionsCollectionIDTagsResponseTagsItem.from_dict, x), from_none], obj.get("tags"))
        return GetCollectionsCollectionIDTagsResponse(tags)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.tags is not None:
            result["tags"] = from_union([lambda x: from_list(lambda x: to_class(GetCollectionsCollectionIDTagsResponseTagsItem, x), x), from_none], self.tags)
        return result


class GetCollectionsCollectionIDTagsResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDTagsResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetCollectionsCollectionIDTagsResponse401(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetCollectionsCollectionIDTagsResponse403:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDTagsResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetCollectionsCollectionIDTagsResponse403(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetCollectionsCollectionIDTagsResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The URI reference that identifies the specific occurrence of the problem."""
    instance: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDTagsResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetCollectionsCollectionIDTagsResponse500(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetCollectionsCollectionIDTransformationsResponse:
    """The collection's transformed output, in a stringified OpenAPI format."""
    output: Optional[str]

    def __init__(self, output: Optional[str]) -> None:
        self.output = output

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDTransformationsResponse':
        assert isinstance(obj, dict)
        output = from_union([from_str, from_none], obj.get("output"))
        return GetCollectionsCollectionIDTransformationsResponse(output)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.output is not None:
            result["output"] = from_union([from_str, from_none], self.output)
        return result


class GetCollectionsCollectionIDTransformationsResponse401:
    """Details about the error message."""
    detail: Optional[str]
    """The instance in which the error occurred."""
    instance: Optional[str]
    """The error's status code."""
    status: Optional[int]
    """The title of the error message."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDTransformationsResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetCollectionsCollectionIDTransformationsResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetCollectionsCollectionIDTransformationsResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The instance in which the error occurred."""
    instance: Optional[str]
    """The error's status code."""
    status: Optional[int]
    """The title of the error message."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDTransformationsResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetCollectionsCollectionIDTransformationsResponse404(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetCollectionsCollectionIDTransformationsResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The instance in which the error occurred."""
    instance: Optional[str]
    """The error's status code."""
    status: Optional[int]
    """The title of the error message."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsCollectionIDTransformationsResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetCollectionsCollectionIDTransformationsResponse500(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetCollectionsResponseCollectionsItemFork:
    """If the collection is
    [forked](https://learning.postman.com/docs/collaborating-in-postman/version-control/#forking-postman-entities),
    the fork's information.
    """
    """The fork's creation date and time."""
    created_at: Optional[str]
    """The unique ID of the fork's source collection."""
    get_collections_response_collections_item_fork_from: Optional[str]
    """The fork's label."""
    label: Optional[str]

    def __init__(self, created_at: Optional[str], get_collections_response_collections_item_fork_from: Optional[str], label: Optional[str]) -> None:
        self.created_at = created_at
        self.get_collections_response_collections_item_fork_from = get_collections_response_collections_item_fork_from
        self.label = label

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsResponseCollectionsItemFork':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        get_collections_response_collections_item_fork_from = from_union([from_str, from_none], obj.get("from"))
        label = from_union([from_str, from_none], obj.get("label"))
        return GetCollectionsResponseCollectionsItemFork(created_at, get_collections_response_collections_item_fork_from, label)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.get_collections_response_collections_item_fork_from is not None:
            result["from"] = from_union([from_str, from_none], self.get_collections_response_collections_item_fork_from)
        if self.label is not None:
            result["label"] = from_union([from_str, from_none], self.label)
        return result


class GetCollectionsResponseCollectionsItem:
    """Information about the collection."""
    """The collection's creation date and time."""
    created_at: Optional[str]
    """If the collection is
    [forked](https://learning.postman.com/docs/collaborating-in-postman/version-control/#forking-postman-entities),
    the fork's information.
    """
    fork: Optional[GetCollectionsResponseCollectionsItemFork]
    """The collection's ID."""
    id: Optional[str]
    """If true, the collection is publicly available."""
    is_public: Optional[bool]
    """The collection's name."""
    name: Optional[str]
    """The owner of the collection."""
    owner: Optional[str]
    """The collection's unique ID."""
    uid: Optional[str]
    """The date and time at which the collection was last updated."""
    updated_at: Optional[str]

    def __init__(self, created_at: Optional[str], fork: Optional[GetCollectionsResponseCollectionsItemFork], id: Optional[str], is_public: Optional[bool], name: Optional[str], owner: Optional[str], uid: Optional[str], updated_at: Optional[str]) -> None:
        self.created_at = created_at
        self.fork = fork
        self.id = id
        self.is_public = is_public
        self.name = name
        self.owner = owner
        self.uid = uid
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsResponseCollectionsItem':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        fork = from_union([GetCollectionsResponseCollectionsItemFork.from_dict, from_none], obj.get("fork"))
        id = from_union([from_str, from_none], obj.get("id"))
        is_public = from_union([from_bool, from_none], obj.get("isPublic"))
        name = from_union([from_str, from_none], obj.get("name"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return GetCollectionsResponseCollectionsItem(created_at, fork, id, is_public, name, owner, uid, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.fork is not None:
            result["fork"] = from_union([lambda x: to_class(GetCollectionsResponseCollectionsItemFork, x), from_none], self.fork)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.is_public is not None:
            result["isPublic"] = from_union([from_bool, from_none], self.is_public)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class GetCollectionsResponse:
    collections: Optional[List[GetCollectionsResponseCollectionsItem]]

    def __init__(self, collections: Optional[List[GetCollectionsResponseCollectionsItem]]) -> None:
        self.collections = collections

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsResponse':
        assert isinstance(obj, dict)
        collections = from_union([lambda x: from_list(GetCollectionsResponseCollectionsItem.from_dict, x), from_none], obj.get("collections"))
        return GetCollectionsResponse(collections)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collections is not None:
            result["collections"] = from_union([lambda x: from_list(lambda x: to_class(GetCollectionsResponseCollectionsItem, x), x), from_none], self.collections)
        return result


class GetCollectionsResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetCollectionsResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetCollectionsResponse401:
    error: Optional[GetCollectionsResponse401Error]

    def __init__(self, error: Optional[GetCollectionsResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetCollectionsResponse401Error.from_dict, from_none], obj.get("error"))
        return GetCollectionsResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetCollectionsResponse401Error, x), from_none], self.error)
        return result


class GetCollectionsResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetCollectionsResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetCollectionsResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetCollectionsResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetCollectionsResponse500:
    error: Optional[GetCollectionsResponse500Error]

    def __init__(self, error: Optional[GetCollectionsResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetCollectionsResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetCollectionsResponse500Error.from_dict, from_none], obj.get("error"))
        return GetCollectionsResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetCollectionsResponse500Error, x), from_none], self.error)
        return result


class DatumResourceType(Enum):
    """The type of resource in which the secret was detected."""
    API = "api"
    COLLECTION = "collection"
    ENVIRONMENT = "environment"
    EXAMPLE = "example"
    FOLDER = "folder"
    GLOBALS = "globals"
    REQUEST = "request"


class GetDetectedSecretsSecretIDLocationsResponseDataItem:
    """Information about the secret finding locations."""
    """The date and time at which the secret was detected."""
    detected_at: Optional[str]
    """If true, the resource in which the secret was found was deleted."""
    is_resource_deleted: Optional[bool]
    """The ID of the user who leaked the secret."""
    leaked_by: Optional[float]
    """The location where the secret was found."""
    location: Optional[str]
    """The number of times the secret occurs in the location."""
    occurrences: Optional[float]
    """The parent resource's unique ID. If the resource is a request, folder, or example, this
    value is a collection ID. If the resource is a collection, globals, or environment, this
    is the resource's ID.
    """
    parent_resource_id: Optional[str]
    """The unique ID of the resource where the secret was detected."""
    resource_id: Optional[str]
    """The type of resource in which the secret was detected."""
    resource_type: Optional[DatumResourceType]
    """The URL to the resource that contains the secret."""
    url: Optional[str]

    def __init__(self, detected_at: Optional[str], is_resource_deleted: Optional[bool], leaked_by: Optional[float], location: Optional[str], occurrences: Optional[float], parent_resource_id: Optional[str], resource_id: Optional[str], resource_type: Optional[DatumResourceType], url: Optional[str]) -> None:
        self.detected_at = detected_at
        self.is_resource_deleted = is_resource_deleted
        self.leaked_by = leaked_by
        self.location = location
        self.occurrences = occurrences
        self.parent_resource_id = parent_resource_id
        self.resource_id = resource_id
        self.resource_type = resource_type
        self.url = url

    @staticmethod
    def from_dict(obj: Any) -> 'GetDetectedSecretsSecretIDLocationsResponseDataItem':
        assert isinstance(obj, dict)
        detected_at = from_union([from_str, from_none], obj.get("detectedAt"))
        is_resource_deleted = from_union([from_bool, from_none], obj.get("isResourceDeleted"))
        leaked_by = from_union([from_float, from_none], obj.get("leakedBy"))
        location = from_union([from_str, from_none], obj.get("location"))
        occurrences = from_union([from_float, from_none], obj.get("occurrences"))
        parent_resource_id = from_union([from_str, from_none], obj.get("parentResourceId"))
        resource_id = from_union([from_str, from_none], obj.get("resourceId"))
        resource_type = from_union([DatumResourceType, from_none], obj.get("resourceType"))
        url = from_union([from_str, from_none], obj.get("url"))
        return GetDetectedSecretsSecretIDLocationsResponseDataItem(detected_at, is_resource_deleted, leaked_by, location, occurrences, parent_resource_id, resource_id, resource_type, url)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detected_at is not None:
            result["detectedAt"] = from_union([from_str, from_none], self.detected_at)
        if self.is_resource_deleted is not None:
            result["isResourceDeleted"] = from_union([from_bool, from_none], self.is_resource_deleted)
        if self.leaked_by is not None:
            result["leakedBy"] = from_union([to_float, from_none], self.leaked_by)
        if self.location is not None:
            result["location"] = from_union([from_str, from_none], self.location)
        if self.occurrences is not None:
            result["occurrences"] = from_union([to_float, from_none], self.occurrences)
        if self.parent_resource_id is not None:
            result["parentResourceId"] = from_union([from_str, from_none], self.parent_resource_id)
        if self.resource_id is not None:
            result["resourceId"] = from_union([from_str, from_none], self.resource_id)
        if self.resource_type is not None:
            result["resourceType"] = from_union([lambda x: to_enum(DatumResourceType, x), from_none], self.resource_type)
        if self.url is not None:
            result["url"] = from_union([from_str, from_none], self.url)
        return result


class ResolutionEnum(Enum):
    """The secret's current resolution status:
    - `ACTIVE`  The secret is active.
    - `FALSE_POSITIVE`  The discovered secret is not an actual secret.
    - `REVOKED`  The secret is valid, but the user rotated their key to resolve the issue.
    - `ACCEPTED_RISK`  The Secret Scanner found the secret, but user accepts the risk of
    publishing it.
    
    
    The secret's current status:
    - `ACTIVE`  The secret is active.
    - `FALSE_POSITIVE`  The discovered secret is not an actual secret.
    - `REVOKED`  The secret is valid, but the user rotated their key to resolve the issue.
    - `ACCEPTED_RISK`  The Secret Scanner found the secret, but user accepts the risk of
    publishing it.
    
    
    The secret's updated resolution status:
    - `ACTIVE`  The secret is active.
    - `FALSE_POSITIVE`  The discovered secret is not an actual secret.
    - `REVOKED`  The secret is valid, but the user rotated their key to resolve the issue.
    - `ACCEPTED_RISK`  The Secret Scanner found the secret, but user accepts the risk of
    publishing it.
    """
    ACCEPTED_RISK = "ACCEPTED_RISK"
    ACTIVE = "ACTIVE"
    FALSE_POSITIVE = "FALSE_POSITIVE"
    REVOKED = "REVOKED"


class GetDetectedSecretsSecretIDLocationsResponseMetaActivityFeedItem:
    """The date and time at which the resolution status was last updated."""
    resolved_at: Optional[str]
    """The ID of the user that updated the secret's resolution status."""
    resolved_by: Optional[float]
    """The secret's current resolution status:
    - `ACTIVE`  The secret is active.
    - `FALSE_POSITIVE`  The discovered secret is not an actual secret.
    - `REVOKED`  The secret is valid, but the user rotated their key to resolve the issue.
    - `ACCEPTED_RISK`  The Secret Scanner found the secret, but user accepts the risk of
    publishing it.
    """
    status: Optional[ResolutionEnum]

    def __init__(self, resolved_at: Optional[str], resolved_by: Optional[float], status: Optional[ResolutionEnum]) -> None:
        self.resolved_at = resolved_at
        self.resolved_by = resolved_by
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetDetectedSecretsSecretIDLocationsResponseMetaActivityFeedItem':
        assert isinstance(obj, dict)
        resolved_at = from_union([from_str, from_none], obj.get("resolvedAt"))
        resolved_by = from_union([from_float, from_none], obj.get("resolvedBy"))
        status = from_union([ResolutionEnum, from_none], obj.get("status"))
        return GetDetectedSecretsSecretIDLocationsResponseMetaActivityFeedItem(resolved_at, resolved_by, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.resolved_at is not None:
            result["resolvedAt"] = from_union([from_str, from_none], self.resolved_at)
        if self.resolved_by is not None:
            result["resolvedBy"] = from_union([to_float, from_none], self.resolved_by)
        if self.status is not None:
            result["status"] = from_union([lambda x: to_enum(ResolutionEnum, x), from_none], self.status)
        return result


class GetDetectedSecretsSecretIDLocationsResponseMeta:
    """The history of the secret's resolution status changes."""
    activity_feed: Optional[List[GetDetectedSecretsSecretIDLocationsResponseMetaActivityFeedItem]]
    """The pointer to the first record of the set of paginated results."""
    cursor: Optional[str]
    """The maximum number of rows to return in the response."""
    limit: Optional[float]
    next_cursor: Any
    """The secret's obfuscated value."""
    obfuscated_secret: Optional[str]
    """The secret's SHA-256 hash."""
    secret_hash: Optional[str]
    """The type of thesecret."""
    secret_type: Optional[str]
    """The total number of discovered secret locations."""
    total: Optional[float]

    def __init__(self, activity_feed: Optional[List[GetDetectedSecretsSecretIDLocationsResponseMetaActivityFeedItem]], cursor: Optional[str], limit: Optional[float], next_cursor: Any, obfuscated_secret: Optional[str], secret_hash: Optional[str], secret_type: Optional[str], total: Optional[float]) -> None:
        self.activity_feed = activity_feed
        self.cursor = cursor
        self.limit = limit
        self.next_cursor = next_cursor
        self.obfuscated_secret = obfuscated_secret
        self.secret_hash = secret_hash
        self.secret_type = secret_type
        self.total = total

    @staticmethod
    def from_dict(obj: Any) -> 'GetDetectedSecretsSecretIDLocationsResponseMeta':
        assert isinstance(obj, dict)
        activity_feed = from_union([lambda x: from_list(GetDetectedSecretsSecretIDLocationsResponseMetaActivityFeedItem.from_dict, x), from_none], obj.get("activityFeed"))
        cursor = from_union([from_str, from_none], obj.get("cursor"))
        limit = from_union([from_float, from_none], obj.get("limit"))
        next_cursor = obj.get("nextCursor")
        obfuscated_secret = from_union([from_str, from_none], obj.get("obfuscatedSecret"))
        secret_hash = from_union([from_str, from_none], obj.get("secretHash"))
        secret_type = from_union([from_str, from_none], obj.get("secretType"))
        total = from_union([from_float, from_none], obj.get("total"))
        return GetDetectedSecretsSecretIDLocationsResponseMeta(activity_feed, cursor, limit, next_cursor, obfuscated_secret, secret_hash, secret_type, total)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.activity_feed is not None:
            result["activityFeed"] = from_union([lambda x: from_list(lambda x: to_class(GetDetectedSecretsSecretIDLocationsResponseMetaActivityFeedItem, x), x), from_none], self.activity_feed)
        if self.cursor is not None:
            result["cursor"] = from_union([from_str, from_none], self.cursor)
        if self.limit is not None:
            result["limit"] = from_union([to_float, from_none], self.limit)
        if self.next_cursor is not None:
            result["nextCursor"] = self.next_cursor
        if self.obfuscated_secret is not None:
            result["obfuscatedSecret"] = from_union([from_str, from_none], self.obfuscated_secret)
        if self.secret_hash is not None:
            result["secretHash"] = from_union([from_str, from_none], self.secret_hash)
        if self.secret_type is not None:
            result["secretType"] = from_union([from_str, from_none], self.secret_type)
        if self.total is not None:
            result["total"] = from_union([to_float, from_none], self.total)
        return result


class GetDetectedSecretsSecretIDLocationsResponse:
    data: Optional[List[GetDetectedSecretsSecretIDLocationsResponseDataItem]]
    meta: Optional[GetDetectedSecretsSecretIDLocationsResponseMeta]

    def __init__(self, data: Optional[List[GetDetectedSecretsSecretIDLocationsResponseDataItem]], meta: Optional[GetDetectedSecretsSecretIDLocationsResponseMeta]) -> None:
        self.data = data
        self.meta = meta

    @staticmethod
    def from_dict(obj: Any) -> 'GetDetectedSecretsSecretIDLocationsResponse':
        assert isinstance(obj, dict)
        data = from_union([lambda x: from_list(GetDetectedSecretsSecretIDLocationsResponseDataItem.from_dict, x), from_none], obj.get("data"))
        meta = from_union([GetDetectedSecretsSecretIDLocationsResponseMeta.from_dict, from_none], obj.get("meta"))
        return GetDetectedSecretsSecretIDLocationsResponse(data, meta)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: from_list(lambda x: to_class(GetDetectedSecretsSecretIDLocationsResponseDataItem, x), x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(GetDetectedSecretsSecretIDLocationsResponseMeta, x), from_none], self.meta)
        return result


class GetDetectedSecretsSecretIDLocationsResponse400:
    """The instance identifying the specific occurrence of the problem."""
    instance: Optional[str]
    """The HTTP status code generated by the origin server."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetDetectedSecretsSecretIDLocationsResponse400':
        assert isinstance(obj, dict)
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetDetectedSecretsSecretIDLocationsResponse400(instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetDetectedSecretsSecretIDLocationsResponse401:
    """The instance identifying the specific occurrence of the problem."""
    instance: Optional[str]
    """The HTTP status code generated by the origin server."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetDetectedSecretsSecretIDLocationsResponse401':
        assert isinstance(obj, dict)
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetDetectedSecretsSecretIDLocationsResponse401(instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetDetectedSecretsSecretIDLocationsResponse403:
    """The instance identifying the specific occurrence of the problem."""
    instance: Optional[str]
    """The HTTP status code generated by the origin server."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetDetectedSecretsSecretIDLocationsResponse403':
        assert isinstance(obj, dict)
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetDetectedSecretsSecretIDLocationsResponse403(instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetDetectedSecretsSecretIDLocationsResponse500:
    """The instance identifying the specific occurrence of the problem."""
    instance: Optional[str]
    """The HTTP status code generated by the origin server."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetDetectedSecretsSecretIDLocationsResponse500':
        assert isinstance(obj, dict)
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetDetectedSecretsSecretIDLocationsResponse500(instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PurpleType(Enum):
    """The variable type."""
    ANY = "any"
    DEFAULT = "default"
    SECRET = "secret"


class GetEnvironmentsEnvironmentIDResponseEnvironmentValuesItemItem:
    """If true, the variable is enabled."""
    enabled: Optional[bool]
    """The variable's name."""
    key: Optional[str]
    """The variable type."""
    type: Optional[PurpleType]
    """The variable's value."""
    value: Optional[str]

    def __init__(self, enabled: Optional[bool], key: Optional[str], type: Optional[PurpleType], value: Optional[str]) -> None:
        self.enabled = enabled
        self.key = key
        self.type = type
        self.value = value

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsEnvironmentIDResponseEnvironmentValuesItemItem':
        assert isinstance(obj, dict)
        enabled = from_union([from_bool, from_none], obj.get("enabled"))
        key = from_union([from_str, from_none], obj.get("key"))
        type = from_union([PurpleType, from_none], obj.get("type"))
        value = from_union([from_str, from_none], obj.get("value"))
        return GetEnvironmentsEnvironmentIDResponseEnvironmentValuesItemItem(enabled, key, type, value)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.enabled is not None:
            result["enabled"] = from_union([from_bool, from_none], self.enabled)
        if self.key is not None:
            result["key"] = from_union([from_str, from_none], self.key)
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(PurpleType, x), from_none], self.type)
        if self.value is not None:
            result["value"] = from_union([from_str, from_none], self.value)
        return result


class GetEnvironmentsEnvironmentIDResponseEnvironment:
    """The date and time at which the environment was created."""
    created_at: Optional[str]
    """The environment's ID."""
    id: Optional[str]
    """If true, the environment is public."""
    is_public: Optional[bool]
    """The environment's name."""
    name: Optional[str]
    """The ID of environment's owner."""
    owner: Optional[str]
    """The date and time at which the environment was last updated."""
    updated_at: Optional[str]
    """Information about the environment's variables."""
    values: Optional[List[List[GetEnvironmentsEnvironmentIDResponseEnvironmentValuesItemItem]]]

    def __init__(self, created_at: Optional[str], id: Optional[str], is_public: Optional[bool], name: Optional[str], owner: Optional[str], updated_at: Optional[str], values: Optional[List[List[GetEnvironmentsEnvironmentIDResponseEnvironmentValuesItemItem]]]) -> None:
        self.created_at = created_at
        self.id = id
        self.is_public = is_public
        self.name = name
        self.owner = owner
        self.updated_at = updated_at
        self.values = values

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsEnvironmentIDResponseEnvironment':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        id = from_union([from_str, from_none], obj.get("id"))
        is_public = from_union([from_bool, from_none], obj.get("isPublic"))
        name = from_union([from_str, from_none], obj.get("name"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        values = from_union([lambda x: from_list(lambda x: from_list(GetEnvironmentsEnvironmentIDResponseEnvironmentValuesItemItem.from_dict, x), x), from_none], obj.get("values"))
        return GetEnvironmentsEnvironmentIDResponseEnvironment(created_at, id, is_public, name, owner, updated_at, values)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.is_public is not None:
            result["isPublic"] = from_union([from_bool, from_none], self.is_public)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.values is not None:
            result["values"] = from_union([lambda x: from_list(lambda x: from_list(lambda x: to_class(GetEnvironmentsEnvironmentIDResponseEnvironmentValuesItemItem, x), x), x), from_none], self.values)
        return result


class GetEnvironmentsEnvironmentIDResponse:
    environment: Optional[GetEnvironmentsEnvironmentIDResponseEnvironment]

    def __init__(self, environment: Optional[GetEnvironmentsEnvironmentIDResponseEnvironment]) -> None:
        self.environment = environment

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsEnvironmentIDResponse':
        assert isinstance(obj, dict)
        environment = from_union([GetEnvironmentsEnvironmentIDResponseEnvironment.from_dict, from_none], obj.get("environment"))
        return GetEnvironmentsEnvironmentIDResponse(environment)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.environment is not None:
            result["environment"] = from_union([lambda x: to_class(GetEnvironmentsEnvironmentIDResponseEnvironment, x), from_none], self.environment)
        return result


class GetEnvironmentsEnvironmentIDResponse400Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsEnvironmentIDResponse400Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetEnvironmentsEnvironmentIDResponse400Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetEnvironmentsEnvironmentIDResponse400:
    error: Optional[GetEnvironmentsEnvironmentIDResponse400Error]

    def __init__(self, error: Optional[GetEnvironmentsEnvironmentIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsEnvironmentIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([GetEnvironmentsEnvironmentIDResponse400Error.from_dict, from_none], obj.get("error"))
        return GetEnvironmentsEnvironmentIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetEnvironmentsEnvironmentIDResponse400Error, x), from_none], self.error)
        return result


class GetEnvironmentsEnvironmentIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsEnvironmentIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetEnvironmentsEnvironmentIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetEnvironmentsEnvironmentIDResponse401:
    error: Optional[GetEnvironmentsEnvironmentIDResponse401Error]

    def __init__(self, error: Optional[GetEnvironmentsEnvironmentIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsEnvironmentIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetEnvironmentsEnvironmentIDResponse401Error.from_dict, from_none], obj.get("error"))
        return GetEnvironmentsEnvironmentIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetEnvironmentsEnvironmentIDResponse401Error, x), from_none], self.error)
        return result


class GetEnvironmentsEnvironmentIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsEnvironmentIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetEnvironmentsEnvironmentIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetEnvironmentsEnvironmentIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsEnvironmentIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetEnvironmentsEnvironmentIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetEnvironmentsEnvironmentIDResponse500:
    error: Optional[GetEnvironmentsEnvironmentIDResponse500Error]

    def __init__(self, error: Optional[GetEnvironmentsEnvironmentIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsEnvironmentIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetEnvironmentsEnvironmentIDResponse500Error.from_dict, from_none], obj.get("error"))
        return GetEnvironmentsEnvironmentIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetEnvironmentsEnvironmentIDResponse500Error, x), from_none], self.error)
        return result


class GetEnvironmentsResponseEnvironmentsItem:
    """The date and time at which the environment was created."""
    created_at: Optional[str]
    """The environment's ID."""
    id: Optional[str]
    """If true, the environment is public."""
    is_public: Optional[bool]
    """The environment's name."""
    name: Optional[str]
    """The environment owner's ID."""
    owner: Optional[str]
    """The environment's unique ID."""
    uid: Optional[str]
    """The date and time at which the environment was last updated."""
    updated_at: Optional[str]

    def __init__(self, created_at: Optional[str], id: Optional[str], is_public: Optional[bool], name: Optional[str], owner: Optional[str], uid: Optional[str], updated_at: Optional[str]) -> None:
        self.created_at = created_at
        self.id = id
        self.is_public = is_public
        self.name = name
        self.owner = owner
        self.uid = uid
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsResponseEnvironmentsItem':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        id = from_union([from_str, from_none], obj.get("id"))
        is_public = from_union([from_bool, from_none], obj.get("isPublic"))
        name = from_union([from_str, from_none], obj.get("name"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return GetEnvironmentsResponseEnvironmentsItem(created_at, id, is_public, name, owner, uid, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.is_public is not None:
            result["isPublic"] = from_union([from_bool, from_none], self.is_public)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class GetEnvironmentsResponse:
    environments: Optional[List[GetEnvironmentsResponseEnvironmentsItem]]

    def __init__(self, environments: Optional[List[GetEnvironmentsResponseEnvironmentsItem]]) -> None:
        self.environments = environments

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsResponse':
        assert isinstance(obj, dict)
        environments = from_union([lambda x: from_list(GetEnvironmentsResponseEnvironmentsItem.from_dict, x), from_none], obj.get("environments"))
        return GetEnvironmentsResponse(environments)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.environments is not None:
            result["environments"] = from_union([lambda x: from_list(lambda x: to_class(GetEnvironmentsResponseEnvironmentsItem, x), x), from_none], self.environments)
        return result


class GetEnvironmentsResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetEnvironmentsResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetEnvironmentsResponse401:
    error: Optional[GetEnvironmentsResponse401Error]

    def __init__(self, error: Optional[GetEnvironmentsResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetEnvironmentsResponse401Error.from_dict, from_none], obj.get("error"))
        return GetEnvironmentsResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetEnvironmentsResponse401Error, x), from_none], self.error)
        return result


class GetEnvironmentsResponse404Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsResponse404Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetEnvironmentsResponse404Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetEnvironmentsResponse404:
    error: Optional[GetEnvironmentsResponse404Error]

    def __init__(self, error: Optional[GetEnvironmentsResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsResponse404':
        assert isinstance(obj, dict)
        error = from_union([GetEnvironmentsResponse404Error.from_dict, from_none], obj.get("error"))
        return GetEnvironmentsResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetEnvironmentsResponse404Error, x), from_none], self.error)
        return result


class GetEnvironmentsResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetEnvironmentsResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetEnvironmentsResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetEnvironmentsResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetEnvironmentsResponse500:
    error: Optional[GetEnvironmentsResponse500Error]

    def __init__(self, error: Optional[GetEnvironmentsResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetEnvironmentsResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetEnvironmentsResponse500Error.from_dict, from_none], obj.get("error"))
        return GetEnvironmentsResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetEnvironmentsResponse500Error, x), from_none], self.error)
        return result


class GetMeResponseOperationsItem:
    """The operation's limit value."""
    limit: Optional[float]
    """The operation's name."""
    name: Optional[str]
    """The operation's overage value."""
    overage: Optional[float]
    """The operation's current usage value."""
    usage: Optional[float]

    def __init__(self, limit: Optional[float], name: Optional[str], overage: Optional[float], usage: Optional[float]) -> None:
        self.limit = limit
        self.name = name
        self.overage = overage
        self.usage = usage

    @staticmethod
    def from_dict(obj: Any) -> 'GetMeResponseOperationsItem':
        assert isinstance(obj, dict)
        limit = from_union([from_float, from_none], obj.get("limit"))
        name = from_union([from_str, from_none], obj.get("name"))
        overage = from_union([from_float, from_none], obj.get("overage"))
        usage = from_union([from_float, from_none], obj.get("usage"))
        return GetMeResponseOperationsItem(limit, name, overage, usage)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.limit is not None:
            result["limit"] = from_union([to_float, from_none], self.limit)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.overage is not None:
            result["overage"] = from_union([to_float, from_none], self.overage)
        if self.usage is not None:
            result["usage"] = from_union([to_float, from_none], self.usage)
        return result


class GetMeResponseUser:
    """Information about the authenticated user."""
    """The user's avatar image URL."""
    avatar: Optional[str]
    """The user's email address."""
    email: Optional[str]
    """The user's full name."""
    full_name: Optional[str]
    """The user's Postman ID."""
    id: Optional[float]
    """If true, the user's information is publicly available."""
    is_public: Optional[bool]
    """The team ID the user is assigned to. This returns a `0` value if the user is not assigned
    to a team.
    """
    team_id: Optional[int]
    """The user's username."""
    username: Optional[str]

    def __init__(self, avatar: Optional[str], email: Optional[str], full_name: Optional[str], id: Optional[float], is_public: Optional[bool], team_id: Optional[int], username: Optional[str]) -> None:
        self.avatar = avatar
        self.email = email
        self.full_name = full_name
        self.id = id
        self.is_public = is_public
        self.team_id = team_id
        self.username = username

    @staticmethod
    def from_dict(obj: Any) -> 'GetMeResponseUser':
        assert isinstance(obj, dict)
        avatar = from_union([from_str, from_none], obj.get("avatar"))
        email = from_union([from_str, from_none], obj.get("email"))
        full_name = from_union([from_str, from_none], obj.get("fullName"))
        id = from_union([from_float, from_none], obj.get("id"))
        is_public = from_union([from_bool, from_none], obj.get("isPublic"))
        team_id = from_union([from_int, from_none], obj.get("teamId"))
        username = from_union([from_str, from_none], obj.get("username"))
        return GetMeResponseUser(avatar, email, full_name, id, is_public, team_id, username)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.avatar is not None:
            result["avatar"] = from_union([from_str, from_none], self.avatar)
        if self.email is not None:
            result["email"] = from_union([from_str, from_none], self.email)
        if self.full_name is not None:
            result["fullName"] = from_union([from_str, from_none], self.full_name)
        if self.id is not None:
            result["id"] = from_union([to_float, from_none], self.id)
        if self.is_public is not None:
            result["isPublic"] = from_union([from_bool, from_none], self.is_public)
        if self.team_id is not None:
            result["teamId"] = from_union([from_int, from_none], self.team_id)
        if self.username is not None:
            result["username"] = from_union([from_str, from_none], self.username)
        return result


class GetMeResponse:
    """Information about operations and their usage limits. The API does not return this object
    for users with the [Guest
    role](https://learning.postman.com/docs/collaborating-in-postman/roles-and-permissions/#team-roles).
    """
    operations: Optional[List[GetMeResponseOperationsItem]]
    """Information about the authenticated user."""
    user: Optional[GetMeResponseUser]

    def __init__(self, operations: Optional[List[GetMeResponseOperationsItem]], user: Optional[GetMeResponseUser]) -> None:
        self.operations = operations
        self.user = user

    @staticmethod
    def from_dict(obj: Any) -> 'GetMeResponse':
        assert isinstance(obj, dict)
        operations = from_union([lambda x: from_list(GetMeResponseOperationsItem.from_dict, x), from_none], obj.get("operations"))
        user = from_union([GetMeResponseUser.from_dict, from_none], obj.get("user"))
        return GetMeResponse(operations, user)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.operations is not None:
            result["operations"] = from_union([lambda x: from_list(lambda x: to_class(GetMeResponseOperationsItem, x), x), from_none], self.operations)
        if self.user is not None:
            result["user"] = from_union([lambda x: to_class(GetMeResponseUser, x), from_none], self.user)
        return result


class GetMeResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMeResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMeResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMeResponse401:
    error: Optional[GetMeResponse401Error]

    def __init__(self, error: Optional[GetMeResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMeResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetMeResponse401Error.from_dict, from_none], obj.get("error"))
        return GetMeResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMeResponse401Error, x), from_none], self.error)
        return result


class GetMeResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetMeResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetMeResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetMeResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMeResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMeResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMeResponse500:
    error: Optional[GetMeResponse500Error]

    def __init__(self, error: Optional[GetMeResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMeResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetMeResponse500Error.from_dict, from_none], obj.get("error"))
        return GetMeResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMeResponse500Error, x), from_none], self.error)
        return result


class GetMocksMockIDCallLogsResponseCallLogsItemRequestBody:
    """The request's body information."""
    """The request body's contents."""
    data: Optional[str]
    """The request body's media type (mode)."""
    mode: Optional[str]

    def __init__(self, data: Optional[str], mode: Optional[str]) -> None:
        self.data = data
        self.mode = mode

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponseCallLogsItemRequestBody':
        assert isinstance(obj, dict)
        data = from_union([from_str, from_none], obj.get("data"))
        mode = from_union([from_str, from_none], obj.get("mode"))
        return GetMocksMockIDCallLogsResponseCallLogsItemRequestBody(data, mode)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([from_str, from_none], self.data)
        if self.mode is not None:
            result["mode"] = from_union([from_str, from_none], self.mode)
        return result


class GetMocksMockIDCallLogsResponseCallLogsItemRequestHeaders:
    """The request's headers."""
    """The request header's name."""
    key: Optional[str]
    """The request header's value."""
    value: Optional[str]

    def __init__(self, key: Optional[str], value: Optional[str]) -> None:
        self.key = key
        self.value = value

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponseCallLogsItemRequestHeaders':
        assert isinstance(obj, dict)
        key = from_union([from_str, from_none], obj.get("key"))
        value = from_union([from_str, from_none], obj.get("value"))
        return GetMocksMockIDCallLogsResponseCallLogsItemRequestHeaders(key, value)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.key is not None:
            result["key"] = from_union([from_str, from_none], self.key)
        if self.value is not None:
            result["value"] = from_union([from_str, from_none], self.value)
        return result


class GetMocksMockIDCallLogsResponseCallLogsItemRequest:
    """The server response's request information."""
    """The request's body information."""
    body: Optional[GetMocksMockIDCallLogsResponseCallLogsItemRequestBody]
    """The request's headers."""
    headers: Optional[GetMocksMockIDCallLogsResponseCallLogsItemRequestHeaders]
    """The request method."""
    method: Optional[str]
    """The request's path."""
    path: Optional[str]

    def __init__(self, body: Optional[GetMocksMockIDCallLogsResponseCallLogsItemRequestBody], headers: Optional[GetMocksMockIDCallLogsResponseCallLogsItemRequestHeaders], method: Optional[str], path: Optional[str]) -> None:
        self.body = body
        self.headers = headers
        self.method = method
        self.path = path

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponseCallLogsItemRequest':
        assert isinstance(obj, dict)
        body = from_union([GetMocksMockIDCallLogsResponseCallLogsItemRequestBody.from_dict, from_none], obj.get("body"))
        headers = from_union([GetMocksMockIDCallLogsResponseCallLogsItemRequestHeaders.from_dict, from_none], obj.get("headers"))
        method = from_union([from_str, from_none], obj.get("method"))
        path = from_union([from_str, from_none], obj.get("path"))
        return GetMocksMockIDCallLogsResponseCallLogsItemRequest(body, headers, method, path)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.body is not None:
            result["body"] = from_union([lambda x: to_class(GetMocksMockIDCallLogsResponseCallLogsItemRequestBody, x), from_none], self.body)
        if self.headers is not None:
            result["headers"] = from_union([lambda x: to_class(GetMocksMockIDCallLogsResponseCallLogsItemRequestHeaders, x), from_none], self.headers)
        if self.method is not None:
            result["method"] = from_union([from_str, from_none], self.method)
        if self.path is not None:
            result["path"] = from_union([from_str, from_none], self.path)
        return result


class GetMocksMockIDCallLogsResponseCallLogsItemResponseBody:
    """The response's body information."""
    """The response body's contents."""
    data: Optional[str]

    def __init__(self, data: Optional[str]) -> None:
        self.data = data

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponseCallLogsItemResponseBody':
        assert isinstance(obj, dict)
        data = from_union([from_str, from_none], obj.get("data"))
        return GetMocksMockIDCallLogsResponseCallLogsItemResponseBody(data)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([from_str, from_none], self.data)
        return result


class GetMocksMockIDCallLogsResponseCallLogsItemResponseHeadersDescription:
    """The response header's description information."""
    """The response header description's content."""
    content: Optional[str]
    """The response header description's media type."""
    type: Optional[str]

    def __init__(self, content: Optional[str], type: Optional[str]) -> None:
        self.content = content
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponseCallLogsItemResponseHeadersDescription':
        assert isinstance(obj, dict)
        content = from_union([from_str, from_none], obj.get("content"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetMocksMockIDCallLogsResponseCallLogsItemResponseHeadersDescription(content, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.content is not None:
            result["content"] = from_union([from_str, from_none], self.content)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetMocksMockIDCallLogsResponseCallLogsItemResponseHeaders:
    """The response's headers."""
    """The response header's description information."""
    description: Optional[GetMocksMockIDCallLogsResponseCallLogsItemResponseHeadersDescription]
    """The response header's name."""
    key: Optional[str]
    """The response header's value."""
    value: Optional[str]

    def __init__(self, description: Optional[GetMocksMockIDCallLogsResponseCallLogsItemResponseHeadersDescription], key: Optional[str], value: Optional[str]) -> None:
        self.description = description
        self.key = key
        self.value = value

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponseCallLogsItemResponseHeaders':
        assert isinstance(obj, dict)
        description = from_union([GetMocksMockIDCallLogsResponseCallLogsItemResponseHeadersDescription.from_dict, from_none], obj.get("description"))
        key = from_union([from_str, from_none], obj.get("key"))
        value = from_union([from_str, from_none], obj.get("value"))
        return GetMocksMockIDCallLogsResponseCallLogsItemResponseHeaders(description, key, value)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.description is not None:
            result["description"] = from_union([lambda x: to_class(GetMocksMockIDCallLogsResponseCallLogsItemResponseHeadersDescription, x), from_none], self.description)
        if self.key is not None:
            result["key"] = from_union([from_str, from_none], self.key)
        if self.value is not None:
            result["value"] = from_union([from_str, from_none], self.value)
        return result


class GetMocksMockIDCallLogsResponseCallLogsItemResponse:
    """The server response's response information."""
    """The response's body information."""
    body: Optional[GetMocksMockIDCallLogsResponseCallLogsItemResponseBody]
    """The response's headers."""
    headers: Optional[GetMocksMockIDCallLogsResponseCallLogsItemResponseHeaders]
    """The response's status code."""
    status_code: Optional[float]
    """The type of response."""
    type: Optional[str]

    def __init__(self, body: Optional[GetMocksMockIDCallLogsResponseCallLogsItemResponseBody], headers: Optional[GetMocksMockIDCallLogsResponseCallLogsItemResponseHeaders], status_code: Optional[float], type: Optional[str]) -> None:
        self.body = body
        self.headers = headers
        self.status_code = status_code
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponseCallLogsItemResponse':
        assert isinstance(obj, dict)
        body = from_union([GetMocksMockIDCallLogsResponseCallLogsItemResponseBody.from_dict, from_none], obj.get("body"))
        headers = from_union([GetMocksMockIDCallLogsResponseCallLogsItemResponseHeaders.from_dict, from_none], obj.get("headers"))
        status_code = from_union([from_float, from_none], obj.get("statusCode"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetMocksMockIDCallLogsResponseCallLogsItemResponse(body, headers, status_code, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.body is not None:
            result["body"] = from_union([lambda x: to_class(GetMocksMockIDCallLogsResponseCallLogsItemResponseBody, x), from_none], self.body)
        if self.headers is not None:
            result["headers"] = from_union([lambda x: to_class(GetMocksMockIDCallLogsResponseCallLogsItemResponseHeaders, x), from_none], self.headers)
        if self.status_code is not None:
            result["statusCode"] = from_union([to_float, from_none], self.status_code)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetMocksMockIDCallLogsResponseCallLogsItem:
    """Information about the mock server's server responses."""
    """The server response's ID."""
    id: Optional[str]
    """The server response's request information."""
    request: Optional[GetMocksMockIDCallLogsResponseCallLogsItemRequest]
    """The server response's response information."""
    response: Optional[GetMocksMockIDCallLogsResponseCallLogsItemResponse]
    """The server response's name."""
    response_name: Optional[str]
    """The date and time at which the server response was served."""
    served_at: Optional[str]

    def __init__(self, id: Optional[str], request: Optional[GetMocksMockIDCallLogsResponseCallLogsItemRequest], response: Optional[GetMocksMockIDCallLogsResponseCallLogsItemResponse], response_name: Optional[str], served_at: Optional[str]) -> None:
        self.id = id
        self.request = request
        self.response = response
        self.response_name = response_name
        self.served_at = served_at

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponseCallLogsItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        request = from_union([GetMocksMockIDCallLogsResponseCallLogsItemRequest.from_dict, from_none], obj.get("request"))
        response = from_union([GetMocksMockIDCallLogsResponseCallLogsItemResponse.from_dict, from_none], obj.get("response"))
        response_name = from_union([from_str, from_none], obj.get("responseName"))
        served_at = from_union([from_str, from_none], obj.get("servedAt"))
        return GetMocksMockIDCallLogsResponseCallLogsItem(id, request, response, response_name, served_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.request is not None:
            result["request"] = from_union([lambda x: to_class(GetMocksMockIDCallLogsResponseCallLogsItemRequest, x), from_none], self.request)
        if self.response is not None:
            result["response"] = from_union([lambda x: to_class(GetMocksMockIDCallLogsResponseCallLogsItemResponse, x), from_none], self.response)
        if self.response_name is not None:
            result["responseName"] = from_union([from_str, from_none], self.response_name)
        if self.served_at is not None:
            result["servedAt"] = from_union([from_str, from_none], self.served_at)
        return result


class GetMocksMockIDCallLogsResponseMeta:
    """The response's non-standard meta information."""
    next_cursor: Optional[str]

    def __init__(self, next_cursor: Optional[str]) -> None:
        self.next_cursor = next_cursor

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponseMeta':
        assert isinstance(obj, dict)
        next_cursor = from_union([from_none, from_str], obj.get("nextCursor"))
        return GetMocksMockIDCallLogsResponseMeta(next_cursor)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.next_cursor is not None:
            result["nextCursor"] = from_union([from_none, from_str], self.next_cursor)
        return result


class GetMocksMockIDCallLogsResponse:
    call_logs: Optional[List[GetMocksMockIDCallLogsResponseCallLogsItem]]
    """The response's non-standard meta information."""
    meta: Optional[GetMocksMockIDCallLogsResponseMeta]

    def __init__(self, call_logs: Optional[List[GetMocksMockIDCallLogsResponseCallLogsItem]], meta: Optional[GetMocksMockIDCallLogsResponseMeta]) -> None:
        self.call_logs = call_logs
        self.meta = meta

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponse':
        assert isinstance(obj, dict)
        call_logs = from_union([lambda x: from_list(GetMocksMockIDCallLogsResponseCallLogsItem.from_dict, x), from_none], obj.get("call-logs"))
        meta = from_union([GetMocksMockIDCallLogsResponseMeta.from_dict, from_none], obj.get("meta"))
        return GetMocksMockIDCallLogsResponse(call_logs, meta)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.call_logs is not None:
            result["call-logs"] = from_union([lambda x: from_list(lambda x: to_class(GetMocksMockIDCallLogsResponseCallLogsItem, x), x), from_none], self.call_logs)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(GetMocksMockIDCallLogsResponseMeta, x), from_none], self.meta)
        return result


class GetMocksMockIDCallLogsResponse400Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponse400Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksMockIDCallLogsResponse400Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksMockIDCallLogsResponse400:
    error: Optional[GetMocksMockIDCallLogsResponse400Error]

    def __init__(self, error: Optional[GetMocksMockIDCallLogsResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponse400':
        assert isinstance(obj, dict)
        error = from_union([GetMocksMockIDCallLogsResponse400Error.from_dict, from_none], obj.get("error"))
        return GetMocksMockIDCallLogsResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksMockIDCallLogsResponse400Error, x), from_none], self.error)
        return result


class GetMocksMockIDCallLogsResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksMockIDCallLogsResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksMockIDCallLogsResponse401:
    error: Optional[GetMocksMockIDCallLogsResponse401Error]

    def __init__(self, error: Optional[GetMocksMockIDCallLogsResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetMocksMockIDCallLogsResponse401Error.from_dict, from_none], obj.get("error"))
        return GetMocksMockIDCallLogsResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksMockIDCallLogsResponse401Error, x), from_none], self.error)
        return result


class GetMocksMockIDCallLogsResponse404Error:
    """Information about the error."""
    details: Optional[List[str]]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[List[str]], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([lambda x: from_list(from_str, x), from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksMockIDCallLogsResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: from_list(from_str, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksMockIDCallLogsResponse404:
    error: Optional[GetMocksMockIDCallLogsResponse404Error]

    def __init__(self, error: Optional[GetMocksMockIDCallLogsResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponse404':
        assert isinstance(obj, dict)
        error = from_union([GetMocksMockIDCallLogsResponse404Error.from_dict, from_none], obj.get("error"))
        return GetMocksMockIDCallLogsResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksMockIDCallLogsResponse404Error, x), from_none], self.error)
        return result


class GetMocksMockIDCallLogsResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetMocksMockIDCallLogsResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetMocksMockIDCallLogsResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksMockIDCallLogsResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksMockIDCallLogsResponse500:
    error: Optional[GetMocksMockIDCallLogsResponse500Error]

    def __init__(self, error: Optional[GetMocksMockIDCallLogsResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDCallLogsResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetMocksMockIDCallLogsResponse500Error.from_dict, from_none], obj.get("error"))
        return GetMocksMockIDCallLogsResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksMockIDCallLogsResponse500Error, x), from_none], self.error)
        return result


class GetMocksMockIDResponseMockConfig:
    """Information about the mock server's configuration."""
    """A list of the mock server's headers."""
    headers: Optional[List[Any]]
    """If true, match the request body."""
    match_body: Optional[bool]
    """If true, match query parameters."""
    match_query_params: Optional[bool]
    """If true, use wildcard variable matching."""
    match_wildcards: Optional[bool]
    """The ID of mock server's default response for requests. All calls to the mock server will
    return the defined response.
    """
    server_response_id: Optional[str]

    def __init__(self, headers: Optional[List[Any]], match_body: Optional[bool], match_query_params: Optional[bool], match_wildcards: Optional[bool], server_response_id: Optional[str]) -> None:
        self.headers = headers
        self.match_body = match_body
        self.match_query_params = match_query_params
        self.match_wildcards = match_wildcards
        self.server_response_id = server_response_id

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDResponseMockConfig':
        assert isinstance(obj, dict)
        headers = from_union([lambda x: from_list(lambda x: x, x), from_none], obj.get("headers"))
        match_body = from_union([from_bool, from_none], obj.get("matchBody"))
        match_query_params = from_union([from_bool, from_none], obj.get("matchQueryParams"))
        match_wildcards = from_union([from_bool, from_none], obj.get("matchWildcards"))
        server_response_id = from_union([from_none, from_str], obj.get("serverResponseId"))
        return GetMocksMockIDResponseMockConfig(headers, match_body, match_query_params, match_wildcards, server_response_id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.headers is not None:
            result["headers"] = from_union([lambda x: from_list(lambda x: x, x), from_none], self.headers)
        if self.match_body is not None:
            result["matchBody"] = from_union([from_bool, from_none], self.match_body)
        if self.match_query_params is not None:
            result["matchQueryParams"] = from_union([from_bool, from_none], self.match_query_params)
        if self.match_wildcards is not None:
            result["matchWildcards"] = from_union([from_bool, from_none], self.match_wildcards)
        if self.server_response_id is not None:
            result["serverResponseId"] = from_union([from_none, from_str], self.server_response_id)
        return result


class GetMocksMockIDResponseMock:
    """The mock's associated collection unique ID."""
    collection: Optional[str]
    """Information about the mock server's configuration."""
    config: Optional[GetMocksMockIDResponseMockConfig]
    """The date and time at which the mock server was created."""
    created_at: Optional[str]
    """If true, the mock server is not active. Mock servers deactivate when a linked collection
    or environment is deleted.
    """
    deactivated: Optional[bool]
    """The mock server's associated environment ID."""
    environment: Optional[str]
    """The mock server's ID."""
    id: Optional[str]
    """If true, the mock server is public."""
    is_public: Optional[bool]
    """The mock server URL."""
    mock_url: Optional[str]
    """The mock server's name."""
    name: Optional[str]
    """The ID of mock server's owner."""
    owner: Optional[str]
    """The mock server's unique ID."""
    uid: Optional[str]
    """The date and time at which the mock server was last updated."""
    updated_at: Optional[str]

    def __init__(self, collection: Optional[str], config: Optional[GetMocksMockIDResponseMockConfig], created_at: Optional[str], deactivated: Optional[bool], environment: Optional[str], id: Optional[str], is_public: Optional[bool], mock_url: Optional[str], name: Optional[str], owner: Optional[str], uid: Optional[str], updated_at: Optional[str]) -> None:
        self.collection = collection
        self.config = config
        self.created_at = created_at
        self.deactivated = deactivated
        self.environment = environment
        self.id = id
        self.is_public = is_public
        self.mock_url = mock_url
        self.name = name
        self.owner = owner
        self.uid = uid
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDResponseMock':
        assert isinstance(obj, dict)
        collection = from_union([from_str, from_none], obj.get("collection"))
        config = from_union([GetMocksMockIDResponseMockConfig.from_dict, from_none], obj.get("config"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        deactivated = from_union([from_bool, from_none], obj.get("deactivated"))
        environment = from_union([from_str, from_none], obj.get("environment"))
        id = from_union([from_str, from_none], obj.get("id"))
        is_public = from_union([from_bool, from_none], obj.get("isPublic"))
        mock_url = from_union([from_str, from_none], obj.get("mockUrl"))
        name = from_union([from_str, from_none], obj.get("name"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return GetMocksMockIDResponseMock(collection, config, created_at, deactivated, environment, id, is_public, mock_url, name, owner, uid, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([from_str, from_none], self.collection)
        if self.config is not None:
            result["config"] = from_union([lambda x: to_class(GetMocksMockIDResponseMockConfig, x), from_none], self.config)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.deactivated is not None:
            result["deactivated"] = from_union([from_bool, from_none], self.deactivated)
        if self.environment is not None:
            result["environment"] = from_union([from_str, from_none], self.environment)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.is_public is not None:
            result["isPublic"] = from_union([from_bool, from_none], self.is_public)
        if self.mock_url is not None:
            result["mockUrl"] = from_union([from_str, from_none], self.mock_url)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class GetMocksMockIDResponse:
    mock: Optional[GetMocksMockIDResponseMock]

    def __init__(self, mock: Optional[GetMocksMockIDResponseMock]) -> None:
        self.mock = mock

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDResponse':
        assert isinstance(obj, dict)
        mock = from_union([GetMocksMockIDResponseMock.from_dict, from_none], obj.get("mock"))
        return GetMocksMockIDResponse(mock)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.mock is not None:
            result["mock"] = from_union([lambda x: to_class(GetMocksMockIDResponseMock, x), from_none], self.mock)
        return result


class GetMocksMockIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksMockIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksMockIDResponse401:
    error: Optional[GetMocksMockIDResponse401Error]

    def __init__(self, error: Optional[GetMocksMockIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetMocksMockIDResponse401Error.from_dict, from_none], obj.get("error"))
        return GetMocksMockIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksMockIDResponse401Error, x), from_none], self.error)
        return result


class GetMocksMockIDResponse404Error:
    """Information about the error."""
    details: Optional[List[str]]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[List[str]], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([lambda x: from_list(from_str, x), from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksMockIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: from_list(from_str, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksMockIDResponse404:
    error: Optional[GetMocksMockIDResponse404Error]

    def __init__(self, error: Optional[GetMocksMockIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([GetMocksMockIDResponse404Error.from_dict, from_none], obj.get("error"))
        return GetMocksMockIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksMockIDResponse404Error, x), from_none], self.error)
        return result


class GetMocksMockIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetMocksMockIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetMocksMockIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksMockIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksMockIDResponse500:
    error: Optional[GetMocksMockIDResponse500Error]

    def __init__(self, error: Optional[GetMocksMockIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetMocksMockIDResponse500Error.from_dict, from_none], obj.get("error"))
        return GetMocksMockIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksMockIDResponse500Error, x), from_none], self.error)
        return result


class GetMocksMockIDServerResponsesResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksMockIDServerResponsesResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksMockIDServerResponsesResponse401:
    error: Optional[GetMocksMockIDServerResponsesResponse401Error]

    def __init__(self, error: Optional[GetMocksMockIDServerResponsesResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetMocksMockIDServerResponsesResponse401Error.from_dict, from_none], obj.get("error"))
        return GetMocksMockIDServerResponsesResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksMockIDServerResponsesResponse401Error, x), from_none], self.error)
        return result


class GetMocksMockIDServerResponsesResponse404Error:
    """Information about the error."""
    details: Optional[List[str]]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[List[str]], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([lambda x: from_list(from_str, x), from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksMockIDServerResponsesResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: from_list(from_str, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksMockIDServerResponsesResponse404:
    error: Optional[GetMocksMockIDServerResponsesResponse404Error]

    def __init__(self, error: Optional[GetMocksMockIDServerResponsesResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesResponse404':
        assert isinstance(obj, dict)
        error = from_union([GetMocksMockIDServerResponsesResponse404Error.from_dict, from_none], obj.get("error"))
        return GetMocksMockIDServerResponsesResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksMockIDServerResponsesResponse404Error, x), from_none], self.error)
        return result


class GetMocksMockIDServerResponsesResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetMocksMockIDServerResponsesResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetMocksMockIDServerResponsesResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksMockIDServerResponsesResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksMockIDServerResponsesResponse500:
    error: Optional[GetMocksMockIDServerResponsesResponse500Error]

    def __init__(self, error: Optional[GetMocksMockIDServerResponsesResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetMocksMockIDServerResponsesResponse500Error.from_dict, from_none], obj.get("error"))
        return GetMocksMockIDServerResponsesResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksMockIDServerResponsesResponse500Error, x), from_none], self.error)
        return result


class GetMocksMockIDServerResponsesResponseItem:
    """Information about the server response."""
    """The date and time at which the server response was created."""
    created_at: Optional[str]
    """The user ID of the user who created the server response."""
    created_by: Optional[str]
    """The server response's ID."""
    id: Optional[str]
    """The server response's name."""
    name: Optional[str]
    """The server response's 5xx HTTP response code."""
    status_code: Optional[float]
    """The date and time at which the server response was last updated."""
    updated_at: Optional[str]
    """The user ID of the user who last updated the server response."""
    updated_by: Optional[str]

    def __init__(self, created_at: Optional[str], created_by: Optional[str], id: Optional[str], name: Optional[str], status_code: Optional[float], updated_at: Optional[str], updated_by: Optional[str]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.id = id
        self.name = name
        self.status_code = status_code
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesResponseItem':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_str, from_none], obj.get("createdBy"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        status_code = from_union([from_float, from_none], obj.get("statusCode"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_str, from_none], obj.get("updatedBy"))
        return GetMocksMockIDServerResponsesResponseItem(created_at, created_by, id, name, status_code, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_str, from_none], self.created_by)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.status_code is not None:
            result["statusCode"] = from_union([to_float, from_none], self.status_code)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_str, from_none], self.updated_by)
        return result


class GetMocksMockIDServerResponsesServerResponseIDResponse400Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesServerResponseIDResponse400Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksMockIDServerResponsesServerResponseIDResponse400Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksMockIDServerResponsesServerResponseIDResponse400:
    error: Optional[GetMocksMockIDServerResponsesServerResponseIDResponse400Error]

    def __init__(self, error: Optional[GetMocksMockIDServerResponsesServerResponseIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesServerResponseIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([GetMocksMockIDServerResponsesServerResponseIDResponse400Error.from_dict, from_none], obj.get("error"))
        return GetMocksMockIDServerResponsesServerResponseIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksMockIDServerResponsesServerResponseIDResponse400Error, x), from_none], self.error)
        return result


class GetMocksMockIDServerResponsesServerResponseIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesServerResponseIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksMockIDServerResponsesServerResponseIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksMockIDServerResponsesServerResponseIDResponse401:
    error: Optional[GetMocksMockIDServerResponsesServerResponseIDResponse401Error]

    def __init__(self, error: Optional[GetMocksMockIDServerResponsesServerResponseIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesServerResponseIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetMocksMockIDServerResponsesServerResponseIDResponse401Error.from_dict, from_none], obj.get("error"))
        return GetMocksMockIDServerResponsesServerResponseIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksMockIDServerResponsesServerResponseIDResponse401Error, x), from_none], self.error)
        return result


class GetMocksMockIDServerResponsesServerResponseIDResponse404Error:
    """Information about the error."""
    details: Optional[List[str]]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[List[str]], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesServerResponseIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([lambda x: from_list(from_str, x), from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksMockIDServerResponsesServerResponseIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: from_list(from_str, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksMockIDServerResponsesServerResponseIDResponse404:
    error: Optional[GetMocksMockIDServerResponsesServerResponseIDResponse404Error]

    def __init__(self, error: Optional[GetMocksMockIDServerResponsesServerResponseIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesServerResponseIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([GetMocksMockIDServerResponsesServerResponseIDResponse404Error.from_dict, from_none], obj.get("error"))
        return GetMocksMockIDServerResponsesServerResponseIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksMockIDServerResponsesServerResponseIDResponse404Error, x), from_none], self.error)
        return result


class GetMocksMockIDServerResponsesServerResponseIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesServerResponseIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetMocksMockIDServerResponsesServerResponseIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetMocksMockIDServerResponsesServerResponseIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesServerResponseIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksMockIDServerResponsesServerResponseIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksMockIDServerResponsesServerResponseIDResponse500:
    error: Optional[GetMocksMockIDServerResponsesServerResponseIDResponse500Error]

    def __init__(self, error: Optional[GetMocksMockIDServerResponsesServerResponseIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesServerResponseIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetMocksMockIDServerResponsesServerResponseIDResponse500Error.from_dict, from_none], obj.get("error"))
        return GetMocksMockIDServerResponsesServerResponseIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksMockIDServerResponsesServerResponseIDResponse500Error, x), from_none], self.error)
        return result


class GetMocksMockIDServerResponsesServerResponseIDResponseItem:
    """Information about the server response."""
    """The date and time at which the server response was created."""
    created_at: Optional[str]
    """The user ID of the user who created the server response."""
    created_by: Optional[str]
    """The server response's ID."""
    id: Optional[str]
    """The server response's name."""
    name: Optional[str]
    """The server response's 5xx HTTP response code."""
    status_code: Optional[float]
    """The date and time at which the server response was last updated."""
    updated_at: Optional[str]
    """The user ID of the user who last updated the server response."""
    updated_by: Optional[str]

    def __init__(self, created_at: Optional[str], created_by: Optional[str], id: Optional[str], name: Optional[str], status_code: Optional[float], updated_at: Optional[str], updated_by: Optional[str]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.id = id
        self.name = name
        self.status_code = status_code
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksMockIDServerResponsesServerResponseIDResponseItem':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_str, from_none], obj.get("createdBy"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        status_code = from_union([from_float, from_none], obj.get("statusCode"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_str, from_none], obj.get("updatedBy"))
        return GetMocksMockIDServerResponsesServerResponseIDResponseItem(created_at, created_by, id, name, status_code, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_str, from_none], self.created_by)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.status_code is not None:
            result["statusCode"] = from_union([to_float, from_none], self.status_code)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_str, from_none], self.updated_by)
        return result


class Preset(Enum):
    """The simulated fixed network delay value:
    
    - `1`  2G (300 ms).
    - `2`  3G (100 ms).
    
    The object does not return this value for custom delay values.
    """
    THE_1 = "1"
    THE_2 = "2"


class GetMocksResponseMocksItemConfigDelayType(Enum):
    """The type of simulated delay value:
    
    - `fixed`  The delay value is a fixed value.
    """
    FIXED = "fixed"


class GetMocksResponseMocksItemConfigDelay:
    """The configured delay, in milliseconds."""
    duration: Optional[int]
    """The simulated fixed network delay value:
    
    - `1`  2G (300 ms).
    - `2`  3G (100 ms).
    
    The object does not return this value for custom delay values.
    """
    preset: Optional[Preset]
    """The type of simulated delay value:
    
    - `fixed`  The delay value is a fixed value.
    """
    type: Optional[GetMocksResponseMocksItemConfigDelayType]

    def __init__(self, duration: Optional[int], preset: Optional[Preset], type: Optional[GetMocksResponseMocksItemConfigDelayType]) -> None:
        self.duration = duration
        self.preset = preset
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksResponseMocksItemConfigDelay':
        assert isinstance(obj, dict)
        duration = from_union([from_int, from_none], obj.get("duration"))
        preset = from_union([Preset, from_none], obj.get("preset"))
        type = from_union([GetMocksResponseMocksItemConfigDelayType, from_none], obj.get("type"))
        return GetMocksResponseMocksItemConfigDelay(duration, preset, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.duration is not None:
            result["duration"] = from_union([from_int, from_none], self.duration)
        if self.preset is not None:
            result["preset"] = from_union([lambda x: to_enum(Preset, x), from_none], self.preset)
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(GetMocksResponseMocksItemConfigDelayType, x), from_none], self.type)
        return result


class GetMocksResponseMocksItemConfig:
    """Information about the mock server's configuration."""
    """Information about the mock server's simulated network delay settings. This returns a null
    value if there are no configured network delay settings.
    """
    delay: Optional[GetMocksResponseMocksItemConfigDelay]
    """A list of the mock server's headers."""
    headers: Optional[List[str]]
    """If true, match the request body."""
    match_body: Optional[bool]
    """If true, match query parameters."""
    match_query_params: Optional[bool]
    """If true, use wildcard variable matching."""
    match_wildcards: Optional[bool]
    """The ID of mock server's default response for requests. All calls to the mock server will
    return the defined response.
    """
    server_response_id: Optional[str]

    def __init__(self, delay: Optional[GetMocksResponseMocksItemConfigDelay], headers: Optional[List[str]], match_body: Optional[bool], match_query_params: Optional[bool], match_wildcards: Optional[bool], server_response_id: Optional[str]) -> None:
        self.delay = delay
        self.headers = headers
        self.match_body = match_body
        self.match_query_params = match_query_params
        self.match_wildcards = match_wildcards
        self.server_response_id = server_response_id

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksResponseMocksItemConfig':
        assert isinstance(obj, dict)
        delay = from_union([from_none, GetMocksResponseMocksItemConfigDelay.from_dict], obj.get("delay"))
        headers = from_union([lambda x: from_list(from_str, x), from_none], obj.get("headers"))
        match_body = from_union([from_bool, from_none], obj.get("matchBody"))
        match_query_params = from_union([from_bool, from_none], obj.get("matchQueryParams"))
        match_wildcards = from_union([from_bool, from_none], obj.get("matchWildcards"))
        server_response_id = from_union([from_str, from_none], obj.get("serverResponseId"))
        return GetMocksResponseMocksItemConfig(delay, headers, match_body, match_query_params, match_wildcards, server_response_id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.delay is not None:
            result["delay"] = from_union([from_none, lambda x: to_class(GetMocksResponseMocksItemConfigDelay, x)], self.delay)
        if self.headers is not None:
            result["headers"] = from_union([lambda x: from_list(from_str, x), from_none], self.headers)
        if self.match_body is not None:
            result["matchBody"] = from_union([from_bool, from_none], self.match_body)
        if self.match_query_params is not None:
            result["matchQueryParams"] = from_union([from_bool, from_none], self.match_query_params)
        if self.match_wildcards is not None:
            result["matchWildcards"] = from_union([from_bool, from_none], self.match_wildcards)
        if self.server_response_id is not None:
            result["serverResponseId"] = from_union([from_str, from_none], self.server_response_id)
        return result


class GetMocksResponseMocksItem:
    """Information about the mock servers."""
    """The mock's associated collection unique ID."""
    collection: Optional[str]
    """Information about the mock server's configuration."""
    config: Optional[GetMocksResponseMocksItemConfig]
    """The date and time at which the mock server was created."""
    created_at: Optional[str]
    """The mock server's associated environment ID."""
    environment: Optional[str]
    """The mock server's ID."""
    id: Optional[str]
    """If true, the mock server is public."""
    is_public: Optional[bool]
    """The mock server URL."""
    mock_url: Optional[str]
    """The mock server's name."""
    name: Optional[str]
    """The ID of mock server's owner."""
    owner: Optional[str]
    """The mock server's unique ID."""
    uid: Optional[str]
    """The date and time at which the mock server was last updated."""
    updated_at: Optional[str]

    def __init__(self, collection: Optional[str], config: Optional[GetMocksResponseMocksItemConfig], created_at: Optional[str], environment: Optional[str], id: Optional[str], is_public: Optional[bool], mock_url: Optional[str], name: Optional[str], owner: Optional[str], uid: Optional[str], updated_at: Optional[str]) -> None:
        self.collection = collection
        self.config = config
        self.created_at = created_at
        self.environment = environment
        self.id = id
        self.is_public = is_public
        self.mock_url = mock_url
        self.name = name
        self.owner = owner
        self.uid = uid
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksResponseMocksItem':
        assert isinstance(obj, dict)
        collection = from_union([from_str, from_none], obj.get("collection"))
        config = from_union([GetMocksResponseMocksItemConfig.from_dict, from_none], obj.get("config"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        environment = from_union([from_str, from_none], obj.get("environment"))
        id = from_union([from_str, from_none], obj.get("id"))
        is_public = from_union([from_bool, from_none], obj.get("isPublic"))
        mock_url = from_union([from_str, from_none], obj.get("mockUrl"))
        name = from_union([from_str, from_none], obj.get("name"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return GetMocksResponseMocksItem(collection, config, created_at, environment, id, is_public, mock_url, name, owner, uid, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([from_str, from_none], self.collection)
        if self.config is not None:
            result["config"] = from_union([lambda x: to_class(GetMocksResponseMocksItemConfig, x), from_none], self.config)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.environment is not None:
            result["environment"] = from_union([from_str, from_none], self.environment)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.is_public is not None:
            result["isPublic"] = from_union([from_bool, from_none], self.is_public)
        if self.mock_url is not None:
            result["mockUrl"] = from_union([from_str, from_none], self.mock_url)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class GetMocksResponse:
    mocks: Optional[List[GetMocksResponseMocksItem]]

    def __init__(self, mocks: Optional[List[GetMocksResponseMocksItem]]) -> None:
        self.mocks = mocks

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksResponse':
        assert isinstance(obj, dict)
        mocks = from_union([lambda x: from_list(GetMocksResponseMocksItem.from_dict, x), from_none], obj.get("mocks"))
        return GetMocksResponse(mocks)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.mocks is not None:
            result["mocks"] = from_union([lambda x: from_list(lambda x: to_class(GetMocksResponseMocksItem, x), x), from_none], self.mocks)
        return result


class GetMocksResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksResponse401:
    error: Optional[GetMocksResponse401Error]

    def __init__(self, error: Optional[GetMocksResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetMocksResponse401Error.from_dict, from_none], obj.get("error"))
        return GetMocksResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksResponse401Error, x), from_none], self.error)
        return result


class GetMocksResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetMocksResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetMocksResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMocksResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMocksResponse500:
    error: Optional[GetMocksResponse500Error]

    def __init__(self, error: Optional[GetMocksResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMocksResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetMocksResponse500Error.from_dict, from_none], obj.get("error"))
        return GetMocksResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMocksResponse500Error, x), from_none], self.error)
        return result


class GetMonitorsMonitorIDResponseMonitorLastRunStatsAssertions:
    """Information about the monitor's assertions."""
    """The total number of test failures."""
    failed: Optional[float]
    """The total number of tests performed."""
    total: Optional[float]

    def __init__(self, failed: Optional[float], total: Optional[float]) -> None:
        self.failed = failed
        self.total = total

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponseMonitorLastRunStatsAssertions':
        assert isinstance(obj, dict)
        failed = from_union([from_float, from_none], obj.get("failed"))
        total = from_union([from_float, from_none], obj.get("total"))
        return GetMonitorsMonitorIDResponseMonitorLastRunStatsAssertions(failed, total)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.failed is not None:
            result["failed"] = from_union([to_float, from_none], self.failed)
        if self.total is not None:
            result["total"] = from_union([to_float, from_none], self.total)
        return result


class GetMonitorsMonitorIDResponseMonitorLastRunStatsRequests:
    """Information about the monitor's requests."""
    """The total number of requests."""
    total: Optional[float]

    def __init__(self, total: Optional[float]) -> None:
        self.total = total

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponseMonitorLastRunStatsRequests':
        assert isinstance(obj, dict)
        total = from_union([from_float, from_none], obj.get("total"))
        return GetMonitorsMonitorIDResponseMonitorLastRunStatsRequests(total)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.total is not None:
            result["total"] = from_union([to_float, from_none], self.total)
        return result


class GetMonitorsMonitorIDResponseMonitorLastRunStats:
    """Information about the monitor's stats."""
    """Information about the monitor's assertions."""
    assertions: Optional[GetMonitorsMonitorIDResponseMonitorLastRunStatsAssertions]
    """Information about the monitor's requests."""
    requests: Optional[GetMonitorsMonitorIDResponseMonitorLastRunStatsRequests]

    def __init__(self, assertions: Optional[GetMonitorsMonitorIDResponseMonitorLastRunStatsAssertions], requests: Optional[GetMonitorsMonitorIDResponseMonitorLastRunStatsRequests]) -> None:
        self.assertions = assertions
        self.requests = requests

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponseMonitorLastRunStats':
        assert isinstance(obj, dict)
        assertions = from_union([GetMonitorsMonitorIDResponseMonitorLastRunStatsAssertions.from_dict, from_none], obj.get("assertions"))
        requests = from_union([GetMonitorsMonitorIDResponseMonitorLastRunStatsRequests.from_dict, from_none], obj.get("requests"))
        return GetMonitorsMonitorIDResponseMonitorLastRunStats(assertions, requests)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.assertions is not None:
            result["assertions"] = from_union([lambda x: to_class(GetMonitorsMonitorIDResponseMonitorLastRunStatsAssertions, x), from_none], self.assertions)
        if self.requests is not None:
            result["requests"] = from_union([lambda x: to_class(GetMonitorsMonitorIDResponseMonitorLastRunStatsRequests, x), from_none], self.requests)
        return result


class GetMonitorsMonitorIDResponseMonitorLastRun:
    """Information about the monitor's previous run."""
    """The date and time at which the monitor's previous run completed."""
    finished_at: Optional[str]
    """The date and time at which the monitor's previous run started."""
    started_at: Optional[str]
    """Information about the monitor's stats."""
    stats: Optional[GetMonitorsMonitorIDResponseMonitorLastRunStats]
    """The monitor's status after its last run."""
    status: Optional[str]

    def __init__(self, finished_at: Optional[str], started_at: Optional[str], stats: Optional[GetMonitorsMonitorIDResponseMonitorLastRunStats], status: Optional[str]) -> None:
        self.finished_at = finished_at
        self.started_at = started_at
        self.stats = stats
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponseMonitorLastRun':
        assert isinstance(obj, dict)
        finished_at = from_union([from_str, from_none], obj.get("finishedAt"))
        started_at = from_union([from_str, from_none], obj.get("startedAt"))
        stats = from_union([GetMonitorsMonitorIDResponseMonitorLastRunStats.from_dict, from_none], obj.get("stats"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetMonitorsMonitorIDResponseMonitorLastRun(finished_at, started_at, stats, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.finished_at is not None:
            result["finishedAt"] = from_union([from_str, from_none], self.finished_at)
        if self.started_at is not None:
            result["startedAt"] = from_union([from_str, from_none], self.started_at)
        if self.stats is not None:
            result["stats"] = from_union([lambda x: to_class(GetMonitorsMonitorIDResponseMonitorLastRunStats, x), from_none], self.stats)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetMonitorsMonitorIDResponseMonitorNotificationsOnErrorItem:
    """The email address of the user to notify on monitor error."""
    email: Optional[str]

    def __init__(self, email: Optional[str]) -> None:
        self.email = email

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponseMonitorNotificationsOnErrorItem':
        assert isinstance(obj, dict)
        email = from_union([from_str, from_none], obj.get("email"))
        return GetMonitorsMonitorIDResponseMonitorNotificationsOnErrorItem(email)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.email is not None:
            result["email"] = from_union([from_str, from_none], self.email)
        return result


class GetMonitorsMonitorIDResponseMonitorNotificationsOnFailureItem:
    """The email address of the user to notify on monitor failure."""
    email: Optional[str]

    def __init__(self, email: Optional[str]) -> None:
        self.email = email

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponseMonitorNotificationsOnFailureItem':
        assert isinstance(obj, dict)
        email = from_union([from_str, from_none], obj.get("email"))
        return GetMonitorsMonitorIDResponseMonitorNotificationsOnFailureItem(email)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.email is not None:
            result["email"] = from_union([from_str, from_none], self.email)
        return result


class GetMonitorsMonitorIDResponseMonitorNotifications:
    """Information about the monitor's notification settings."""
    on_error: Optional[List[GetMonitorsMonitorIDResponseMonitorNotificationsOnErrorItem]]
    on_failure: Optional[List[GetMonitorsMonitorIDResponseMonitorNotificationsOnFailureItem]]

    def __init__(self, on_error: Optional[List[GetMonitorsMonitorIDResponseMonitorNotificationsOnErrorItem]], on_failure: Optional[List[GetMonitorsMonitorIDResponseMonitorNotificationsOnFailureItem]]) -> None:
        self.on_error = on_error
        self.on_failure = on_failure

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponseMonitorNotifications':
        assert isinstance(obj, dict)
        on_error = from_union([lambda x: from_list(GetMonitorsMonitorIDResponseMonitorNotificationsOnErrorItem.from_dict, x), from_none], obj.get("onError"))
        on_failure = from_union([lambda x: from_list(GetMonitorsMonitorIDResponseMonitorNotificationsOnFailureItem.from_dict, x), from_none], obj.get("onFailure"))
        return GetMonitorsMonitorIDResponseMonitorNotifications(on_error, on_failure)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.on_error is not None:
            result["onError"] = from_union([lambda x: from_list(lambda x: to_class(GetMonitorsMonitorIDResponseMonitorNotificationsOnErrorItem, x), x), from_none], self.on_error)
        if self.on_failure is not None:
            result["onFailure"] = from_union([lambda x: from_list(lambda x: to_class(GetMonitorsMonitorIDResponseMonitorNotificationsOnFailureItem, x), x), from_none], self.on_failure)
        return result


class GetMonitorsMonitorIDResponseMonitorOptions:
    """Information about the monitor's option settings."""
    """If true, follow redirects enabled."""
    follow_redirects: Optional[bool]
    """The monitor's request delay value."""
    request_delay: Optional[float]
    """The monitor's request timeout value."""
    request_timeout: Optional[float]
    """If true, strict SSL enabled."""
    strict_ssl: Optional[bool]

    def __init__(self, follow_redirects: Optional[bool], request_delay: Optional[float], request_timeout: Optional[float], strict_ssl: Optional[bool]) -> None:
        self.follow_redirects = follow_redirects
        self.request_delay = request_delay
        self.request_timeout = request_timeout
        self.strict_ssl = strict_ssl

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponseMonitorOptions':
        assert isinstance(obj, dict)
        follow_redirects = from_union([from_bool, from_none], obj.get("followRedirects"))
        request_delay = from_union([from_float, from_none], obj.get("requestDelay"))
        request_timeout = from_union([from_float, from_none], obj.get("requestTimeout"))
        strict_ssl = from_union([from_bool, from_none], obj.get("strictSSL"))
        return GetMonitorsMonitorIDResponseMonitorOptions(follow_redirects, request_delay, request_timeout, strict_ssl)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.follow_redirects is not None:
            result["followRedirects"] = from_union([from_bool, from_none], self.follow_redirects)
        if self.request_delay is not None:
            result["requestDelay"] = from_union([to_float, from_none], self.request_delay)
        if self.request_timeout is not None:
            result["requestTimeout"] = from_union([to_float, from_none], self.request_timeout)
        if self.strict_ssl is not None:
            result["strictSSL"] = from_union([from_bool, from_none], self.strict_ssl)
        return result


class GetMonitorsMonitorIDResponseMonitorSchedule:
    """Information about the monitor's schedule."""
    """The monitor's cron frequency value."""
    cron: Optional[str]
    """The date and time of monitor's next scheduled run."""
    next_run: Optional[str]
    """The monitor's timezone."""
    timezone: Optional[str]

    def __init__(self, cron: Optional[str], next_run: Optional[str], timezone: Optional[str]) -> None:
        self.cron = cron
        self.next_run = next_run
        self.timezone = timezone

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponseMonitorSchedule':
        assert isinstance(obj, dict)
        cron = from_union([from_str, from_none], obj.get("cron"))
        next_run = from_union([from_str, from_none], obj.get("nextRun"))
        timezone = from_union([from_str, from_none], obj.get("timezone"))
        return GetMonitorsMonitorIDResponseMonitorSchedule(cron, next_run, timezone)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.cron is not None:
            result["cron"] = from_union([from_str, from_none], self.cron)
        if self.next_run is not None:
            result["nextRun"] = from_union([from_str, from_none], self.next_run)
        if self.timezone is not None:
            result["timezone"] = from_union([from_str, from_none], self.timezone)
        return result


class GetMonitorsMonitorIDResponseMonitor:
    """The monitor's associated collection unique ID."""
    collection_uid: Optional[str]
    """A list of the monitor's [geographic
    regions](https://learning.postman.com/docs/monitoring-your-api/setting-up-monitor/#adding-regions).
    """
    distribution: Optional[List[Any]]
    """The monitor's associated environment unique ID."""
    environment_uid: Optional[str]
    """The monitor's ID."""
    id: Optional[str]
    """Information about the monitor's previous run."""
    last_run: Optional[GetMonitorsMonitorIDResponseMonitorLastRun]
    """The monitor's name."""
    name: Optional[str]
    """Information about the monitor's notification settings."""
    notifications: Optional[GetMonitorsMonitorIDResponseMonitorNotifications]
    """Information about the monitor's option settings."""
    options: Optional[GetMonitorsMonitorIDResponseMonitorOptions]
    """The ID of monitor's owner."""
    owner: Optional[float]
    """Information about the monitor's schedule."""
    schedule: Optional[GetMonitorsMonitorIDResponseMonitorSchedule]
    """The monitor's unique ID."""
    uid: Optional[str]

    def __init__(self, collection_uid: Optional[str], distribution: Optional[List[Any]], environment_uid: Optional[str], id: Optional[str], last_run: Optional[GetMonitorsMonitorIDResponseMonitorLastRun], name: Optional[str], notifications: Optional[GetMonitorsMonitorIDResponseMonitorNotifications], options: Optional[GetMonitorsMonitorIDResponseMonitorOptions], owner: Optional[float], schedule: Optional[GetMonitorsMonitorIDResponseMonitorSchedule], uid: Optional[str]) -> None:
        self.collection_uid = collection_uid
        self.distribution = distribution
        self.environment_uid = environment_uid
        self.id = id
        self.last_run = last_run
        self.name = name
        self.notifications = notifications
        self.options = options
        self.owner = owner
        self.schedule = schedule
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponseMonitor':
        assert isinstance(obj, dict)
        collection_uid = from_union([from_str, from_none], obj.get("collectionUid"))
        distribution = from_union([lambda x: from_list(lambda x: x, x), from_none], obj.get("distribution"))
        environment_uid = from_union([from_str, from_none], obj.get("environmentUid"))
        id = from_union([from_str, from_none], obj.get("id"))
        last_run = from_union([GetMonitorsMonitorIDResponseMonitorLastRun.from_dict, from_none], obj.get("lastRun"))
        name = from_union([from_str, from_none], obj.get("name"))
        notifications = from_union([GetMonitorsMonitorIDResponseMonitorNotifications.from_dict, from_none], obj.get("notifications"))
        options = from_union([GetMonitorsMonitorIDResponseMonitorOptions.from_dict, from_none], obj.get("options"))
        owner = from_union([from_float, from_none], obj.get("owner"))
        schedule = from_union([GetMonitorsMonitorIDResponseMonitorSchedule.from_dict, from_none], obj.get("schedule"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return GetMonitorsMonitorIDResponseMonitor(collection_uid, distribution, environment_uid, id, last_run, name, notifications, options, owner, schedule, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection_uid is not None:
            result["collectionUid"] = from_union([from_str, from_none], self.collection_uid)
        if self.distribution is not None:
            result["distribution"] = from_union([lambda x: from_list(lambda x: x, x), from_none], self.distribution)
        if self.environment_uid is not None:
            result["environmentUid"] = from_union([from_str, from_none], self.environment_uid)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.last_run is not None:
            result["lastRun"] = from_union([lambda x: to_class(GetMonitorsMonitorIDResponseMonitorLastRun, x), from_none], self.last_run)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.notifications is not None:
            result["notifications"] = from_union([lambda x: to_class(GetMonitorsMonitorIDResponseMonitorNotifications, x), from_none], self.notifications)
        if self.options is not None:
            result["options"] = from_union([lambda x: to_class(GetMonitorsMonitorIDResponseMonitorOptions, x), from_none], self.options)
        if self.owner is not None:
            result["owner"] = from_union([to_float, from_none], self.owner)
        if self.schedule is not None:
            result["schedule"] = from_union([lambda x: to_class(GetMonitorsMonitorIDResponseMonitorSchedule, x), from_none], self.schedule)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class GetMonitorsMonitorIDResponse:
    monitor: Optional[GetMonitorsMonitorIDResponseMonitor]

    def __init__(self, monitor: Optional[GetMonitorsMonitorIDResponseMonitor]) -> None:
        self.monitor = monitor

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponse':
        assert isinstance(obj, dict)
        monitor = from_union([GetMonitorsMonitorIDResponseMonitor.from_dict, from_none], obj.get("monitor"))
        return GetMonitorsMonitorIDResponse(monitor)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.monitor is not None:
            result["monitor"] = from_union([lambda x: to_class(GetMonitorsMonitorIDResponseMonitor, x), from_none], self.monitor)
        return result


class GetMonitorsMonitorIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMonitorsMonitorIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMonitorsMonitorIDResponse401:
    error: Optional[GetMonitorsMonitorIDResponse401Error]

    def __init__(self, error: Optional[GetMonitorsMonitorIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetMonitorsMonitorIDResponse401Error.from_dict, from_none], obj.get("error"))
        return GetMonitorsMonitorIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMonitorsMonitorIDResponse401Error, x), from_none], self.error)
        return result


class GetMonitorsMonitorIDResponse404Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponse404Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMonitorsMonitorIDResponse404Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMonitorsMonitorIDResponse404:
    error: Optional[GetMonitorsMonitorIDResponse404Error]

    def __init__(self, error: Optional[GetMonitorsMonitorIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([GetMonitorsMonitorIDResponse404Error.from_dict, from_none], obj.get("error"))
        return GetMonitorsMonitorIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMonitorsMonitorIDResponse404Error, x), from_none], self.error)
        return result


class GetMonitorsMonitorIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetMonitorsMonitorIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetMonitorsMonitorIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMonitorsMonitorIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMonitorsMonitorIDResponse500:
    error: Optional[GetMonitorsMonitorIDResponse500Error]

    def __init__(self, error: Optional[GetMonitorsMonitorIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsMonitorIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetMonitorsMonitorIDResponse500Error.from_dict, from_none], obj.get("error"))
        return GetMonitorsMonitorIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMonitorsMonitorIDResponse500Error, x), from_none], self.error)
        return result


class GetMonitorsResponseMonitorsItem:
    """The monitor's ID."""
    id: Optional[str]
    """The monitor's name."""
    name: Optional[str]
    """The ID of the monitor's owner."""
    owner: Optional[str]
    """The monitor's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str], owner: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.name = name
        self.owner = owner
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsResponseMonitorsItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return GetMonitorsResponseMonitorsItem(id, name, owner, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class GetMonitorsResponse:
    monitors: Optional[List[GetMonitorsResponseMonitorsItem]]

    def __init__(self, monitors: Optional[List[GetMonitorsResponseMonitorsItem]]) -> None:
        self.monitors = monitors

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsResponse':
        assert isinstance(obj, dict)
        monitors = from_union([lambda x: from_list(GetMonitorsResponseMonitorsItem.from_dict, x), from_none], obj.get("monitors"))
        return GetMonitorsResponse(monitors)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.monitors is not None:
            result["monitors"] = from_union([lambda x: from_list(lambda x: to_class(GetMonitorsResponseMonitorsItem, x), x), from_none], self.monitors)
        return result


class GetMonitorsResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMonitorsResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMonitorsResponse401:
    error: Optional[GetMonitorsResponse401Error]

    def __init__(self, error: Optional[GetMonitorsResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetMonitorsResponse401Error.from_dict, from_none], obj.get("error"))
        return GetMonitorsResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMonitorsResponse401Error, x), from_none], self.error)
        return result


class GetMonitorsResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetMonitorsResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetMonitorsResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetMonitorsResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetMonitorsResponse500:
    error: Optional[GetMonitorsResponse500Error]

    def __init__(self, error: Optional[GetMonitorsResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetMonitorsResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetMonitorsResponse500Error.from_dict, from_none], obj.get("error"))
        return GetMonitorsResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetMonitorsResponse500Error, x), from_none], self.error)
        return result


class GetNetworkPrivateNetworkEntityRequestAllResponseMeta:
    """The response's non-standard meta information."""
    """The maximum number of items returned."""
    limit: Optional[int]
    """The zero-based offset of the first item returned."""
    offset: Optional[int]
    """The total count of items found."""
    total_count: Optional[int]

    def __init__(self, limit: Optional[int], offset: Optional[int], total_count: Optional[int]) -> None:
        self.limit = limit
        self.offset = offset
        self.total_count = total_count

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateNetworkEntityRequestAllResponseMeta':
        assert isinstance(obj, dict)
        limit = from_union([from_int, from_none], obj.get("limit"))
        offset = from_union([from_int, from_none], obj.get("offset"))
        total_count = from_union([from_int, from_none], obj.get("totalCount"))
        return GetNetworkPrivateNetworkEntityRequestAllResponseMeta(limit, offset, total_count)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.limit is not None:
            result["limit"] = from_union([from_int, from_none], self.limit)
        if self.offset is not None:
            result["offset"] = from_union([from_int, from_none], self.offset)
        if self.total_count is not None:
            result["totalCount"] = from_union([from_int, from_none], self.total_count)
        return result


class EntityTypeEnum(Enum):
    """The element type.
    
    The type of Postman element.
    """
    API = "api"
    COLLECTION = "collection"
    WORKSPACE = "workspace"


class GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemElement:
    """Information about the requested element."""
    """The element's ID."""
    id: Optional[str]
    """The element's name."""
    name: Optional[str]
    """The element's short summary."""
    summary: Optional[str]
    """The element type."""
    type: Optional[EntityTypeEnum]

    def __init__(self, id: Optional[str], name: Optional[str], summary: Optional[str], type: Optional[EntityTypeEnum]) -> None:
        self.id = id
        self.name = name
        self.summary = summary
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemElement':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        summary = from_union([from_str, from_none], obj.get("summary"))
        type = from_union([EntityTypeEnum, from_none], obj.get("type"))
        return GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemElement(id, name, summary, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.summary is not None:
            result["summary"] = from_union([from_str, from_none], self.summary)
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(EntityTypeEnum, x), from_none], self.type)
        return result


class GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemResponse:
    """Information about the response to the request. This object only returns when the network
    manager denied a request with a message.
    """
    """The date and time at which the network manager denied the request."""
    created_at: Optional[str]
    """The network manager's user ID."""
    created_by: Optional[int]
    """The network manager's request response message."""
    message: Optional[str]

    def __init__(self, created_at: Optional[str], created_by: Optional[int], message: Optional[str]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemResponse':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_int, from_none], obj.get("createdBy"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemResponse(created_at, created_by, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_int, from_none], self.created_by)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PurpleStatus(Enum):
    """The request's status."""
    DENIED = "denied"
    PENDING = "pending"


class GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItem:
    """The date and time at which the request was created."""
    created_at: Optional[str]
    """The ID of the user who created the request."""
    created_by: Optional[int]
    """Information about the requested element."""
    element: Optional[GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemElement]
    """The request's ID."""
    id: Optional[int]
    """The user's optional message included in the request."""
    message: Optional[str]
    """Information about the response to the request. This object only returns when the network
    manager denied a request with a message.
    """
    response: Optional[GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemResponse]
    """The request's status."""
    status: Optional[PurpleStatus]

    def __init__(self, created_at: Optional[str], created_by: Optional[int], element: Optional[GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemElement], id: Optional[int], message: Optional[str], response: Optional[GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemResponse], status: Optional[PurpleStatus]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.element = element
        self.id = id
        self.message = message
        self.response = response
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItem':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_int, from_none], obj.get("createdBy"))
        element = from_union([GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemElement.from_dict, from_none], obj.get("element"))
        id = from_union([from_int, from_none], obj.get("id"))
        message = from_union([from_str, from_none], obj.get("message"))
        response = from_union([GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemResponse.from_dict, from_none], obj.get("response"))
        status = from_union([PurpleStatus, from_none], obj.get("status"))
        return GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItem(created_at, created_by, element, id, message, response, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_int, from_none], self.created_by)
        if self.element is not None:
            result["element"] = from_union([lambda x: to_class(GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemElement, x), from_none], self.element)
        if self.id is not None:
            result["id"] = from_union([from_int, from_none], self.id)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.response is not None:
            result["response"] = from_union([lambda x: to_class(GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItemResponse, x), from_none], self.response)
        if self.status is not None:
            result["status"] = from_union([lambda x: to_enum(PurpleStatus, x), from_none], self.status)
        return result


class GetNetworkPrivateNetworkEntityRequestAllResponse:
    """The response's non-standard meta information."""
    meta: Optional[GetNetworkPrivateNetworkEntityRequestAllResponseMeta]
    """Information about the requests to add elements to the Private API Network."""
    requests: Optional[List[GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItem]]

    def __init__(self, meta: Optional[GetNetworkPrivateNetworkEntityRequestAllResponseMeta], requests: Optional[List[GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItem]]) -> None:
        self.meta = meta
        self.requests = requests

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateNetworkEntityRequestAllResponse':
        assert isinstance(obj, dict)
        meta = from_union([GetNetworkPrivateNetworkEntityRequestAllResponseMeta.from_dict, from_none], obj.get("meta"))
        requests = from_union([lambda x: from_list(GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItem.from_dict, x), from_none], obj.get("requests"))
        return GetNetworkPrivateNetworkEntityRequestAllResponse(meta, requests)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(GetNetworkPrivateNetworkEntityRequestAllResponseMeta, x), from_none], self.meta)
        if self.requests is not None:
            result["requests"] = from_union([lambda x: from_list(lambda x: to_class(GetNetworkPrivateNetworkEntityRequestAllResponseRequestsItem, x), x), from_none], self.requests)
        return result


class GetNetworkPrivateNetworkEntityRequestAllResponse400:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateNetworkEntityRequestAllResponse400':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetNetworkPrivateNetworkEntityRequestAllResponse400(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetNetworkPrivateNetworkEntityRequestAllResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateNetworkEntityRequestAllResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetNetworkPrivateNetworkEntityRequestAllResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetNetworkPrivateNetworkEntityRequestAllResponse401:
    error: Optional[GetNetworkPrivateNetworkEntityRequestAllResponse401Error]

    def __init__(self, error: Optional[GetNetworkPrivateNetworkEntityRequestAllResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateNetworkEntityRequestAllResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetNetworkPrivateNetworkEntityRequestAllResponse401Error.from_dict, from_none], obj.get("error"))
        return GetNetworkPrivateNetworkEntityRequestAllResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetNetworkPrivateNetworkEntityRequestAllResponse401Error, x), from_none], self.error)
        return result


class GetNetworkPrivateNetworkEntityRequestAllResponse403Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateNetworkEntityRequestAllResponse403Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetNetworkPrivateNetworkEntityRequestAllResponse403Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetNetworkPrivateNetworkEntityRequestAllResponse403:
    error: Optional[GetNetworkPrivateNetworkEntityRequestAllResponse403Error]

    def __init__(self, error: Optional[GetNetworkPrivateNetworkEntityRequestAllResponse403Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateNetworkEntityRequestAllResponse403':
        assert isinstance(obj, dict)
        error = from_union([GetNetworkPrivateNetworkEntityRequestAllResponse403Error.from_dict, from_none], obj.get("error"))
        return GetNetworkPrivateNetworkEntityRequestAllResponse403(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetNetworkPrivateNetworkEntityRequestAllResponse403Error, x), from_none], self.error)
        return result


class GetNetworkPrivateNetworkEntityRequestAllResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateNetworkEntityRequestAllResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetNetworkPrivateNetworkEntityRequestAllResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetNetworkPrivateNetworkEntityRequestAllResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateNetworkEntityRequestAllResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetNetworkPrivateNetworkEntityRequestAllResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetNetworkPrivateNetworkEntityRequestAllResponse500:
    error: Optional[GetNetworkPrivateNetworkEntityRequestAllResponse500Error]

    def __init__(self, error: Optional[GetNetworkPrivateNetworkEntityRequestAllResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateNetworkEntityRequestAllResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetNetworkPrivateNetworkEntityRequestAllResponse500Error.from_dict, from_none], obj.get("error"))
        return GetNetworkPrivateNetworkEntityRequestAllResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetNetworkPrivateNetworkEntityRequestAllResponse500Error, x), from_none], self.error)
        return result


class GetNetworkPrivateResponseElementsItem:
    """The date and time at which the element was published to Private API Network. This value
    is the same as the `updatedAt` value.
    """
    added_at: Optional[str]
    """The user ID of the user who published the element."""
    added_by: Optional[int]
    """The date and time at which the element was created."""
    created_at: Optional[str]
    """The user who created the element."""
    created_by: Optional[int]
    """The element's description."""
    description: Optional[str]
    """The element's HREF."""
    href: Optional[str]
    """The element's ID."""
    id: Optional[str]
    """The element's name."""
    name: Optional[str]
    """The element's parent folder ID."""
    parent_folder_id: Optional[int]
    """The element's summary."""
    summary: Optional[str]
    """The element's type."""
    type: Optional[str]
    """The date and time at which the element was last updated."""
    updated_at: Optional[str]
    """The user who updated the element."""
    updated_by: Optional[int]

    def __init__(self, added_at: Optional[str], added_by: Optional[int], created_at: Optional[str], created_by: Optional[int], description: Optional[str], href: Optional[str], id: Optional[str], name: Optional[str], parent_folder_id: Optional[int], summary: Optional[str], type: Optional[str], updated_at: Optional[str], updated_by: Optional[int]) -> None:
        self.added_at = added_at
        self.added_by = added_by
        self.created_at = created_at
        self.created_by = created_by
        self.description = description
        self.href = href
        self.id = id
        self.name = name
        self.parent_folder_id = parent_folder_id
        self.summary = summary
        self.type = type
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateResponseElementsItem':
        assert isinstance(obj, dict)
        added_at = from_union([from_str, from_none], obj.get("addedAt"))
        added_by = from_union([from_int, from_none], obj.get("addedBy"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_int, from_none], obj.get("createdBy"))
        description = from_union([from_str, from_none], obj.get("description"))
        href = from_union([from_str, from_none], obj.get("href"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        parent_folder_id = from_union([from_int, from_none], obj.get("parentFolderId"))
        summary = from_union([from_str, from_none], obj.get("summary"))
        type = from_union([from_str, from_none], obj.get("type"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_int, from_none], obj.get("updatedBy"))
        return GetNetworkPrivateResponseElementsItem(added_at, added_by, created_at, created_by, description, href, id, name, parent_folder_id, summary, type, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.added_at is not None:
            result["addedAt"] = from_union([from_str, from_none], self.added_at)
        if self.added_by is not None:
            result["addedBy"] = from_union([from_int, from_none], self.added_by)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_int, from_none], self.created_by)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.href is not None:
            result["href"] = from_union([from_str, from_none], self.href)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.parent_folder_id is not None:
            result["parentFolderId"] = from_union([from_int, from_none], self.parent_folder_id)
        if self.summary is not None:
            result["summary"] = from_union([from_str, from_none], self.summary)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_int, from_none], self.updated_by)
        return result


class GetNetworkPrivateResponseFoldersItem:
    """The date and time at which the folder was created."""
    created_at: Optional[str]
    """The user who created the folder."""
    created_by: Optional[int]
    """The folder's description."""
    description: Optional[str]
    """The folder's ID."""
    id: Optional[int]
    """The folder's name."""
    name: Optional[str]
    """The folder's parent folder ID."""
    parent_folder_id: Optional[int]
    """The element's type. This value is always `folder`."""
    type: Optional[str]
    """The date and time at which the folder was updated."""
    updated_at: Optional[str]
    """The user ID of the user who updated the folder."""
    updated_by: Optional[int]

    def __init__(self, created_at: Optional[str], created_by: Optional[int], description: Optional[str], id: Optional[int], name: Optional[str], parent_folder_id: Optional[int], type: Optional[str], updated_at: Optional[str], updated_by: Optional[int]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.description = description
        self.id = id
        self.name = name
        self.parent_folder_id = parent_folder_id
        self.type = type
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateResponseFoldersItem':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_int, from_none], obj.get("createdBy"))
        description = from_union([from_str, from_none], obj.get("description"))
        id = from_union([from_int, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        parent_folder_id = from_union([from_int, from_none], obj.get("parentFolderId"))
        type = from_union([from_str, from_none], obj.get("type"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_int, from_none], obj.get("updatedBy"))
        return GetNetworkPrivateResponseFoldersItem(created_at, created_by, description, id, name, parent_folder_id, type, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_int, from_none], self.created_by)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.id is not None:
            result["id"] = from_union([from_int, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.parent_folder_id is not None:
            result["parentFolderId"] = from_union([from_int, from_none], self.parent_folder_id)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_int, from_none], self.updated_by)
        return result


class GetNetworkPrivateResponseMeta:
    """The response's non-standard meta information."""
    """The maximum number of elements returned. If the value exceeds the maximum value of
    `1000`, then the system uses the `1000` value.
    """
    limit: Optional[int]
    """The zero-based offset of the first item returned."""
    offset: Optional[int]
    """The total count of the `elements` and `folders` items."""
    total_count: Optional[int]

    def __init__(self, limit: Optional[int], offset: Optional[int], total_count: Optional[int]) -> None:
        self.limit = limit
        self.offset = offset
        self.total_count = total_count

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateResponseMeta':
        assert isinstance(obj, dict)
        limit = from_union([from_int, from_none], obj.get("limit"))
        offset = from_union([from_int, from_none], obj.get("offset"))
        total_count = from_union([from_int, from_none], obj.get("totalCount"))
        return GetNetworkPrivateResponseMeta(limit, offset, total_count)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.limit is not None:
            result["limit"] = from_union([from_int, from_none], self.limit)
        if self.offset is not None:
            result["offset"] = from_union([from_int, from_none], self.offset)
        if self.total_count is not None:
            result["totalCount"] = from_union([from_int, from_none], self.total_count)
        return result


class GetNetworkPrivateResponse:
    """Information about a Private API Network's folder elements. Elements are APIs,
    collections, and workspaces.
    """
    elements: Optional[List[GetNetworkPrivateResponseElementsItem]]
    """Information about the Private API Network's folders."""
    folders: Optional[List[GetNetworkPrivateResponseFoldersItem]]
    """The response's non-standard meta information."""
    meta: Optional[GetNetworkPrivateResponseMeta]

    def __init__(self, elements: Optional[List[GetNetworkPrivateResponseElementsItem]], folders: Optional[List[GetNetworkPrivateResponseFoldersItem]], meta: Optional[GetNetworkPrivateResponseMeta]) -> None:
        self.elements = elements
        self.folders = folders
        self.meta = meta

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateResponse':
        assert isinstance(obj, dict)
        elements = from_union([lambda x: from_list(GetNetworkPrivateResponseElementsItem.from_dict, x), from_none], obj.get("elements"))
        folders = from_union([lambda x: from_list(GetNetworkPrivateResponseFoldersItem.from_dict, x), from_none], obj.get("folders"))
        meta = from_union([GetNetworkPrivateResponseMeta.from_dict, from_none], obj.get("meta"))
        return GetNetworkPrivateResponse(elements, folders, meta)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.elements is not None:
            result["elements"] = from_union([lambda x: from_list(lambda x: to_class(GetNetworkPrivateResponseElementsItem, x), x), from_none], self.elements)
        if self.folders is not None:
            result["folders"] = from_union([lambda x: from_list(lambda x: to_class(GetNetworkPrivateResponseFoldersItem, x), x), from_none], self.folders)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(GetNetworkPrivateResponseMeta, x), from_none], self.meta)
        return result


class GetNetworkPrivateResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetNetworkPrivateResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetNetworkPrivateResponse401:
    error: Optional[GetNetworkPrivateResponse401Error]

    def __init__(self, error: Optional[GetNetworkPrivateResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetNetworkPrivateResponse401Error.from_dict, from_none], obj.get("error"))
        return GetNetworkPrivateResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetNetworkPrivateResponse401Error, x), from_none], self.error)
        return result


class GetNetworkPrivateResponse403Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateResponse403Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetNetworkPrivateResponse403Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetNetworkPrivateResponse403:
    error: Optional[GetNetworkPrivateResponse403Error]

    def __init__(self, error: Optional[GetNetworkPrivateResponse403Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateResponse403':
        assert isinstance(obj, dict)
        error = from_union([GetNetworkPrivateResponse403Error.from_dict, from_none], obj.get("error"))
        return GetNetworkPrivateResponse403(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetNetworkPrivateResponse403Error, x), from_none], self.error)
        return result


class GetNetworkPrivateResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetNetworkPrivateResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetNetworkPrivateResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetNetworkPrivateResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetNetworkPrivateResponse500:
    error: Optional[GetNetworkPrivateResponse500Error]

    def __init__(self, error: Optional[GetNetworkPrivateResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetNetworkPrivateResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetNetworkPrivateResponse500Error.from_dict, from_none], obj.get("error"))
        return GetNetworkPrivateResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetNetworkPrivateResponse500Error, x), from_none], self.error)
        return result


class GetScimV2GroupsGroupIDResponseMembers:
    """Information about the group's members."""
    display: Optional[str]
    value: Optional[str]

    def __init__(self, display: Optional[str], value: Optional[str]) -> None:
        self.display = display
        self.value = value

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsGroupIDResponseMembers':
        assert isinstance(obj, dict)
        display = from_union([from_str, from_none], obj.get("display"))
        value = from_union([from_str, from_none], obj.get("value"))
        return GetScimV2GroupsGroupIDResponseMembers(display, value)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.display is not None:
            result["display"] = from_union([from_str, from_none], self.display)
        if self.value is not None:
            result["value"] = from_union([from_str, from_none], self.value)
        return result


class GetScimV2GroupsGroupIDResponseMeta:
    """The response's non-standard meta information."""
    """The date and time at which the group was created."""
    created: Optional[str]
    """The date and time at which the group was last modified."""
    last_modified: Optional[str]
    """The resource type."""
    resource_type: Optional[str]

    def __init__(self, created: Optional[str], last_modified: Optional[str], resource_type: Optional[str]) -> None:
        self.created = created
        self.last_modified = last_modified
        self.resource_type = resource_type

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsGroupIDResponseMeta':
        assert isinstance(obj, dict)
        created = from_union([from_str, from_none], obj.get("created"))
        last_modified = from_union([from_str, from_none], obj.get("lastModified"))
        resource_type = from_union([from_str, from_none], obj.get("resourceType"))
        return GetScimV2GroupsGroupIDResponseMeta(created, last_modified, resource_type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created is not None:
            result["created"] = from_union([from_str, from_none], self.created)
        if self.last_modified is not None:
            result["lastModified"] = from_union([from_str, from_none], self.last_modified)
        if self.resource_type is not None:
            result["resourceType"] = from_union([from_str, from_none], self.resource_type)
        return result


class GetScimV2GroupsGroupIDResponse:
    """The group's external ID."""
    external_id: Optional[str]
    """The group's SCIM ID."""
    id: Optional[str]
    """Information about the group's members."""
    members: Optional[GetScimV2GroupsGroupIDResponseMembers]
    """The response's non-standard meta information."""
    meta: Optional[GetScimV2GroupsGroupIDResponseMeta]
    """A list of schema resource URIs."""
    schemas: Optional[List[str]]
    """The group's display name."""
    user_name: Optional[str]

    def __init__(self, external_id: Optional[str], id: Optional[str], members: Optional[GetScimV2GroupsGroupIDResponseMembers], meta: Optional[GetScimV2GroupsGroupIDResponseMeta], schemas: Optional[List[str]], user_name: Optional[str]) -> None:
        self.external_id = external_id
        self.id = id
        self.members = members
        self.meta = meta
        self.schemas = schemas
        self.user_name = user_name

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsGroupIDResponse':
        assert isinstance(obj, dict)
        external_id = from_union([from_str, from_none], obj.get("externalId"))
        id = from_union([from_str, from_none], obj.get("id"))
        members = from_union([GetScimV2GroupsGroupIDResponseMembers.from_dict, from_none], obj.get("members"))
        meta = from_union([GetScimV2GroupsGroupIDResponseMeta.from_dict, from_none], obj.get("meta"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        user_name = from_union([from_str, from_none], obj.get("userName"))
        return GetScimV2GroupsGroupIDResponse(external_id, id, members, meta, schemas, user_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.external_id is not None:
            result["externalId"] = from_union([from_str, from_none], self.external_id)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.members is not None:
            result["members"] = from_union([lambda x: to_class(GetScimV2GroupsGroupIDResponseMembers, x), from_none], self.members)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(GetScimV2GroupsGroupIDResponseMeta, x), from_none], self.meta)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.user_name is not None:
            result["userName"] = from_union([from_str, from_none], self.user_name)
        return result


class GetScimV2GroupsGroupIDResponse400:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsGroupIDResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2GroupsGroupIDResponse400(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2GroupsGroupIDResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsGroupIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2GroupsGroupIDResponse401(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2GroupsGroupIDResponse403:
    """Information about the error."""
    detail: Optional[str]
    schemas: Optional[List[str]]
    """The error status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsGroupIDResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2GroupsGroupIDResponse403(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2GroupsGroupIDResponse404:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsGroupIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2GroupsGroupIDResponse404(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2GroupsGroupIDResponse429:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[float]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[float]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsGroupIDResponse429':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_float, from_none], obj.get("status"))
        return GetScimV2GroupsGroupIDResponse429(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        return result


class GetScimV2GroupsGroupIDResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsGroupIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2GroupsGroupIDResponse500(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class ScimGroupResourceMembers:
    """Information about the group's members."""
    display: Optional[str]
    value: Optional[str]

    def __init__(self, display: Optional[str], value: Optional[str]) -> None:
        self.display = display
        self.value = value

    @staticmethod
    def from_dict(obj: Any) -> 'ScimGroupResourceMembers':
        assert isinstance(obj, dict)
        display = from_union([from_str, from_none], obj.get("display"))
        value = from_union([from_str, from_none], obj.get("value"))
        return ScimGroupResourceMembers(display, value)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.display is not None:
            result["display"] = from_union([from_str, from_none], self.display)
        if self.value is not None:
            result["value"] = from_union([from_str, from_none], self.value)
        return result


class ScimGroupResourceMeta:
    """The response's non-standard meta information."""
    """The date and time at which the group was created."""
    created: Optional[str]
    """The date and time at which the group was last modified."""
    last_modified: Optional[str]
    """The resource type."""
    resource_type: Optional[str]

    def __init__(self, created: Optional[str], last_modified: Optional[str], resource_type: Optional[str]) -> None:
        self.created = created
        self.last_modified = last_modified
        self.resource_type = resource_type

    @staticmethod
    def from_dict(obj: Any) -> 'ScimGroupResourceMeta':
        assert isinstance(obj, dict)
        created = from_union([from_str, from_none], obj.get("created"))
        last_modified = from_union([from_str, from_none], obj.get("lastModified"))
        resource_type = from_union([from_str, from_none], obj.get("resourceType"))
        return ScimGroupResourceMeta(created, last_modified, resource_type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created is not None:
            result["created"] = from_union([from_str, from_none], self.created)
        if self.last_modified is not None:
            result["lastModified"] = from_union([from_str, from_none], self.last_modified)
        if self.resource_type is not None:
            result["resourceType"] = from_union([from_str, from_none], self.resource_type)
        return result


class ScimGroupResource:
    """The SCIM group resource object."""
    """The group's display name."""
    display_name: Optional[str]
    """The group's external ID."""
    external_id: Optional[str]
    """The group's SCIM ID."""
    id: Optional[str]
    """Information about the group's members."""
    members: Optional[ScimGroupResourceMembers]
    """The response's non-standard meta information."""
    meta: Optional[ScimGroupResourceMeta]
    """A list of schema resource URIs."""
    schemas: Optional[List[str]]

    def __init__(self, display_name: Optional[str], external_id: Optional[str], id: Optional[str], members: Optional[ScimGroupResourceMembers], meta: Optional[ScimGroupResourceMeta], schemas: Optional[List[str]]) -> None:
        self.display_name = display_name
        self.external_id = external_id
        self.id = id
        self.members = members
        self.meta = meta
        self.schemas = schemas

    @staticmethod
    def from_dict(obj: Any) -> 'ScimGroupResource':
        assert isinstance(obj, dict)
        display_name = from_union([from_str, from_none], obj.get("displayName"))
        external_id = from_union([from_str, from_none], obj.get("externalId"))
        id = from_union([from_str, from_none], obj.get("id"))
        members = from_union([ScimGroupResourceMembers.from_dict, from_none], obj.get("members"))
        meta = from_union([ScimGroupResourceMeta.from_dict, from_none], obj.get("meta"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        return ScimGroupResource(display_name, external_id, id, members, meta, schemas)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.display_name is not None:
            result["displayName"] = from_union([from_str, from_none], self.display_name)
        if self.external_id is not None:
            result["externalId"] = from_union([from_str, from_none], self.external_id)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.members is not None:
            result["members"] = from_union([lambda x: to_class(ScimGroupResourceMembers, x), from_none], self.members)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(ScimGroupResourceMeta, x), from_none], self.meta)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        return result


class GetScimV2GroupsResponse:
    """The number of items per response page."""
    items_per_page: Optional[float]
    """A list of group resources."""
    resources: Optional[List[ScimGroupResource]]
    schemas: Optional[List[str]]
    """The index entry by which the returned results begin."""
    start_index: Optional[float]
    """The total number of results found."""
    total_results: Optional[float]

    def __init__(self, items_per_page: Optional[float], resources: Optional[List[ScimGroupResource]], schemas: Optional[List[str]], start_index: Optional[float], total_results: Optional[float]) -> None:
        self.items_per_page = items_per_page
        self.resources = resources
        self.schemas = schemas
        self.start_index = start_index
        self.total_results = total_results

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsResponse':
        assert isinstance(obj, dict)
        items_per_page = from_union([from_float, from_none], obj.get("itemsPerPage"))
        resources = from_union([lambda x: from_list(ScimGroupResource.from_dict, x), from_none], obj.get("Resources"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        start_index = from_union([from_float, from_none], obj.get("startIndex"))
        total_results = from_union([from_float, from_none], obj.get("totalResults"))
        return GetScimV2GroupsResponse(items_per_page, resources, schemas, start_index, total_results)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.items_per_page is not None:
            result["itemsPerPage"] = from_union([to_float, from_none], self.items_per_page)
        if self.resources is not None:
            result["Resources"] = from_union([lambda x: from_list(lambda x: to_class(ScimGroupResource, x), x), from_none], self.resources)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.start_index is not None:
            result["startIndex"] = from_union([to_float, from_none], self.start_index)
        if self.total_results is not None:
            result["totalResults"] = from_union([to_float, from_none], self.total_results)
        return result


class GetScimV2GroupsResponse400:
    detail: Optional[str]
    schemas: Optional[List[str]]
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2GroupsResponse400(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2GroupsResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2GroupsResponse401(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2GroupsResponse403:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2GroupsResponse403(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2GroupsResponse429:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[float]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[float]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsResponse429':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_float, from_none], obj.get("status"))
        return GetScimV2GroupsResponse429(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        return result


class GetScimV2GroupsResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2GroupsResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2GroupsResponse500(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2ResourceTypesResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ResourceTypesResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetScimV2ResourceTypesResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetScimV2ResourceTypesResponse401:
    error: Optional[GetScimV2ResourceTypesResponse401Error]

    def __init__(self, error: Optional[GetScimV2ResourceTypesResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ResourceTypesResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetScimV2ResourceTypesResponse401Error.from_dict, from_none], obj.get("error"))
        return GetScimV2ResourceTypesResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetScimV2ResourceTypesResponse401Error, x), from_none], self.error)
        return result


class GetScimV2ResourceTypesResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ResourceTypesResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2ResourceTypesResponse500(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2ResourceTypesResponseItemSchemaExtensionsItem:
    """If true, the resource must include this schema extension."""
    required: Optional[bool]
    """The resource extension's URI."""
    schema: Optional[str]

    def __init__(self, required: Optional[bool], schema: Optional[str]) -> None:
        self.required = required
        self.schema = schema

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ResourceTypesResponseItemSchemaExtensionsItem':
        assert isinstance(obj, dict)
        required = from_union([from_bool, from_none], obj.get("required"))
        schema = from_union([from_str, from_none], obj.get("schema"))
        return GetScimV2ResourceTypesResponseItemSchemaExtensionsItem(required, schema)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.required is not None:
            result["required"] = from_union([from_bool, from_none], self.required)
        if self.schema is not None:
            result["schema"] = from_union([from_str, from_none], self.schema)
        return result


class GetScimV2ResourceTypesResponseItem:
    """The resource's description."""
    description: Optional[str]
    """The resource's endpoint."""
    endpoint: Optional[str]
    """The resource's ID."""
    id: Optional[str]
    """The resource's friendly name."""
    name: Optional[str]
    """The resource's schema URI."""
    schema: Optional[str]
    """Information about the resource's schema extensions."""
    schema_extensions: Optional[List[GetScimV2ResourceTypesResponseItemSchemaExtensionsItem]]
    """A list of SCIM schema resource URIs."""
    schemas: Optional[List[str]]

    def __init__(self, description: Optional[str], endpoint: Optional[str], id: Optional[str], name: Optional[str], schema: Optional[str], schema_extensions: Optional[List[GetScimV2ResourceTypesResponseItemSchemaExtensionsItem]], schemas: Optional[List[str]]) -> None:
        self.description = description
        self.endpoint = endpoint
        self.id = id
        self.name = name
        self.schema = schema
        self.schema_extensions = schema_extensions
        self.schemas = schemas

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ResourceTypesResponseItem':
        assert isinstance(obj, dict)
        description = from_union([from_str, from_none], obj.get("description"))
        endpoint = from_union([from_str, from_none], obj.get("endpoint"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        schema = from_union([from_str, from_none], obj.get("schema"))
        schema_extensions = from_union([lambda x: from_list(GetScimV2ResourceTypesResponseItemSchemaExtensionsItem.from_dict, x), from_none], obj.get("schemaExtensions"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        return GetScimV2ResourceTypesResponseItem(description, endpoint, id, name, schema, schema_extensions, schemas)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.endpoint is not None:
            result["endpoint"] = from_union([from_str, from_none], self.endpoint)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.schema is not None:
            result["schema"] = from_union([from_str, from_none], self.schema)
        if self.schema_extensions is not None:
            result["schemaExtensions"] = from_union([lambda x: from_list(lambda x: to_class(GetScimV2ResourceTypesResponseItemSchemaExtensionsItem, x), x), from_none], self.schema_extensions)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        return result


class GetScimV2ServiceProviderConfigResponseAuthenticationSchemesItem:
    """Information about the scheme."""
    """The scheme's description."""
    description: Optional[str]
    """The scheme's friendly name."""
    name: Optional[str]
    """A link to the scheme's specification documentation."""
    spec_uri: Optional[str]
    """The scheme's type."""
    type: Optional[str]

    def __init__(self, description: Optional[str], name: Optional[str], spec_uri: Optional[str], type: Optional[str]) -> None:
        self.description = description
        self.name = name
        self.spec_uri = spec_uri
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ServiceProviderConfigResponseAuthenticationSchemesItem':
        assert isinstance(obj, dict)
        description = from_union([from_str, from_none], obj.get("description"))
        name = from_union([from_str, from_none], obj.get("name"))
        spec_uri = from_union([from_str, from_none], obj.get("specUri"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetScimV2ServiceProviderConfigResponseAuthenticationSchemesItem(description, name, spec_uri, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.spec_uri is not None:
            result["specUri"] = from_union([from_str, from_none], self.spec_uri)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetScimV2ServiceProviderConfigResponseBulk:
    max_operations: Optional[float]
    max_payload_size: Optional[float]
    supported: Optional[bool]

    def __init__(self, max_operations: Optional[float], max_payload_size: Optional[float], supported: Optional[bool]) -> None:
        self.max_operations = max_operations
        self.max_payload_size = max_payload_size
        self.supported = supported

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ServiceProviderConfigResponseBulk':
        assert isinstance(obj, dict)
        max_operations = from_union([from_float, from_none], obj.get("maxOperations"))
        max_payload_size = from_union([from_float, from_none], obj.get("maxPayloadSize"))
        supported = from_union([from_bool, from_none], obj.get("supported"))
        return GetScimV2ServiceProviderConfigResponseBulk(max_operations, max_payload_size, supported)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.max_operations is not None:
            result["maxOperations"] = from_union([to_float, from_none], self.max_operations)
        if self.max_payload_size is not None:
            result["maxPayloadSize"] = from_union([to_float, from_none], self.max_payload_size)
        if self.supported is not None:
            result["supported"] = from_union([from_bool, from_none], self.supported)
        return result


class GetScimV2ServiceProviderConfigResponseChangePassword:
    supported: Optional[bool]

    def __init__(self, supported: Optional[bool]) -> None:
        self.supported = supported

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ServiceProviderConfigResponseChangePassword':
        assert isinstance(obj, dict)
        supported = from_union([from_bool, from_none], obj.get("supported"))
        return GetScimV2ServiceProviderConfigResponseChangePassword(supported)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.supported is not None:
            result["supported"] = from_union([from_bool, from_none], self.supported)
        return result


class GetScimV2ServiceProviderConfigResponseEtag:
    supported: Optional[bool]

    def __init__(self, supported: Optional[bool]) -> None:
        self.supported = supported

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ServiceProviderConfigResponseEtag':
        assert isinstance(obj, dict)
        supported = from_union([from_bool, from_none], obj.get("supported"))
        return GetScimV2ServiceProviderConfigResponseEtag(supported)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.supported is not None:
            result["supported"] = from_union([from_bool, from_none], self.supported)
        return result


class GetScimV2ServiceProviderConfigResponseFilter:
    max_results: Optional[float]
    supported: Optional[bool]

    def __init__(self, max_results: Optional[float], supported: Optional[bool]) -> None:
        self.max_results = max_results
        self.supported = supported

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ServiceProviderConfigResponseFilter':
        assert isinstance(obj, dict)
        max_results = from_union([from_float, from_none], obj.get("maxResults"))
        supported = from_union([from_bool, from_none], obj.get("supported"))
        return GetScimV2ServiceProviderConfigResponseFilter(max_results, supported)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.max_results is not None:
            result["maxResults"] = from_union([to_float, from_none], self.max_results)
        if self.supported is not None:
            result["supported"] = from_union([from_bool, from_none], self.supported)
        return result


class GetScimV2ServiceProviderConfigResponseMeta:
    """The response's non-standard meta information."""
    location: Optional[str]
    resource_type: Optional[str]

    def __init__(self, location: Optional[str], resource_type: Optional[str]) -> None:
        self.location = location
        self.resource_type = resource_type

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ServiceProviderConfigResponseMeta':
        assert isinstance(obj, dict)
        location = from_union([from_str, from_none], obj.get("location"))
        resource_type = from_union([from_str, from_none], obj.get("resourceType"))
        return GetScimV2ServiceProviderConfigResponseMeta(location, resource_type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.location is not None:
            result["location"] = from_union([from_str, from_none], self.location)
        if self.resource_type is not None:
            result["resourceType"] = from_union([from_str, from_none], self.resource_type)
        return result


class GetScimV2ServiceProviderConfigResponsePatch:
    supported: Optional[bool]

    def __init__(self, supported: Optional[bool]) -> None:
        self.supported = supported

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ServiceProviderConfigResponsePatch':
        assert isinstance(obj, dict)
        supported = from_union([from_bool, from_none], obj.get("supported"))
        return GetScimV2ServiceProviderConfigResponsePatch(supported)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.supported is not None:
            result["supported"] = from_union([from_bool, from_none], self.supported)
        return result


class GetScimV2ServiceProviderConfigResponseSort:
    supported: Optional[bool]

    def __init__(self, supported: Optional[bool]) -> None:
        self.supported = supported

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ServiceProviderConfigResponseSort':
        assert isinstance(obj, dict)
        supported = from_union([from_bool, from_none], obj.get("supported"))
        return GetScimV2ServiceProviderConfigResponseSort(supported)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.supported is not None:
            result["supported"] = from_union([from_bool, from_none], self.supported)
        return result


class GetScimV2ServiceProviderConfigResponse:
    """A list of authentication schemes."""
    authentication_schemes: Optional[List[GetScimV2ServiceProviderConfigResponseAuthenticationSchemesItem]]
    bulk: Optional[GetScimV2ServiceProviderConfigResponseBulk]
    change_password: Optional[GetScimV2ServiceProviderConfigResponseChangePassword]
    """A link to the URI's documentation."""
    documentation_uri: Optional[str]
    etag: Optional[GetScimV2ServiceProviderConfigResponseEtag]
    filter: Optional[GetScimV2ServiceProviderConfigResponseFilter]
    """The response's non-standard meta information."""
    meta: Optional[GetScimV2ServiceProviderConfigResponseMeta]
    patch: Optional[GetScimV2ServiceProviderConfigResponsePatch]
    """A list of schema resource URIs."""
    schemas: Optional[List[str]]
    sort: Optional[GetScimV2ServiceProviderConfigResponseSort]

    def __init__(self, authentication_schemes: Optional[List[GetScimV2ServiceProviderConfigResponseAuthenticationSchemesItem]], bulk: Optional[GetScimV2ServiceProviderConfigResponseBulk], change_password: Optional[GetScimV2ServiceProviderConfigResponseChangePassword], documentation_uri: Optional[str], etag: Optional[GetScimV2ServiceProviderConfigResponseEtag], filter: Optional[GetScimV2ServiceProviderConfigResponseFilter], meta: Optional[GetScimV2ServiceProviderConfigResponseMeta], patch: Optional[GetScimV2ServiceProviderConfigResponsePatch], schemas: Optional[List[str]], sort: Optional[GetScimV2ServiceProviderConfigResponseSort]) -> None:
        self.authentication_schemes = authentication_schemes
        self.bulk = bulk
        self.change_password = change_password
        self.documentation_uri = documentation_uri
        self.etag = etag
        self.filter = filter
        self.meta = meta
        self.patch = patch
        self.schemas = schemas
        self.sort = sort

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ServiceProviderConfigResponse':
        assert isinstance(obj, dict)
        authentication_schemes = from_union([lambda x: from_list(GetScimV2ServiceProviderConfigResponseAuthenticationSchemesItem.from_dict, x), from_none], obj.get("authenticationSchemes"))
        bulk = from_union([GetScimV2ServiceProviderConfigResponseBulk.from_dict, from_none], obj.get("bulk"))
        change_password = from_union([GetScimV2ServiceProviderConfigResponseChangePassword.from_dict, from_none], obj.get("changePassword"))
        documentation_uri = from_union([from_str, from_none], obj.get("documentationUri"))
        etag = from_union([GetScimV2ServiceProviderConfigResponseEtag.from_dict, from_none], obj.get("etag"))
        filter = from_union([GetScimV2ServiceProviderConfigResponseFilter.from_dict, from_none], obj.get("filter"))
        meta = from_union([GetScimV2ServiceProviderConfigResponseMeta.from_dict, from_none], obj.get("meta"))
        patch = from_union([GetScimV2ServiceProviderConfigResponsePatch.from_dict, from_none], obj.get("patch"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        sort = from_union([GetScimV2ServiceProviderConfigResponseSort.from_dict, from_none], obj.get("sort"))
        return GetScimV2ServiceProviderConfigResponse(authentication_schemes, bulk, change_password, documentation_uri, etag, filter, meta, patch, schemas, sort)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.authentication_schemes is not None:
            result["authenticationSchemes"] = from_union([lambda x: from_list(lambda x: to_class(GetScimV2ServiceProviderConfigResponseAuthenticationSchemesItem, x), x), from_none], self.authentication_schemes)
        if self.bulk is not None:
            result["bulk"] = from_union([lambda x: to_class(GetScimV2ServiceProviderConfigResponseBulk, x), from_none], self.bulk)
        if self.change_password is not None:
            result["changePassword"] = from_union([lambda x: to_class(GetScimV2ServiceProviderConfigResponseChangePassword, x), from_none], self.change_password)
        if self.documentation_uri is not None:
            result["documentationUri"] = from_union([from_str, from_none], self.documentation_uri)
        if self.etag is not None:
            result["etag"] = from_union([lambda x: to_class(GetScimV2ServiceProviderConfigResponseEtag, x), from_none], self.etag)
        if self.filter is not None:
            result["filter"] = from_union([lambda x: to_class(GetScimV2ServiceProviderConfigResponseFilter, x), from_none], self.filter)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(GetScimV2ServiceProviderConfigResponseMeta, x), from_none], self.meta)
        if self.patch is not None:
            result["patch"] = from_union([lambda x: to_class(GetScimV2ServiceProviderConfigResponsePatch, x), from_none], self.patch)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.sort is not None:
            result["sort"] = from_union([lambda x: to_class(GetScimV2ServiceProviderConfigResponseSort, x), from_none], self.sort)
        return result


class GetScimV2ServiceProviderConfigResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ServiceProviderConfigResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2ServiceProviderConfigResponse401(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2ServiceProviderConfigResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2ServiceProviderConfigResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2ServiceProviderConfigResponse500(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class ScimUserResourceMeta:
    """The response's non-standard meta information."""
    """The date and time at which the team member was created."""
    created: Optional[str]
    """The date and time at which the team member was last modified."""
    last_modified: Optional[str]
    """The resource type."""
    resource_type: Optional[str]

    def __init__(self, created: Optional[str], last_modified: Optional[str], resource_type: Optional[str]) -> None:
        self.created = created
        self.last_modified = last_modified
        self.resource_type = resource_type

    @staticmethod
    def from_dict(obj: Any) -> 'ScimUserResourceMeta':
        assert isinstance(obj, dict)
        created = from_union([from_str, from_none], obj.get("created"))
        last_modified = from_union([from_str, from_none], obj.get("lastModified"))
        resource_type = from_union([from_str, from_none], obj.get("resourceType"))
        return ScimUserResourceMeta(created, last_modified, resource_type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created is not None:
            result["created"] = from_union([from_str, from_none], self.created)
        if self.last_modified is not None:
            result["lastModified"] = from_union([from_str, from_none], self.last_modified)
        if self.resource_type is not None:
            result["resourceType"] = from_union([from_str, from_none], self.resource_type)
        return result


class ScimUserResourceName:
    """Information about the Postman team member."""
    """The team member's last name."""
    family_name: Optional[str]
    """The team member's first name."""
    given_name: Optional[str]

    def __init__(self, family_name: Optional[str], given_name: Optional[str]) -> None:
        self.family_name = family_name
        self.given_name = given_name

    @staticmethod
    def from_dict(obj: Any) -> 'ScimUserResourceName':
        assert isinstance(obj, dict)
        family_name = from_union([from_str, from_none], obj.get("familyName"))
        given_name = from_union([from_str, from_none], obj.get("givenName"))
        return ScimUserResourceName(family_name, given_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.family_name is not None:
            result["familyName"] = from_union([from_str, from_none], self.family_name)
        if self.given_name is not None:
            result["givenName"] = from_union([from_str, from_none], self.given_name)
        return result


class ScimUserResource:
    """The SCIM user resource object."""
    """If true, the team member is active."""
    active: Optional[bool]
    """The team member's external ID."""
    external_id: Optional[str]
    """The team member's SCIM ID."""
    id: Optional[str]
    """The response's non-standard meta information."""
    meta: Optional[ScimUserResourceMeta]
    """Information about the Postman team member."""
    name: Optional[ScimUserResourceName]
    """A list of schema resource URIs."""
    schemas: Optional[List[str]]
    """The team member's SCIM username."""
    user_name: Optional[str]

    def __init__(self, active: Optional[bool], external_id: Optional[str], id: Optional[str], meta: Optional[ScimUserResourceMeta], name: Optional[ScimUserResourceName], schemas: Optional[List[str]], user_name: Optional[str]) -> None:
        self.active = active
        self.external_id = external_id
        self.id = id
        self.meta = meta
        self.name = name
        self.schemas = schemas
        self.user_name = user_name

    @staticmethod
    def from_dict(obj: Any) -> 'ScimUserResource':
        assert isinstance(obj, dict)
        active = from_union([from_bool, from_none], obj.get("active"))
        external_id = from_union([from_str, from_none], obj.get("externalId"))
        id = from_union([from_str, from_none], obj.get("id"))
        meta = from_union([ScimUserResourceMeta.from_dict, from_none], obj.get("meta"))
        name = from_union([ScimUserResourceName.from_dict, from_none], obj.get("name"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        user_name = from_union([from_str, from_none], obj.get("userName"))
        return ScimUserResource(active, external_id, id, meta, name, schemas, user_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.active is not None:
            result["active"] = from_union([from_bool, from_none], self.active)
        if self.external_id is not None:
            result["externalId"] = from_union([from_str, from_none], self.external_id)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(ScimUserResourceMeta, x), from_none], self.meta)
        if self.name is not None:
            result["name"] = from_union([lambda x: to_class(ScimUserResourceName, x), from_none], self.name)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.user_name is not None:
            result["userName"] = from_union([from_str, from_none], self.user_name)
        return result


class GetScimV2UsersResponse:
    """The number of items per response page."""
    items_per_page: Optional[float]
    """A list of user resources."""
    resources: Optional[List[ScimUserResource]]
    schemas: Optional[List[str]]
    """The index entry by which the returned results begin."""
    start_index: Optional[float]
    """The total number of results found."""
    total_results: Optional[float]

    def __init__(self, items_per_page: Optional[float], resources: Optional[List[ScimUserResource]], schemas: Optional[List[str]], start_index: Optional[float], total_results: Optional[float]) -> None:
        self.items_per_page = items_per_page
        self.resources = resources
        self.schemas = schemas
        self.start_index = start_index
        self.total_results = total_results

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersResponse':
        assert isinstance(obj, dict)
        items_per_page = from_union([from_float, from_none], obj.get("itemsPerPage"))
        resources = from_union([lambda x: from_list(ScimUserResource.from_dict, x), from_none], obj.get("Resources"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        start_index = from_union([from_float, from_none], obj.get("startIndex"))
        total_results = from_union([from_float, from_none], obj.get("totalResults"))
        return GetScimV2UsersResponse(items_per_page, resources, schemas, start_index, total_results)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.items_per_page is not None:
            result["itemsPerPage"] = from_union([to_float, from_none], self.items_per_page)
        if self.resources is not None:
            result["Resources"] = from_union([lambda x: from_list(lambda x: to_class(ScimUserResource, x), x), from_none], self.resources)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.start_index is not None:
            result["startIndex"] = from_union([to_float, from_none], self.start_index)
        if self.total_results is not None:
            result["totalResults"] = from_union([to_float, from_none], self.total_results)
        return result


class GetScimV2UsersResponse400:
    detail: Optional[str]
    schemas: Optional[List[str]]
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2UsersResponse400(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2UsersResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2UsersResponse401(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2UsersResponse403:
    detail: Optional[str]
    schemas: Optional[List[str]]
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2UsersResponse403(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2UsersResponse429:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[float]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[float]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersResponse429':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_float, from_none], obj.get("status"))
        return GetScimV2UsersResponse429(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        return result


class GetScimV2UsersResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2UsersResponse500(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2UsersUserIDResponseMeta:
    """The response's non-standard meta information."""
    """The date and time at which the team member was created."""
    created: Optional[str]
    """The date and time at which the team member was last modified."""
    last_modified: Optional[str]
    """The resource type."""
    resource_type: Optional[str]

    def __init__(self, created: Optional[str], last_modified: Optional[str], resource_type: Optional[str]) -> None:
        self.created = created
        self.last_modified = last_modified
        self.resource_type = resource_type

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersUserIDResponseMeta':
        assert isinstance(obj, dict)
        created = from_union([from_str, from_none], obj.get("created"))
        last_modified = from_union([from_str, from_none], obj.get("lastModified"))
        resource_type = from_union([from_str, from_none], obj.get("resourceType"))
        return GetScimV2UsersUserIDResponseMeta(created, last_modified, resource_type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created is not None:
            result["created"] = from_union([from_str, from_none], self.created)
        if self.last_modified is not None:
            result["lastModified"] = from_union([from_str, from_none], self.last_modified)
        if self.resource_type is not None:
            result["resourceType"] = from_union([from_str, from_none], self.resource_type)
        return result


class GetScimV2UsersUserIDResponseName:
    """Information about the Postman team member."""
    """The team member's last name."""
    family_name: Optional[str]
    """The team member's first name."""
    given_name: Optional[str]

    def __init__(self, family_name: Optional[str], given_name: Optional[str]) -> None:
        self.family_name = family_name
        self.given_name = given_name

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersUserIDResponseName':
        assert isinstance(obj, dict)
        family_name = from_union([from_str, from_none], obj.get("familyName"))
        given_name = from_union([from_str, from_none], obj.get("givenName"))
        return GetScimV2UsersUserIDResponseName(family_name, given_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.family_name is not None:
            result["familyName"] = from_union([from_str, from_none], self.family_name)
        if self.given_name is not None:
            result["givenName"] = from_union([from_str, from_none], self.given_name)
        return result


class GetScimV2UsersUserIDResponse:
    """If true, the team member is active."""
    active: Optional[bool]
    """The team member's external ID."""
    external_id: Optional[str]
    """The team member's SCIM ID."""
    id: Optional[str]
    """The response's non-standard meta information."""
    meta: Optional[GetScimV2UsersUserIDResponseMeta]
    """Information about the Postman team member."""
    name: Optional[GetScimV2UsersUserIDResponseName]
    """A list of schema resource URIs."""
    schemas: Optional[List[str]]
    """The team member's SCIM username."""
    user_name: Optional[str]

    def __init__(self, active: Optional[bool], external_id: Optional[str], id: Optional[str], meta: Optional[GetScimV2UsersUserIDResponseMeta], name: Optional[GetScimV2UsersUserIDResponseName], schemas: Optional[List[str]], user_name: Optional[str]) -> None:
        self.active = active
        self.external_id = external_id
        self.id = id
        self.meta = meta
        self.name = name
        self.schemas = schemas
        self.user_name = user_name

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersUserIDResponse':
        assert isinstance(obj, dict)
        active = from_union([from_bool, from_none], obj.get("active"))
        external_id = from_union([from_str, from_none], obj.get("externalId"))
        id = from_union([from_str, from_none], obj.get("id"))
        meta = from_union([GetScimV2UsersUserIDResponseMeta.from_dict, from_none], obj.get("meta"))
        name = from_union([GetScimV2UsersUserIDResponseName.from_dict, from_none], obj.get("name"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        user_name = from_union([from_str, from_none], obj.get("userName"))
        return GetScimV2UsersUserIDResponse(active, external_id, id, meta, name, schemas, user_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.active is not None:
            result["active"] = from_union([from_bool, from_none], self.active)
        if self.external_id is not None:
            result["externalId"] = from_union([from_str, from_none], self.external_id)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(GetScimV2UsersUserIDResponseMeta, x), from_none], self.meta)
        if self.name is not None:
            result["name"] = from_union([lambda x: to_class(GetScimV2UsersUserIDResponseName, x), from_none], self.name)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.user_name is not None:
            result["userName"] = from_union([from_str, from_none], self.user_name)
        return result


class GetScimV2UsersUserIDResponse400:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersUserIDResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2UsersUserIDResponse400(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2UsersUserIDResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersUserIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2UsersUserIDResponse401(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2UsersUserIDResponse403:
    """Information about the error."""
    detail: Optional[str]
    schemas: Optional[List[str]]
    """The error status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersUserIDResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2UsersUserIDResponse403(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2UsersUserIDResponse404:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersUserIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2UsersUserIDResponse404(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class GetScimV2UsersUserIDResponse429:
    """Information about the error."""
    detail: Optional[str]
    schemas: Optional[List[str]]
    """The error status code."""
    status: Optional[float]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[float]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersUserIDResponse429':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_float, from_none], obj.get("status"))
        return GetScimV2UsersUserIDResponse429(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        return result


class GetScimV2UsersUserIDResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'GetScimV2UsersUserIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return GetScimV2UsersUserIDResponse500(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class DatumType(Enum):
    """The origin of the secret type:
    - `DEFAULT`  Supported by default in Postman.
    - `TEAM_REGEX`  A custom regex added by an Admin or Super Admin user in the **Configure
    Alerts** section of the [**Team
    Settings**](https://learning.postman.com/docs/administration/team-settings/) interface.
    """
    DEFAULT = "DEFAULT"
    TEAM_REGEX = "TEAM_REGEX"


class GetSecretTypesResponseDataItem:
    """Information about the secret type."""
    """The ID of the secret type."""
    id: Optional[str]
    """The name of the secret type."""
    name: Optional[str]
    """The origin of the secret type:
    - `DEFAULT`  Supported by default in Postman.
    - `TEAM_REGEX`  A custom regex added by an Admin or Super Admin user in the **Configure
    Alerts** section of the [**Team
    Settings**](https://learning.postman.com/docs/administration/team-settings/) interface.
    """
    type: Optional[DatumType]

    def __init__(self, id: Optional[str], name: Optional[str], type: Optional[DatumType]) -> None:
        self.id = id
        self.name = name
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetSecretTypesResponseDataItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        type = from_union([DatumType, from_none], obj.get("type"))
        return GetSecretTypesResponseDataItem(id, name, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(DatumType, x), from_none], self.type)
        return result


class GetSecretTypesResponseMeta:
    """The total number of supported secrets."""
    total: Optional[float]

    def __init__(self, total: Optional[float]) -> None:
        self.total = total

    @staticmethod
    def from_dict(obj: Any) -> 'GetSecretTypesResponseMeta':
        assert isinstance(obj, dict)
        total = from_union([from_float, from_none], obj.get("total"))
        return GetSecretTypesResponseMeta(total)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.total is not None:
            result["total"] = from_union([to_float, from_none], self.total)
        return result


class GetSecretTypesResponse:
    data: Optional[List[GetSecretTypesResponseDataItem]]
    meta: Optional[GetSecretTypesResponseMeta]

    def __init__(self, data: Optional[List[GetSecretTypesResponseDataItem]], meta: Optional[GetSecretTypesResponseMeta]) -> None:
        self.data = data
        self.meta = meta

    @staticmethod
    def from_dict(obj: Any) -> 'GetSecretTypesResponse':
        assert isinstance(obj, dict)
        data = from_union([lambda x: from_list(GetSecretTypesResponseDataItem.from_dict, x), from_none], obj.get("data"))
        meta = from_union([GetSecretTypesResponseMeta.from_dict, from_none], obj.get("meta"))
        return GetSecretTypesResponse(data, meta)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: from_list(lambda x: to_class(GetSecretTypesResponseDataItem, x), x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(GetSecretTypesResponseMeta, x), from_none], self.meta)
        return result


class GetSecretTypesResponse401:
    """The instance identifying the specific occurrence of the problem."""
    instance: Optional[str]
    """The HTTP status code generated by the origin server."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetSecretTypesResponse401':
        assert isinstance(obj, dict)
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetSecretTypesResponse401(instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetSecretTypesResponse403:
    """The instance identifying the specific occurrence of the problem."""
    instance: Optional[str]
    """The HTTP status code generated by the origin server."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetSecretTypesResponse403':
        assert isinstance(obj, dict)
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetSecretTypesResponse403(instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetSecretTypesResponse500:
    """The instance identifying the specific occurrence of the problem."""
    instance: Optional[str]
    """The HTTP status code generated by the origin server."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetSecretTypesResponse500':
        assert isinstance(obj, dict)
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetSecretTypesResponse500(instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetTagsSlugEntitiesResponseDataEntitiesItem:
    """The element's unique ID."""
    entity_id: Optional[str]
    """The type of Postman element."""
    entity_type: Optional[EntityTypeEnum]

    def __init__(self, entity_id: Optional[str], entity_type: Optional[EntityTypeEnum]) -> None:
        self.entity_id = entity_id
        self.entity_type = entity_type

    @staticmethod
    def from_dict(obj: Any) -> 'GetTagsSlugEntitiesResponseDataEntitiesItem':
        assert isinstance(obj, dict)
        entity_id = from_union([from_str, from_none], obj.get("entityId"))
        entity_type = from_union([EntityTypeEnum, from_none], obj.get("entityType"))
        return GetTagsSlugEntitiesResponseDataEntitiesItem(entity_id, entity_type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.entity_id is not None:
            result["entityId"] = from_union([from_str, from_none], self.entity_id)
        if self.entity_type is not None:
            result["entityType"] = from_union([lambda x: to_enum(EntityTypeEnum, x), from_none], self.entity_type)
        return result


class GetTagsSlugEntitiesResponseData:
    """An object containing the paginated elements."""
    """A list of the Postman elements that contain the given tag."""
    entities: List[GetTagsSlugEntitiesResponseDataEntitiesItem]

    def __init__(self, entities: List[GetTagsSlugEntitiesResponseDataEntitiesItem]) -> None:
        self.entities = entities

    @staticmethod
    def from_dict(obj: Any) -> 'GetTagsSlugEntitiesResponseData':
        assert isinstance(obj, dict)
        entities = from_list(GetTagsSlugEntitiesResponseDataEntitiesItem.from_dict, obj.get("entities"))
        return GetTagsSlugEntitiesResponseData(entities)

    def to_dict(self) -> dict:
        result: dict = {}
        result["entities"] = from_list(lambda x: to_class(GetTagsSlugEntitiesResponseDataEntitiesItem, x), self.entities)
        return result


class GetTagsSlugEntitiesResponseMeta:
    """The response's pagination information."""
    """The number of tagged elements returned in the response."""
    count: int
    """The pagination cursor that points to the next record in the results set."""
    next_cursor: Optional[str]

    def __init__(self, count: int, next_cursor: Optional[str]) -> None:
        self.count = count
        self.next_cursor = next_cursor

    @staticmethod
    def from_dict(obj: Any) -> 'GetTagsSlugEntitiesResponseMeta':
        assert isinstance(obj, dict)
        count = from_int(obj.get("count"))
        next_cursor = from_union([from_str, from_none], obj.get("nextCursor"))
        return GetTagsSlugEntitiesResponseMeta(count, next_cursor)

    def to_dict(self) -> dict:
        result: dict = {}
        result["count"] = from_int(self.count)
        if self.next_cursor is not None:
            result["nextCursor"] = from_union([from_str, from_none], self.next_cursor)
        return result


class GetTagsSlugEntitiesResponse:
    """An object containing the paginated elements."""
    data: Optional[GetTagsSlugEntitiesResponseData]
    """The response's pagination information."""
    meta: Optional[GetTagsSlugEntitiesResponseMeta]

    def __init__(self, data: Optional[GetTagsSlugEntitiesResponseData], meta: Optional[GetTagsSlugEntitiesResponseMeta]) -> None:
        self.data = data
        self.meta = meta

    @staticmethod
    def from_dict(obj: Any) -> 'GetTagsSlugEntitiesResponse':
        assert isinstance(obj, dict)
        data = from_union([GetTagsSlugEntitiesResponseData.from_dict, from_none], obj.get("data"))
        meta = from_union([GetTagsSlugEntitiesResponseMeta.from_dict, from_none], obj.get("meta"))
        return GetTagsSlugEntitiesResponse(data, meta)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: to_class(GetTagsSlugEntitiesResponseData, x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(GetTagsSlugEntitiesResponseMeta, x), from_none], self.meta)
        return result


class GetTagsSlugEntitiesResponse400:
    """A short summary of the problem."""
    error: Optional[str]
    """Information about the error."""
    message: Optional[str]
    """The error's HTTP status code."""
    status_code: Optional[int]

    def __init__(self, error: Optional[str], message: Optional[str], status_code: Optional[int]) -> None:
        self.error = error
        self.message = message
        self.status_code = status_code

    @staticmethod
    def from_dict(obj: Any) -> 'GetTagsSlugEntitiesResponse400':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        status_code = from_union([from_int, from_none], obj.get("statusCode"))
        return GetTagsSlugEntitiesResponse400(error, message, status_code)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.status_code is not None:
            result["statusCode"] = from_union([from_int, from_none], self.status_code)
        return result


class GetTagsSlugEntitiesResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetTagsSlugEntitiesResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetTagsSlugEntitiesResponse401(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetTagsSlugEntitiesResponse403:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetTagsSlugEntitiesResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetTagsSlugEntitiesResponse403(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetTagsSlugEntitiesResponse404:
    """Information about the error."""
    detail: Optional[str]
    """The URI reference that identifies the specific occurrence of the problem."""
    instance: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetTagsSlugEntitiesResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetTagsSlugEntitiesResponse404(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetTagsSlugEntitiesResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The URI reference that identifies the specific occurrence of the problem."""
    instance: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetTagsSlugEntitiesResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetTagsSlugEntitiesResponse500(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class VisibilityEnum(Enum):
    """The type of workspace.
    
    The workspace's visibility.
    [Visibility](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/managing-workspaces/#changing-workspace-visibility)
    determines who can access the workspace:
    
    - `personal`  Only you can access the workspace.
    - `team`  All team members can access the workspace.
    - `private`  Only invited team members can access the workspace ([Professional and
    Enterprise plans only](https://www.postman.com/pricing)).
    - `public`  Everyone can access the workspace.
    - `partner`  Only invited team members and
    [partners](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/partner-workspaces/)
    can access the workspace ([Enterprise Ultimate plans](https://www.postman.com/pricing)
    only).
    
    
    The type of workspace:
    
    - `personal`
    - `private`  Private workspaces are available on Postman [Professional and Enterprise
    plans](https://www.postman.com/pricing).
    - `public`
    - `team`
    - `partner`  [Partner
    Workspaces](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/partner-workspaces/)
    are available on Postman [Enterprise Ultimate plans](https://www.postman.com/pricing).
    """
    PARTNER = "partner"
    PERSONAL = "personal"
    PRIVATE = "private"
    PUBLIC = "public"
    TEAM = "team"


class GetWorkspacesResponseWorkspacesItem:
    """Information about the workspace."""
    """The workspace's ID."""
    id: Optional[str]
    """The workspace's name."""
    name: Optional[str]
    """The type of workspace."""
    type: Optional[VisibilityEnum]
    """The workspace's visibility.
    [Visibility](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/managing-workspaces/#changing-workspace-visibility)
    determines who can access the workspace:
    
    - `personal`  Only you can access the workspace.
    - `team`  All team members can access the workspace.
    - `private`  Only invited team members can access the workspace ([Professional and
    Enterprise plans only](https://www.postman.com/pricing)).
    - `public`  Everyone can access the workspace.
    - `partner`  Only invited team members and
    [partners](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/partner-workspaces/)
    can access the workspace ([Enterprise Ultimate plans](https://www.postman.com/pricing)
    only).
    """
    visibility: Optional[VisibilityEnum]

    def __init__(self, id: Optional[str], name: Optional[str], type: Optional[VisibilityEnum], visibility: Optional[VisibilityEnum]) -> None:
        self.id = id
        self.name = name
        self.type = type
        self.visibility = visibility

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesResponseWorkspacesItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        type = from_union([VisibilityEnum, from_none], obj.get("type"))
        visibility = from_union([VisibilityEnum, from_none], obj.get("visibility"))
        return GetWorkspacesResponseWorkspacesItem(id, name, type, visibility)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(VisibilityEnum, x), from_none], self.type)
        if self.visibility is not None:
            result["visibility"] = from_union([lambda x: to_enum(VisibilityEnum, x), from_none], self.visibility)
        return result


class GetWorkspacesResponse:
    workspaces: Optional[List[GetWorkspacesResponseWorkspacesItem]]

    def __init__(self, workspaces: Optional[List[GetWorkspacesResponseWorkspacesItem]]) -> None:
        self.workspaces = workspaces

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesResponse':
        assert isinstance(obj, dict)
        workspaces = from_union([lambda x: from_list(GetWorkspacesResponseWorkspacesItem.from_dict, x), from_none], obj.get("workspaces"))
        return GetWorkspacesResponse(workspaces)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.workspaces is not None:
            result["workspaces"] = from_union([lambda x: from_list(lambda x: to_class(GetWorkspacesResponseWorkspacesItem, x), x), from_none], self.workspaces)
        return result


class GetWorkspacesResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetWorkspacesResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetWorkspacesResponse401:
    error: Optional[GetWorkspacesResponse401Error]

    def __init__(self, error: Optional[GetWorkspacesResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetWorkspacesResponse401Error.from_dict, from_none], obj.get("error"))
        return GetWorkspacesResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetWorkspacesResponse401Error, x), from_none], self.error)
        return result


class GetWorkspacesResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetWorkspacesResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetWorkspacesResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetWorkspacesResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetWorkspacesResponse500:
    error: Optional[GetWorkspacesResponse500Error]

    def __init__(self, error: Optional[GetWorkspacesResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetWorkspacesResponse500Error.from_dict, from_none], obj.get("error"))
        return GetWorkspacesResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetWorkspacesResponse500Error, x), from_none], self.error)
        return result


class GlobalVariableType(Enum):
    """The [type](https://learning.postman.com/docs/sending-requests/variables/#variable-types)
    of variable.
    """
    DEFAULT = "default"
    SECRET = "secret"


class GlobalVariable:
    """Information about the global variable."""
    """If true, the variable is enabled."""
    enabled: Optional[bool]
    """The variable's name."""
    key: Optional[str]
    """The [type](https://learning.postman.com/docs/sending-requests/variables/#variable-types)
    of variable.
    """
    type: Optional[GlobalVariableType]
    """The variable's value."""
    value: Optional[str]

    def __init__(self, enabled: Optional[bool], key: Optional[str], type: Optional[GlobalVariableType], value: Optional[str]) -> None:
        self.enabled = enabled
        self.key = key
        self.type = type
        self.value = value

    @staticmethod
    def from_dict(obj: Any) -> 'GlobalVariable':
        assert isinstance(obj, dict)
        enabled = from_union([from_bool, from_none], obj.get("enabled"))
        key = from_union([from_str, from_none], obj.get("key"))
        type = from_union([GlobalVariableType, from_none], obj.get("type"))
        value = from_union([from_str, from_none], obj.get("value"))
        return GlobalVariable(enabled, key, type, value)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.enabled is not None:
            result["enabled"] = from_union([from_bool, from_none], self.enabled)
        if self.key is not None:
            result["key"] = from_union([from_str, from_none], self.key)
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(GlobalVariableType, x), from_none], self.type)
        if self.value is not None:
            result["value"] = from_union([from_str, from_none], self.value)
        return result


class GetWorkspacesWorkspaceIDGlobalVariablesResponse:
    """Information about the workspace's global variables."""
    """A list of the workspace's global variables."""
    values: Optional[List[GlobalVariable]]

    def __init__(self, values: Optional[List[GlobalVariable]]) -> None:
        self.values = values

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDGlobalVariablesResponse':
        assert isinstance(obj, dict)
        values = from_union([lambda x: from_list(GlobalVariable.from_dict, x), from_none], obj.get("values"))
        return GetWorkspacesWorkspaceIDGlobalVariablesResponse(values)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.values is not None:
            result["values"] = from_union([lambda x: from_list(lambda x: to_class(GlobalVariable, x), x), from_none], self.values)
        return result


class GetWorkspacesWorkspaceIDGlobalVariablesResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The type of error."""
    title: Optional[str]
    """The generic description for the error's class."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDGlobalVariablesResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetWorkspacesWorkspaceIDGlobalVariablesResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetWorkspacesWorkspaceIDResponseWorkspaceApisItem:
    """Information about the API."""
    """The API's ID."""
    id: Optional[str]
    """The API's name."""
    name: Optional[str]
    """The API's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.name = name
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDResponseWorkspaceApisItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return GetWorkspacesWorkspaceIDResponseWorkspaceApisItem(id, name, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class GetWorkspacesWorkspaceIDResponseWorkspaceCollectionsItem:
    """Information about the collection."""
    """The collection's ID."""
    id: Optional[str]
    """The collection's name."""
    name: Optional[str]
    """The collection's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.name = name
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDResponseWorkspaceCollectionsItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return GetWorkspacesWorkspaceIDResponseWorkspaceCollectionsItem(id, name, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class GetWorkspacesWorkspaceIDResponseWorkspaceEnvironmentsItem:
    """Information about the environment."""
    """The environment's ID."""
    id: Optional[str]
    """The environment's name."""
    name: Optional[str]
    """The environment's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.name = name
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDResponseWorkspaceEnvironmentsItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return GetWorkspacesWorkspaceIDResponseWorkspaceEnvironmentsItem(id, name, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class GetWorkspacesWorkspaceIDResponseWorkspaceMocksItem:
    """Information about the mock server."""
    """If true, the mock server is not active. Mock servers deactivate when a linked collection
    or environment is deleted.
    """
    deactivated: Optional[bool]
    """The mock server's ID."""
    id: Optional[str]
    """The mock server's name."""
    name: Optional[str]
    """The mock server's unique ID."""
    uid: Optional[str]

    def __init__(self, deactivated: Optional[bool], id: Optional[str], name: Optional[str], uid: Optional[str]) -> None:
        self.deactivated = deactivated
        self.id = id
        self.name = name
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDResponseWorkspaceMocksItem':
        assert isinstance(obj, dict)
        deactivated = from_union([from_bool, from_none], obj.get("deactivated"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return GetWorkspacesWorkspaceIDResponseWorkspaceMocksItem(deactivated, id, name, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.deactivated is not None:
            result["deactivated"] = from_union([from_bool, from_none], self.deactivated)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class GetWorkspacesWorkspaceIDResponseWorkspaceMonitorsItem:
    """Information about the monitor."""
    """The monitor's ID."""
    id: Optional[str]
    """The monitor's name."""
    name: Optional[str]
    """The monitor's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.name = name
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDResponseWorkspaceMonitorsItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return GetWorkspacesWorkspaceIDResponseWorkspaceMonitorsItem(id, name, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class GetWorkspacesWorkspaceIDResponseWorkspace:
    """Information about the workspace."""
    """The workspace's APIs."""
    apis: Optional[List[GetWorkspacesWorkspaceIDResponseWorkspaceApisItem]]
    """The workspace's collections."""
    collections: Optional[List[GetWorkspacesWorkspaceIDResponseWorkspaceCollectionsItem]]
    """The date and time at which the workspace was created."""
    created_at: Optional[str]
    """The user ID of the user who created the workspace."""
    created_by: Optional[str]
    """The workspace's description."""
    description: Optional[str]
    """The workspace's environments."""
    environments: Optional[List[GetWorkspacesWorkspaceIDResponseWorkspaceEnvironmentsItem]]
    """The workspace's ID."""
    id: Optional[str]
    """The workspace's mock servers."""
    mocks: Optional[List[GetWorkspacesWorkspaceIDResponseWorkspaceMocksItem]]
    """The workspace's monitors."""
    monitors: Optional[List[GetWorkspacesWorkspaceIDResponseWorkspaceMonitorsItem]]
    """The workspace's name."""
    name: Optional[str]
    """The type of workspace."""
    type: Optional[VisibilityEnum]
    """The date and time at which the workspace was last updated."""
    updated_at: Optional[str]
    """The user ID of the user who last updated the workspace."""
    updated_by: Optional[str]
    """The workspace's visibility.
    [Visibility](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/managing-workspaces/#changing-workspace-visibility)
    determines who can access the workspace:
    
    - `personal`  Only you can access the workspace.
    - `team`  All team members can access the workspace.
    - `private`  Only invited team members can access the workspace ([Professional and
    Enterprise plans only](https://www.postman.com/pricing)).
    - `public`  Everyone can access the workspace.
    - `partner`  Only invited team members and
    [partners](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/partner-workspaces/)
    can access the workspace ([Enterprise Ultimate plans](https://www.postman.com/pricing)
    only).
    """
    visibility: Optional[VisibilityEnum]

    def __init__(self, apis: Optional[List[GetWorkspacesWorkspaceIDResponseWorkspaceApisItem]], collections: Optional[List[GetWorkspacesWorkspaceIDResponseWorkspaceCollectionsItem]], created_at: Optional[str], created_by: Optional[str], description: Optional[str], environments: Optional[List[GetWorkspacesWorkspaceIDResponseWorkspaceEnvironmentsItem]], id: Optional[str], mocks: Optional[List[GetWorkspacesWorkspaceIDResponseWorkspaceMocksItem]], monitors: Optional[List[GetWorkspacesWorkspaceIDResponseWorkspaceMonitorsItem]], name: Optional[str], type: Optional[VisibilityEnum], updated_at: Optional[str], updated_by: Optional[str], visibility: Optional[VisibilityEnum]) -> None:
        self.apis = apis
        self.collections = collections
        self.created_at = created_at
        self.created_by = created_by
        self.description = description
        self.environments = environments
        self.id = id
        self.mocks = mocks
        self.monitors = monitors
        self.name = name
        self.type = type
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.visibility = visibility

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDResponseWorkspace':
        assert isinstance(obj, dict)
        apis = from_union([lambda x: from_list(GetWorkspacesWorkspaceIDResponseWorkspaceApisItem.from_dict, x), from_none], obj.get("apis"))
        collections = from_union([lambda x: from_list(GetWorkspacesWorkspaceIDResponseWorkspaceCollectionsItem.from_dict, x), from_none], obj.get("collections"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_str, from_none], obj.get("createdBy"))
        description = from_union([from_str, from_none], obj.get("description"))
        environments = from_union([lambda x: from_list(GetWorkspacesWorkspaceIDResponseWorkspaceEnvironmentsItem.from_dict, x), from_none], obj.get("environments"))
        id = from_union([from_str, from_none], obj.get("id"))
        mocks = from_union([lambda x: from_list(GetWorkspacesWorkspaceIDResponseWorkspaceMocksItem.from_dict, x), from_none], obj.get("mocks"))
        monitors = from_union([lambda x: from_list(GetWorkspacesWorkspaceIDResponseWorkspaceMonitorsItem.from_dict, x), from_none], obj.get("monitors"))
        name = from_union([from_str, from_none], obj.get("name"))
        type = from_union([VisibilityEnum, from_none], obj.get("type"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_str, from_none], obj.get("updatedBy"))
        visibility = from_union([VisibilityEnum, from_none], obj.get("visibility"))
        return GetWorkspacesWorkspaceIDResponseWorkspace(apis, collections, created_at, created_by, description, environments, id, mocks, monitors, name, type, updated_at, updated_by, visibility)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.apis is not None:
            result["apis"] = from_union([lambda x: from_list(lambda x: to_class(GetWorkspacesWorkspaceIDResponseWorkspaceApisItem, x), x), from_none], self.apis)
        if self.collections is not None:
            result["collections"] = from_union([lambda x: from_list(lambda x: to_class(GetWorkspacesWorkspaceIDResponseWorkspaceCollectionsItem, x), x), from_none], self.collections)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_str, from_none], self.created_by)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.environments is not None:
            result["environments"] = from_union([lambda x: from_list(lambda x: to_class(GetWorkspacesWorkspaceIDResponseWorkspaceEnvironmentsItem, x), x), from_none], self.environments)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.mocks is not None:
            result["mocks"] = from_union([lambda x: from_list(lambda x: to_class(GetWorkspacesWorkspaceIDResponseWorkspaceMocksItem, x), x), from_none], self.mocks)
        if self.monitors is not None:
            result["monitors"] = from_union([lambda x: from_list(lambda x: to_class(GetWorkspacesWorkspaceIDResponseWorkspaceMonitorsItem, x), x), from_none], self.monitors)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(VisibilityEnum, x), from_none], self.type)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_str, from_none], self.updated_by)
        if self.visibility is not None:
            result["visibility"] = from_union([lambda x: to_enum(VisibilityEnum, x), from_none], self.visibility)
        return result


class GetWorkspacesWorkspaceIDResponse:
    """Information about the workspace."""
    workspace: Optional[GetWorkspacesWorkspaceIDResponseWorkspace]

    def __init__(self, workspace: Optional[GetWorkspacesWorkspaceIDResponseWorkspace]) -> None:
        self.workspace = workspace

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDResponse':
        assert isinstance(obj, dict)
        workspace = from_union([GetWorkspacesWorkspaceIDResponseWorkspace.from_dict, from_none], obj.get("workspace"))
        return GetWorkspacesWorkspaceIDResponse(workspace)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.workspace is not None:
            result["workspace"] = from_union([lambda x: to_class(GetWorkspacesWorkspaceIDResponseWorkspace, x), from_none], self.workspace)
        return result


class GetWorkspacesWorkspaceIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetWorkspacesWorkspaceIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetWorkspacesWorkspaceIDResponse401:
    error: Optional[GetWorkspacesWorkspaceIDResponse401Error]

    def __init__(self, error: Optional[GetWorkspacesWorkspaceIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([GetWorkspacesWorkspaceIDResponse401Error.from_dict, from_none], obj.get("error"))
        return GetWorkspacesWorkspaceIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetWorkspacesWorkspaceIDResponse401Error, x), from_none], self.error)
        return result


class GetWorkspacesWorkspaceIDResponse404Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]
    """The error's HTTP status code."""
    status_code: Optional[float]

    def __init__(self, message: Optional[str], name: Optional[str], status_code: Optional[float]) -> None:
        self.message = message
        self.name = name
        self.status_code = status_code

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDResponse404Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        status_code = from_union([from_float, from_none], obj.get("statusCode"))
        return GetWorkspacesWorkspaceIDResponse404Error(message, name, status_code)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.status_code is not None:
            result["statusCode"] = from_union([to_float, from_none], self.status_code)
        return result


class GetWorkspacesWorkspaceIDResponse404:
    error: Optional[GetWorkspacesWorkspaceIDResponse404Error]

    def __init__(self, error: Optional[GetWorkspacesWorkspaceIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([GetWorkspacesWorkspaceIDResponse404Error.from_dict, from_none], obj.get("error"))
        return GetWorkspacesWorkspaceIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetWorkspacesWorkspaceIDResponse404Error, x), from_none], self.error)
        return result


class GetWorkspacesWorkspaceIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return GetWorkspacesWorkspaceIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class GetWorkspacesWorkspaceIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return GetWorkspacesWorkspaceIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class GetWorkspacesWorkspaceIDResponse500:
    error: Optional[GetWorkspacesWorkspaceIDResponse500Error]

    def __init__(self, error: Optional[GetWorkspacesWorkspaceIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([GetWorkspacesWorkspaceIDResponse500Error.from_dict, from_none], obj.get("error"))
        return GetWorkspacesWorkspaceIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(GetWorkspacesWorkspaceIDResponse500Error, x), from_none], self.error)
        return result


class GetWorkspacesWorkspaceIDTagsResponseTagsItem:
    """Information about the tag."""
    """The tag's ID within a team or individual (non-team) user scope."""
    slug: Optional[str]

    def __init__(self, slug: Optional[str]) -> None:
        self.slug = slug

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDTagsResponseTagsItem':
        assert isinstance(obj, dict)
        slug = from_union([from_str, from_none], obj.get("slug"))
        return GetWorkspacesWorkspaceIDTagsResponseTagsItem(slug)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.slug is not None:
            result["slug"] = from_union([from_str, from_none], self.slug)
        return result


class GetWorkspacesWorkspaceIDTagsResponse:
    """A list of associated tags."""
    tags: Optional[List[GetWorkspacesWorkspaceIDTagsResponseTagsItem]]

    def __init__(self, tags: Optional[List[GetWorkspacesWorkspaceIDTagsResponseTagsItem]]) -> None:
        self.tags = tags

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDTagsResponse':
        assert isinstance(obj, dict)
        tags = from_union([lambda x: from_list(GetWorkspacesWorkspaceIDTagsResponseTagsItem.from_dict, x), from_none], obj.get("tags"))
        return GetWorkspacesWorkspaceIDTagsResponse(tags)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.tags is not None:
            result["tags"] = from_union([lambda x: from_list(lambda x: to_class(GetWorkspacesWorkspaceIDTagsResponseTagsItem, x), x), from_none], self.tags)
        return result


class GetWorkspacesWorkspaceIDTagsResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDTagsResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetWorkspacesWorkspaceIDTagsResponse401(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetWorkspacesWorkspaceIDTagsResponse403:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDTagsResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetWorkspacesWorkspaceIDTagsResponse403(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetWorkspacesWorkspaceIDTagsResponse404:
    """Information about the error."""
    detail: Optional[str]
    """The URI reference that identifies the specific occurrence of the problem."""
    instance: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDTagsResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetWorkspacesWorkspaceIDTagsResponse404(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class GetWorkspacesWorkspaceIDTagsResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The URI reference that identifies the specific occurrence of the problem."""
    instance: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'GetWorkspacesWorkspaceIDTagsResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return GetWorkspacesWorkspaceIDTagsResponse500(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PANElementCreated:
    """Information about the Private API Network element."""
    """The date and time at which the element was added."""
    added_at: Optional[str]
    """The user who added the element."""
    added_by: Optional[int]
    """The date and time at which the element was created."""
    created_at: Optional[str]
    """The user who created the element."""
    created_by: Optional[int]
    """The element's description."""
    description: Optional[str]
    """A list of the element's environments."""
    environments: Optional[List[str]]
    """The element's Postman URL."""
    href: Optional[str]
    """The element's ID or UID."""
    id: Optional[str]
    """The element's name."""
    name: Optional[str]
    """The parent folder's ID."""
    parent_folder_id: Optional[int]
    """The element's summary."""
    summary: Optional[str]
    """The element's type."""
    type: Optional[str]
    """The date and time at which the element was last updated."""
    updated_at: Optional[str]
    """The user who last updated the element."""
    updated_by: Optional[int]

    def __init__(self, added_at: Optional[str], added_by: Optional[int], created_at: Optional[str], created_by: Optional[int], description: Optional[str], environments: Optional[List[str]], href: Optional[str], id: Optional[str], name: Optional[str], parent_folder_id: Optional[int], summary: Optional[str], type: Optional[str], updated_at: Optional[str], updated_by: Optional[int]) -> None:
        self.added_at = added_at
        self.added_by = added_by
        self.created_at = created_at
        self.created_by = created_by
        self.description = description
        self.environments = environments
        self.href = href
        self.id = id
        self.name = name
        self.parent_folder_id = parent_folder_id
        self.summary = summary
        self.type = type
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'PANElementCreated':
        assert isinstance(obj, dict)
        added_at = from_union([from_str, from_none], obj.get("addedAt"))
        added_by = from_union([from_int, from_none], obj.get("addedBy"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_int, from_none], obj.get("createdBy"))
        description = from_union([from_str, from_none], obj.get("description"))
        environments = from_union([lambda x: from_list(from_str, x), from_none], obj.get("environments"))
        href = from_union([from_str, from_none], obj.get("href"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        parent_folder_id = from_union([from_int, from_none], obj.get("parentFolderId"))
        summary = from_union([from_str, from_none], obj.get("summary"))
        type = from_union([from_str, from_none], obj.get("type"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_int, from_none], obj.get("updatedBy"))
        return PANElementCreated(added_at, added_by, created_at, created_by, description, environments, href, id, name, parent_folder_id, summary, type, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.added_at is not None:
            result["addedAt"] = from_union([from_str, from_none], self.added_at)
        if self.added_by is not None:
            result["addedBy"] = from_union([from_int, from_none], self.added_by)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_int, from_none], self.created_by)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.environments is not None:
            result["environments"] = from_union([lambda x: from_list(from_str, x), from_none], self.environments)
        if self.href is not None:
            result["href"] = from_union([from_str, from_none], self.href)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.parent_folder_id is not None:
            result["parentFolderId"] = from_union([from_int, from_none], self.parent_folder_id)
        if self.summary is not None:
            result["summary"] = from_union([from_str, from_none], self.summary)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_int, from_none], self.updated_by)
        return result


class PANFolderCreated:
    """Information about the Private API Network folder."""
    """The date and time at which the element was created."""
    created_at: Optional[str]
    """The user who created the folder."""
    created_by: Optional[int]
    """The folder's description."""
    description: Optional[str]
    """The folder's ID."""
    id: Optional[int]
    """The folder's name."""
    name: Optional[str]
    """The parent folder ID."""
    parent_folder_id: Optional[int]
    """The folder's type. This is always the `folder` value."""
    type: Optional[str]
    """The date and time at which the folder was updated."""
    updated_at: Optional[str]
    """The user who updated the folder."""
    updated_by: Optional[int]

    def __init__(self, created_at: Optional[str], created_by: Optional[int], description: Optional[str], id: Optional[int], name: Optional[str], parent_folder_id: Optional[int], type: Optional[str], updated_at: Optional[str], updated_by: Optional[int]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.description = description
        self.id = id
        self.name = name
        self.parent_folder_id = parent_folder_id
        self.type = type
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'PANFolderCreated':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_int, from_none], obj.get("createdBy"))
        description = from_union([from_str, from_none], obj.get("description"))
        id = from_union([from_int, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        parent_folder_id = from_union([from_int, from_none], obj.get("parentFolderId"))
        type = from_union([from_str, from_none], obj.get("type"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_int, from_none], obj.get("updatedBy"))
        return PANFolderCreated(created_at, created_by, description, id, name, parent_folder_id, type, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_int, from_none], self.created_by)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.id is not None:
            result["id"] = from_union([from_int, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.parent_folder_id is not None:
            result["parentFolderId"] = from_union([from_int, from_none], self.parent_folder_id)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_int, from_none], self.updated_by)
        return result


class PatchCollectionsCollectionIDBodyCollectionInfo:
    """An object that contains the collection's updated name and description."""
    """The collection's updated description."""
    description: Optional[str]
    """The collection's updated name."""
    name: Optional[str]

    def __init__(self, description: Optional[str], name: Optional[str]) -> None:
        self.description = description
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDBodyCollectionInfo':
        assert isinstance(obj, dict)
        description = from_union([from_str, from_none], obj.get("description"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PatchCollectionsCollectionIDBodyCollectionInfo(description, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PatchCollectionsCollectionIDBodyCollection:
    auth: Any
    events: Any
    """An object that contains the collection's updated name and description."""
    info: Optional[PatchCollectionsCollectionIDBodyCollectionInfo]
    variables: Any

    def __init__(self, auth: Any, events: Any, info: Optional[PatchCollectionsCollectionIDBodyCollectionInfo], variables: Any) -> None:
        self.auth = auth
        self.events = events
        self.info = info
        self.variables = variables

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDBodyCollection':
        assert isinstance(obj, dict)
        auth = obj.get("auth")
        events = obj.get("events")
        info = from_union([PatchCollectionsCollectionIDBodyCollectionInfo.from_dict, from_none], obj.get("info"))
        variables = obj.get("variables")
        return PatchCollectionsCollectionIDBodyCollection(auth, events, info, variables)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.auth is not None:
            result["auth"] = self.auth
        if self.events is not None:
            result["events"] = self.events
        if self.info is not None:
            result["info"] = from_union([lambda x: to_class(PatchCollectionsCollectionIDBodyCollectionInfo, x), from_none], self.info)
        if self.variables is not None:
            result["variables"] = self.variables
        return result


class PatchCollectionsCollectionIDBody:
    collection: Optional[PatchCollectionsCollectionIDBodyCollection]

    def __init__(self, collection: Optional[PatchCollectionsCollectionIDBodyCollection]) -> None:
        self.collection = collection

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDBody':
        assert isinstance(obj, dict)
        collection = from_union([PatchCollectionsCollectionIDBodyCollection.from_dict, from_none], obj.get("collection"))
        return PatchCollectionsCollectionIDBody(collection)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([lambda x: to_class(PatchCollectionsCollectionIDBodyCollection, x), from_none], self.collection)
        return result


class PatchCollectionsCollectionIDResponseCollection:
    """The collection's updated description."""
    description: Optional[str]
    """The collection's ID."""
    id: Optional[str]
    """The collection's updated name."""
    name: Optional[str]

    def __init__(self, description: Optional[str], id: Optional[str], name: Optional[str]) -> None:
        self.description = description
        self.id = id
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDResponseCollection':
        assert isinstance(obj, dict)
        description = from_union([from_str, from_none], obj.get("description"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PatchCollectionsCollectionIDResponseCollection(description, id, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PatchCollectionsCollectionIDResponse:
    collection: Optional[PatchCollectionsCollectionIDResponseCollection]

    def __init__(self, collection: Optional[PatchCollectionsCollectionIDResponseCollection]) -> None:
        self.collection = collection

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDResponse':
        assert isinstance(obj, dict)
        collection = from_union([PatchCollectionsCollectionIDResponseCollection.from_dict, from_none], obj.get("collection"))
        return PatchCollectionsCollectionIDResponse(collection)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([lambda x: to_class(PatchCollectionsCollectionIDResponseCollection, x), from_none], self.collection)
        return result


class PatchCollectionsCollectionIDResponse400Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDResponse400Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PatchCollectionsCollectionIDResponse400Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PatchCollectionsCollectionIDResponse400:
    error: Optional[PatchCollectionsCollectionIDResponse400Error]

    def __init__(self, error: Optional[PatchCollectionsCollectionIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([PatchCollectionsCollectionIDResponse400Error.from_dict, from_none], obj.get("error"))
        return PatchCollectionsCollectionIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PatchCollectionsCollectionIDResponse400Error, x), from_none], self.error)
        return result


class PatchCollectionsCollectionIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PatchCollectionsCollectionIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PatchCollectionsCollectionIDResponse401:
    error: Optional[PatchCollectionsCollectionIDResponse401Error]

    def __init__(self, error: Optional[PatchCollectionsCollectionIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([PatchCollectionsCollectionIDResponse401Error.from_dict, from_none], obj.get("error"))
        return PatchCollectionsCollectionIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PatchCollectionsCollectionIDResponse401Error, x), from_none], self.error)
        return result


class PatchCollectionsCollectionIDResponse403Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDResponse403Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PatchCollectionsCollectionIDResponse403Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PatchCollectionsCollectionIDResponse403:
    error: Optional[PatchCollectionsCollectionIDResponse403Error]

    def __init__(self, error: Optional[PatchCollectionsCollectionIDResponse403Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDResponse403':
        assert isinstance(obj, dict)
        error = from_union([PatchCollectionsCollectionIDResponse403Error.from_dict, from_none], obj.get("error"))
        return PatchCollectionsCollectionIDResponse403(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PatchCollectionsCollectionIDResponse403Error, x), from_none], self.error)
        return result


class PatchCollectionsCollectionIDResponse404ErrorDetails:
    """Information about the error."""
    """The collection ID."""
    id: Optional[str]
    """The instance item."""
    item: Optional[str]

    def __init__(self, id: Optional[str], item: Optional[str]) -> None:
        self.id = id
        self.item = item

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDResponse404ErrorDetails':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        item = from_union([from_str, from_none], obj.get("item"))
        return PatchCollectionsCollectionIDResponse404ErrorDetails(id, item)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.item is not None:
            result["item"] = from_union([from_str, from_none], self.item)
        return result


class PatchCollectionsCollectionIDResponse404Error:
    """Information about the error."""
    details: Optional[PatchCollectionsCollectionIDResponse404ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PatchCollectionsCollectionIDResponse404ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([PatchCollectionsCollectionIDResponse404ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PatchCollectionsCollectionIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PatchCollectionsCollectionIDResponse404ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PatchCollectionsCollectionIDResponse404:
    error: Optional[PatchCollectionsCollectionIDResponse404Error]

    def __init__(self, error: Optional[PatchCollectionsCollectionIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([PatchCollectionsCollectionIDResponse404Error.from_dict, from_none], obj.get("error"))
        return PatchCollectionsCollectionIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PatchCollectionsCollectionIDResponse404Error, x), from_none], self.error)
        return result


class PatchCollectionsCollectionIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PatchCollectionsCollectionIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PatchCollectionsCollectionIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PatchCollectionsCollectionIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PatchCollectionsCollectionIDResponse500:
    error: Optional[PatchCollectionsCollectionIDResponse500Error]

    def __init__(self, error: Optional[PatchCollectionsCollectionIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PatchCollectionsCollectionIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([PatchCollectionsCollectionIDResponse500Error.from_dict, from_none], obj.get("error"))
        return PatchCollectionsCollectionIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PatchCollectionsCollectionIDResponse500Error, x), from_none], self.error)
        return result


class PurpleOp(Enum):
    """The operation to perform."""
    ADD = "add"
    REMOVE = "remove"
    REPLACE = "replace"


class PatchScimV2GroupsGroupIDBodyOperationsItemValue:
    """The performed operation's value."""
    """The group's name."""
    display_name: Optional[str]
    """The group's ID."""
    id: Optional[str]

    def __init__(self, display_name: Optional[str], id: Optional[str]) -> None:
        self.display_name = display_name
        self.id = id

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2GroupsGroupIDBodyOperationsItemValue':
        assert isinstance(obj, dict)
        display_name = from_union([from_str, from_none], obj.get("displayName"))
        id = from_union([from_str, from_none], obj.get("id"))
        return PatchScimV2GroupsGroupIDBodyOperationsItemValue(display_name, id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.display_name is not None:
            result["displayName"] = from_union([from_str, from_none], self.display_name)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        return result


class PatchScimV2GroupsGroupIDBodyOperationsItem:
    """The operation to perform."""
    op: Optional[PurpleOp]
    """The operation's path. Include this value when you update a group's members."""
    path: Optional[str]
    """The performed operation's value."""
    value: Optional[PatchScimV2GroupsGroupIDBodyOperationsItemValue]

    def __init__(self, op: Optional[PurpleOp], path: Optional[str], value: Optional[PatchScimV2GroupsGroupIDBodyOperationsItemValue]) -> None:
        self.op = op
        self.path = path
        self.value = value

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2GroupsGroupIDBodyOperationsItem':
        assert isinstance(obj, dict)
        op = from_union([PurpleOp, from_none], obj.get("op"))
        path = from_union([from_str, from_none], obj.get("path"))
        value = from_union([PatchScimV2GroupsGroupIDBodyOperationsItemValue.from_dict, from_none], obj.get("value"))
        return PatchScimV2GroupsGroupIDBodyOperationsItem(op, path, value)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.op is not None:
            result["op"] = from_union([lambda x: to_enum(PurpleOp, x), from_none], self.op)
        if self.path is not None:
            result["path"] = from_union([from_str, from_none], self.path)
        if self.value is not None:
            result["value"] = from_union([lambda x: to_class(PatchScimV2GroupsGroupIDBodyOperationsItemValue, x), from_none], self.value)
        return result


class PatchScimV2GroupsGroupIDBody:
    """Information about the group update operation."""
    operations: Optional[List[PatchScimV2GroupsGroupIDBodyOperationsItem]]
    """The SCIM schema resource URI."""
    schemas: Optional[List[str]]

    def __init__(self, operations: Optional[List[PatchScimV2GroupsGroupIDBodyOperationsItem]], schemas: Optional[List[str]]) -> None:
        self.operations = operations
        self.schemas = schemas

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2GroupsGroupIDBody':
        assert isinstance(obj, dict)
        operations = from_union([lambda x: from_list(PatchScimV2GroupsGroupIDBodyOperationsItem.from_dict, x), from_none], obj.get("Operations"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        return PatchScimV2GroupsGroupIDBody(operations, schemas)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.operations is not None:
            result["Operations"] = from_union([lambda x: from_list(lambda x: to_class(PatchScimV2GroupsGroupIDBodyOperationsItem, x), x), from_none], self.operations)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        return result


class PatchScimV2GroupsGroupIDResponseMeta:
    """The response's non-standard meta information."""
    """The date and time at which the group was created."""
    created: Optional[str]
    """The date and time at which the group was last modified."""
    last_modified: Optional[str]
    """The resource type."""
    resource_type: Optional[str]

    def __init__(self, created: Optional[str], last_modified: Optional[str], resource_type: Optional[str]) -> None:
        self.created = created
        self.last_modified = last_modified
        self.resource_type = resource_type

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2GroupsGroupIDResponseMeta':
        assert isinstance(obj, dict)
        created = from_union([from_str, from_none], obj.get("created"))
        last_modified = from_union([from_str, from_none], obj.get("lastModified"))
        resource_type = from_union([from_str, from_none], obj.get("resourceType"))
        return PatchScimV2GroupsGroupIDResponseMeta(created, last_modified, resource_type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created is not None:
            result["created"] = from_union([from_str, from_none], self.created)
        if self.last_modified is not None:
            result["lastModified"] = from_union([from_str, from_none], self.last_modified)
        if self.resource_type is not None:
            result["resourceType"] = from_union([from_str, from_none], self.resource_type)
        return result


class PatchScimV2GroupsGroupIDResponse:
    """The group's name."""
    display_name: Optional[str]
    """The group's external ID."""
    external_id: Optional[str]
    """The group's ID."""
    id: Optional[str]
    """The response's non-standard meta information."""
    meta: Optional[PatchScimV2GroupsGroupIDResponseMeta]
    """The SCIM schema resource URI."""
    schemas: Optional[List[str]]

    def __init__(self, display_name: Optional[str], external_id: Optional[str], id: Optional[str], meta: Optional[PatchScimV2GroupsGroupIDResponseMeta], schemas: Optional[List[str]]) -> None:
        self.display_name = display_name
        self.external_id = external_id
        self.id = id
        self.meta = meta
        self.schemas = schemas

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2GroupsGroupIDResponse':
        assert isinstance(obj, dict)
        display_name = from_union([from_str, from_none], obj.get("displayName"))
        external_id = from_union([from_str, from_none], obj.get("externalId"))
        id = from_union([from_str, from_none], obj.get("id"))
        meta = from_union([PatchScimV2GroupsGroupIDResponseMeta.from_dict, from_none], obj.get("meta"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        return PatchScimV2GroupsGroupIDResponse(display_name, external_id, id, meta, schemas)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.display_name is not None:
            result["displayName"] = from_union([from_str, from_none], self.display_name)
        if self.external_id is not None:
            result["externalId"] = from_union([from_str, from_none], self.external_id)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(PatchScimV2GroupsGroupIDResponseMeta, x), from_none], self.meta)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        return result


class PatchScimV2GroupsGroupIDResponse400:
    """Information about the error."""
    detail: Optional[str]
    """A list of SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The SCIM type."""
    scim_type: Optional[str]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], scim_type: Optional[str], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.scim_type = scim_type
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2GroupsGroupIDResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        scim_type = from_union([from_str, from_none], obj.get("scimType"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PatchScimV2GroupsGroupIDResponse400(detail, schemas, scim_type, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.scim_type is not None:
            result["scimType"] = from_union([from_str, from_none], self.scim_type)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PatchScimV2GroupsGroupIDResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2GroupsGroupIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PatchScimV2GroupsGroupIDResponse401(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PatchScimV2GroupsGroupIDResponse403:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2GroupsGroupIDResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PatchScimV2GroupsGroupIDResponse403(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PatchScimV2GroupsGroupIDResponse404:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2GroupsGroupIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PatchScimV2GroupsGroupIDResponse404(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PatchScimV2GroupsGroupIDResponse429:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[float]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[float]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2GroupsGroupIDResponse429':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_float, from_none], obj.get("status"))
        return PatchScimV2GroupsGroupIDResponse429(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        return result


class PatchScimV2GroupsGroupIDResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2GroupsGroupIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PatchScimV2GroupsGroupIDResponse500(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class FluffyOp(Enum):
    """The operation to perform."""
    REPLACE = "replace"


class PatchScimV2UsersUserIDBodyOperationsItemValue:
    """The performed operation's value."""
    """Sets the user's `active` state:
    - `true`  Activates the user. This lets them authenticate in to your Postman team.
    - `false`  Removes the user from your Postman team and deactivates the account. This
    blocks the user from authenticating in to Postman.
    """
    active: Optional[bool]

    def __init__(self, active: Optional[bool]) -> None:
        self.active = active

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2UsersUserIDBodyOperationsItemValue':
        assert isinstance(obj, dict)
        active = from_union([from_bool, from_none], obj.get("active"))
        return PatchScimV2UsersUserIDBodyOperationsItemValue(active)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.active is not None:
            result["active"] = from_union([from_bool, from_none], self.active)
        return result


class PatchScimV2UsersUserIDBodyOperationsItem:
    """The operation to perform."""
    op: Optional[FluffyOp]
    """The performed operation's value."""
    value: Optional[PatchScimV2UsersUserIDBodyOperationsItemValue]

    def __init__(self, op: Optional[FluffyOp], value: Optional[PatchScimV2UsersUserIDBodyOperationsItemValue]) -> None:
        self.op = op
        self.value = value

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2UsersUserIDBodyOperationsItem':
        assert isinstance(obj, dict)
        op = from_union([FluffyOp, from_none], obj.get("op"))
        value = from_union([PatchScimV2UsersUserIDBodyOperationsItemValue.from_dict, from_none], obj.get("value"))
        return PatchScimV2UsersUserIDBodyOperationsItem(op, value)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.op is not None:
            result["op"] = from_union([lambda x: to_enum(FluffyOp, x), from_none], self.op)
        if self.value is not None:
            result["value"] = from_union([lambda x: to_class(PatchScimV2UsersUserIDBodyOperationsItemValue, x), from_none], self.value)
        return result


class PatchScimV2UsersUserIDBody:
    """Information about the user update operation."""
    operations: Optional[List[PatchScimV2UsersUserIDBodyOperationsItem]]
    """The SCIM schema resource URI."""
    schemas: Optional[List[str]]

    def __init__(self, operations: Optional[List[PatchScimV2UsersUserIDBodyOperationsItem]], schemas: Optional[List[str]]) -> None:
        self.operations = operations
        self.schemas = schemas

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2UsersUserIDBody':
        assert isinstance(obj, dict)
        operations = from_union([lambda x: from_list(PatchScimV2UsersUserIDBodyOperationsItem.from_dict, x), from_none], obj.get("Operations"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        return PatchScimV2UsersUserIDBody(operations, schemas)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.operations is not None:
            result["Operations"] = from_union([lambda x: from_list(lambda x: to_class(PatchScimV2UsersUserIDBodyOperationsItem, x), x), from_none], self.operations)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        return result


class PatchScimV2UsersUserIDResponseMeta:
    """The response's non-standard meta information."""
    """The date and time at which the team member was created."""
    created: Optional[str]
    """The date and time at which the team member was last modified."""
    last_modified: Optional[str]
    """The resource type."""
    resource_type: Optional[str]

    def __init__(self, created: Optional[str], last_modified: Optional[str], resource_type: Optional[str]) -> None:
        self.created = created
        self.last_modified = last_modified
        self.resource_type = resource_type

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2UsersUserIDResponseMeta':
        assert isinstance(obj, dict)
        created = from_union([from_str, from_none], obj.get("created"))
        last_modified = from_union([from_str, from_none], obj.get("lastModified"))
        resource_type = from_union([from_str, from_none], obj.get("resourceType"))
        return PatchScimV2UsersUserIDResponseMeta(created, last_modified, resource_type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created is not None:
            result["created"] = from_union([from_str, from_none], self.created)
        if self.last_modified is not None:
            result["lastModified"] = from_union([from_str, from_none], self.last_modified)
        if self.resource_type is not None:
            result["resourceType"] = from_union([from_str, from_none], self.resource_type)
        return result


class PatchScimV2UsersUserIDResponseName:
    """Information about the Postman team member."""
    """The team member's last name."""
    family_name: Optional[str]
    """The team member's first name."""
    given_name: Optional[str]

    def __init__(self, family_name: Optional[str], given_name: Optional[str]) -> None:
        self.family_name = family_name
        self.given_name = given_name

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2UsersUserIDResponseName':
        assert isinstance(obj, dict)
        family_name = from_union([from_str, from_none], obj.get("familyName"))
        given_name = from_union([from_str, from_none], obj.get("givenName"))
        return PatchScimV2UsersUserIDResponseName(family_name, given_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.family_name is not None:
            result["familyName"] = from_union([from_str, from_none], self.family_name)
        if self.given_name is not None:
            result["givenName"] = from_union([from_str, from_none], self.given_name)
        return result


class PatchScimV2UsersUserIDResponse:
    """If true, the team member is active."""
    active: Optional[bool]
    """The team member's external ID."""
    external_id: Optional[str]
    """The team member's SCIM ID."""
    id: Optional[str]
    """The response's non-standard meta information."""
    meta: Optional[PatchScimV2UsersUserIDResponseMeta]
    """Information about the Postman team member."""
    name: Optional[PatchScimV2UsersUserIDResponseName]
    """A list of schema resource URIs."""
    schemas: Optional[List[str]]
    """The team member's SCIM username."""
    user_name: Optional[str]

    def __init__(self, active: Optional[bool], external_id: Optional[str], id: Optional[str], meta: Optional[PatchScimV2UsersUserIDResponseMeta], name: Optional[PatchScimV2UsersUserIDResponseName], schemas: Optional[List[str]], user_name: Optional[str]) -> None:
        self.active = active
        self.external_id = external_id
        self.id = id
        self.meta = meta
        self.name = name
        self.schemas = schemas
        self.user_name = user_name

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2UsersUserIDResponse':
        assert isinstance(obj, dict)
        active = from_union([from_bool, from_none], obj.get("active"))
        external_id = from_union([from_str, from_none], obj.get("externalId"))
        id = from_union([from_str, from_none], obj.get("id"))
        meta = from_union([PatchScimV2UsersUserIDResponseMeta.from_dict, from_none], obj.get("meta"))
        name = from_union([PatchScimV2UsersUserIDResponseName.from_dict, from_none], obj.get("name"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        user_name = from_union([from_str, from_none], obj.get("userName"))
        return PatchScimV2UsersUserIDResponse(active, external_id, id, meta, name, schemas, user_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.active is not None:
            result["active"] = from_union([from_bool, from_none], self.active)
        if self.external_id is not None:
            result["externalId"] = from_union([from_str, from_none], self.external_id)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(PatchScimV2UsersUserIDResponseMeta, x), from_none], self.meta)
        if self.name is not None:
            result["name"] = from_union([lambda x: to_class(PatchScimV2UsersUserIDResponseName, x), from_none], self.name)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.user_name is not None:
            result["userName"] = from_union([from_str, from_none], self.user_name)
        return result


class PatchScimV2UsersUserIDResponse400:
    detail: Optional[str]
    schemas: Optional[List[str]]
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2UsersUserIDResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PatchScimV2UsersUserIDResponse400(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PatchScimV2UsersUserIDResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2UsersUserIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PatchScimV2UsersUserIDResponse401(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PatchScimV2UsersUserIDResponse403:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2UsersUserIDResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PatchScimV2UsersUserIDResponse403(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PatchScimV2UsersUserIDResponse404:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2UsersUserIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PatchScimV2UsersUserIDResponse404(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PatchScimV2UsersUserIDResponse429:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[float]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[float]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2UsersUserIDResponse429':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_float, from_none], obj.get("status"))
        return PatchScimV2UsersUserIDResponse429(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        return result


class PatchScimV2UsersUserIDResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PatchScimV2UsersUserIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PatchScimV2UsersUserIDResponse500(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PostApisAPIIDCollectionsResponse:
    """The collection's ID."""
    id: Optional[str]

    def __init__(self, id: Optional[str]) -> None:
        self.id = id

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDCollectionsResponse':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        return PostApisAPIIDCollectionsResponse(id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        return result


class PostApisAPIIDCollectionsResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDCollectionsResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDCollectionsResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisAPIIDCollectionsResponse403:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDCollectionsResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDCollectionsResponse403(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisAPIIDCollectionsResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDCollectionsResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDCollectionsResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisAPIIDCollectionsResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDCollectionsResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDCollectionsResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisAPIIDSchemasBodyFilesItemRoot:
    """Information about the schema's root file."""
    """If true, tag the file as the root file. The root tag is only allowed for protobuf
    specifications.
    """
    enabled: Optional[bool]

    def __init__(self, enabled: Optional[bool]) -> None:
        self.enabled = enabled

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDSchemasBodyFilesItemRoot':
        assert isinstance(obj, dict)
        enabled = from_union([from_bool, from_none], obj.get("enabled"))
        return PostApisAPIIDSchemasBodyFilesItemRoot(enabled)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.enabled is not None:
            result["enabled"] = from_union([from_bool, from_none], self.enabled)
        return result


class PostApisAPIIDSchemasBodyFilesItem:
    """The schema file's stringified contents."""
    content: Optional[str]
    """The schema's file path."""
    path: Optional[str]
    """Information about the schema's root file."""
    root: Optional[PostApisAPIIDSchemasBodyFilesItemRoot]

    def __init__(self, content: Optional[str], path: Optional[str], root: Optional[PostApisAPIIDSchemasBodyFilesItemRoot]) -> None:
        self.content = content
        self.path = path
        self.root = root

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDSchemasBodyFilesItem':
        assert isinstance(obj, dict)
        content = from_union([from_str, from_none], obj.get("content"))
        path = from_union([from_str, from_none], obj.get("path"))
        root = from_union([PostApisAPIIDSchemasBodyFilesItemRoot.from_dict, from_none], obj.get("root"))
        return PostApisAPIIDSchemasBodyFilesItem(content, path, root)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.content is not None:
            result["content"] = from_union([from_str, from_none], self.content)
        if self.path is not None:
            result["path"] = from_union([from_str, from_none], self.path)
        if self.root is not None:
            result["root"] = from_union([lambda x: to_class(PostApisAPIIDSchemasBodyFilesItemRoot, x), from_none], self.root)
        return result


class PostApisAPIIDSchemasBodyType(Enum):
    """The schema's type.
    
    The type of schema.
    """
    ASYNCAPI_2 = "asyncapi:2"
    GRAPHQL = "graphql"
    OPENAPI_1 = "openapi:1"
    OPENAPI_2 = "openapi:2"
    OPENAPI_3 = "openapi:3"
    OPENAPI_3_1 = "openapi:3_1"
    PROTO_2 = "proto:2"
    PROTO_3 = "proto:3"
    RAML_0_8 = "raml:0_8"
    RAML_1 = "raml:1"
    WSDL_1 = "wsdl:1"
    WSDL_2 = "wsdl:2"


class PostApisAPIIDSchemasBody:
    """Information about the API schema."""
    """The list of files that are part of the schema."""
    files: List[PostApisAPIIDSchemasBodyFilesItem]
    """The schema's type."""
    type: PostApisAPIIDSchemasBodyType

    def __init__(self, files: List[PostApisAPIIDSchemasBodyFilesItem], type: PostApisAPIIDSchemasBodyType) -> None:
        self.files = files
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDSchemasBody':
        assert isinstance(obj, dict)
        files = from_list(PostApisAPIIDSchemasBodyFilesItem.from_dict, obj.get("files"))
        type = PostApisAPIIDSchemasBodyType(obj.get("type"))
        return PostApisAPIIDSchemasBody(files, type)

    def to_dict(self) -> dict:
        result: dict = {}
        result["files"] = from_list(lambda x: to_class(PostApisAPIIDSchemasBodyFilesItem, x), self.files)
        result["type"] = to_enum(PostApisAPIIDSchemasBodyType, self.type)
        return result


class PostApisAPIIDSchemasResponseFilesItem:
    """Information about the schema file."""
    """The date and time at which the file was created."""
    created_at: Optional[str]
    """The user Id of the user that created the file."""
    created_by: Optional[str]
    """The schema file's ID."""
    id: Optional[str]
    """The schema file's name."""
    name: Optional[str]
    """The file system path to the schema file."""
    path: Optional[str]
    """The date and time at which the file was last updated."""
    updated_at: Optional[str]
    """The user ID of the user that last updated the file."""
    updated_by: Optional[str]

    def __init__(self, created_at: Optional[str], created_by: Optional[str], id: Optional[str], name: Optional[str], path: Optional[str], updated_at: Optional[str], updated_by: Optional[str]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.id = id
        self.name = name
        self.path = path
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDSchemasResponseFilesItem':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_str, from_none], obj.get("createdBy"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        path = from_union([from_str, from_none], obj.get("path"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_str, from_none], obj.get("updatedBy"))
        return PostApisAPIIDSchemasResponseFilesItem(created_at, created_by, id, name, path, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_str, from_none], self.created_by)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.path is not None:
            result["path"] = from_union([from_str, from_none], self.path)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_str, from_none], self.updated_by)
        return result


class PostApisAPIIDSchemasResponse:
    """Information about the created API schema."""
    """The date and time at which the schema was created."""
    created_at: Optional[str]
    """The user ID of the user that created the schema."""
    created_by: Optional[str]
    """The list of the schema's files."""
    files: Optional[List[PostApisAPIIDSchemasResponseFilesItem]]
    """The schema's ID."""
    id: Optional[str]
    """The schema's type."""
    type: Optional[PostApisAPIIDSchemasBodyType]
    """The date and time at which the schema was last updated."""
    updated_at: Optional[str]
    """The user ID of the user that updated the schema."""
    updated_by: Optional[str]

    def __init__(self, created_at: Optional[str], created_by: Optional[str], files: Optional[List[PostApisAPIIDSchemasResponseFilesItem]], id: Optional[str], type: Optional[PostApisAPIIDSchemasBodyType], updated_at: Optional[str], updated_by: Optional[str]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.files = files
        self.id = id
        self.type = type
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDSchemasResponse':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_str, from_none], obj.get("createdBy"))
        files = from_union([lambda x: from_list(PostApisAPIIDSchemasResponseFilesItem.from_dict, x), from_none], obj.get("files"))
        id = from_union([from_str, from_none], obj.get("id"))
        type = from_union([PostApisAPIIDSchemasBodyType, from_none], obj.get("type"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_str, from_none], obj.get("updatedBy"))
        return PostApisAPIIDSchemasResponse(created_at, created_by, files, id, type, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_str, from_none], self.created_by)
        if self.files is not None:
            result["files"] = from_union([lambda x: from_list(lambda x: to_class(PostApisAPIIDSchemasResponseFilesItem, x), x), from_none], self.files)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(PostApisAPIIDSchemasBodyType, x), from_none], self.type)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_str, from_none], self.updated_by)
        return result


class PostApisAPIIDSchemasResponse400:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDSchemasResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDSchemasResponse400(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisAPIIDSchemasResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDSchemasResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDSchemasResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisAPIIDSchemasResponse403:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDSchemasResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDSchemasResponse403(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisAPIIDSchemasResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDSchemasResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDSchemasResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisAPIIDSchemasResponse422:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDSchemasResponse422':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDSchemasResponse422(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisAPIIDSchemasResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDSchemasResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDSchemasResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisAPIIDVersionsResponse:
    """The date and time at which the version was created."""
    created_at: Optional[str]
    """The version's ID."""
    id: Optional[str]
    """The version's name."""
    name: Optional[str]
    """Information about the API version release. For example, changelog notes."""
    release_notes: Optional[str]
    """The date and time at which the version was last updated."""
    updated_at: Optional[str]

    def __init__(self, created_at: Optional[str], id: Optional[str], name: Optional[str], release_notes: Optional[str], updated_at: Optional[str]) -> None:
        self.created_at = created_at
        self.id = id
        self.name = name
        self.release_notes = release_notes
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDVersionsResponse':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        release_notes = from_union([from_str, from_none], obj.get("releaseNotes"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return PostApisAPIIDVersionsResponse(created_at, id, name, release_notes, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.release_notes is not None:
            result["releaseNotes"] = from_union([from_str, from_none], self.release_notes)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class PostApisAPIIDVersionsResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDVersionsResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDVersionsResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisAPIIDVersionsResponse403:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDVersionsResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDVersionsResponse403(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisAPIIDVersionsResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDVersionsResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDVersionsResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisAPIIDVersionsResponse422:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDVersionsResponse422':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDVersionsResponse422(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisAPIIDVersionsResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisAPIIDVersionsResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisAPIIDVersionsResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisBody:
    """Information about the API."""
    """The API's description. This supports Markdown formatting."""
    description: Optional[str]
    """The API's name."""
    name: str
    """The API's short summary."""
    summary: Optional[str]

    def __init__(self, description: Optional[str], name: str, summary: Optional[str]) -> None:
        self.description = description
        self.name = name
        self.summary = summary

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisBody':
        assert isinstance(obj, dict)
        description = from_union([from_str, from_none], obj.get("description"))
        name = from_str(obj.get("name"))
        summary = from_union([from_str, from_none], obj.get("summary"))
        return PostApisBody(description, name, summary)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        result["name"] = from_str(self.name)
        if self.summary is not None:
            result["summary"] = from_union([from_str, from_none], self.summary)
        return result


class PostApisResponse:
    """The API's base data schema."""
    """The date and time at which the API was created."""
    created_at: Optional[str]
    """The Postman ID of the user that created the API."""
    created_by: Optional[float]
    """The API's description."""
    description: Optional[str]
    """The API's ID."""
    id: Optional[str]
    """The API's name."""
    name: Optional[str]
    """The API's short summary."""
    summary: Optional[str]
    """The date and time at which the API was updated."""
    updated_at: Optional[str]
    """The Postman ID of the user that updated the API."""
    updated_by: Optional[float]

    def __init__(self, created_at: Optional[str], created_by: Optional[float], description: Optional[str], id: Optional[str], name: Optional[str], summary: Optional[str], updated_at: Optional[str], updated_by: Optional[float]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.description = description
        self.id = id
        self.name = name
        self.summary = summary
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisResponse':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_float, from_none], obj.get("createdBy"))
        description = from_union([from_str, from_none], obj.get("description"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        summary = from_union([from_str, from_none], obj.get("summary"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_float, from_none], obj.get("updatedBy"))
        return PostApisResponse(created_at, created_by, description, id, name, summary, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([to_float, from_none], self.created_by)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.summary is not None:
            result["summary"] = from_union([from_str, from_none], self.summary)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([to_float, from_none], self.updated_by)
        return result


class PostApisResponse400:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisResponse400(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisResponse403:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisResponse403(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostApisResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostApisResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostApisResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostCollectionsBodyCollectionInfo:
    """An object that contains basic information about the collection. For a complete list of
    values, refer to the `definitions.info` entry in the [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    """The collection's name."""
    name: str
    """A URL to the collection's schema."""
    schema: str

    def __init__(self, name: str, schema: str) -> None:
        self.name = name
        self.schema = schema

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsBodyCollectionInfo':
        assert isinstance(obj, dict)
        name = from_str(obj.get("name"))
        schema = from_str(obj.get("schema"))
        return PostCollectionsBodyCollectionInfo(name, schema)

    def to_dict(self) -> dict:
        result: dict = {}
        result["name"] = from_str(self.name)
        result["schema"] = from_str(self.schema)
        return result


class PostCollectionsBodyCollectionItemItem:
    request: Any

    def __init__(self, request: Any) -> None:
        self.request = request

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsBodyCollectionItemItem':
        assert isinstance(obj, dict)
        request = obj.get("request")
        return PostCollectionsBodyCollectionItemItem(request)

    def to_dict(self) -> dict:
        result: dict = {}
        result["request"] = self.request
        return result


class PostCollectionsBodyCollection:
    """For a complete list of values, refer to the [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    """An object that contains basic information about the collection. For a complete list of
    values, refer to the `definitions.info` entry in the [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    info: PostCollectionsBodyCollectionInfo
    """Information about the collection's HTTP requests and responses. For a complete list of
    values, refer to the `definitions.item` entry in the [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    item: Optional[List[PostCollectionsBodyCollectionItemItem]]

    def __init__(self, info: PostCollectionsBodyCollectionInfo, item: Optional[List[PostCollectionsBodyCollectionItemItem]]) -> None:
        self.info = info
        self.item = item

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsBodyCollection':
        assert isinstance(obj, dict)
        info = PostCollectionsBodyCollectionInfo.from_dict(obj.get("info"))
        item = from_union([lambda x: from_list(PostCollectionsBodyCollectionItemItem.from_dict, x), from_none], obj.get("item"))
        return PostCollectionsBodyCollection(info, item)

    def to_dict(self) -> dict:
        result: dict = {}
        result["info"] = to_class(PostCollectionsBodyCollectionInfo, self.info)
        if self.item is not None:
            result["item"] = from_union([lambda x: from_list(lambda x: to_class(PostCollectionsBodyCollectionItemItem, x), x), from_none], self.item)
        return result


class PostCollectionsBody:
    """For a complete list of values, refer to the [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    collection: Optional[PostCollectionsBodyCollection]

    def __init__(self, collection: Optional[PostCollectionsBodyCollection]) -> None:
        self.collection = collection

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsBody':
        assert isinstance(obj, dict)
        collection = from_union([PostCollectionsBodyCollection.from_dict, from_none], obj.get("collection"))
        return PostCollectionsBody(collection)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([lambda x: to_class(PostCollectionsBodyCollection, x), from_none], self.collection)
        return result


class PostCollectionsCollectionIDFoldersBody:
    """Information about the collection folder. For a complete list of properties, refer to the
    [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    
    **Note:**
    
    It is recommended that you pass the `name` property in the request body. If you do not,
    the system uses a null value. As a result, this creates a folder with a blank name.
    """
    """The ID of a folder in which to create the folder."""
    folder: Optional[str]
    """The folder's name. It is recommended that you pass the `name` property in the request
    body. If you do not, the system uses a null value. As a result, this creates a folder
    with a blank name.
    """
    name: Optional[str]

    def __init__(self, folder: Optional[str], name: Optional[str]) -> None:
        self.folder = folder
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDFoldersBody':
        assert isinstance(obj, dict)
        folder = from_union([from_str, from_none], obj.get("folder"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsCollectionIDFoldersBody(folder, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.folder is not None:
            result["folder"] = from_union([from_str, from_none], self.folder)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsCollectionIDFoldersResponseData:
    """Information about the collection folder. For a complete list of properties, refer to the
    [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    """The collection ID that the folder belongs to."""
    collection: Optional[str]
    """The folder's creation date and time."""
    created_at: Optional[str]
    """The folder's description."""
    description: Optional[str]
    """Information about the folder."""
    folder: Optional[str]
    """A list of folders."""
    folders: Optional[List[str]]
    """A list of folder IDs and their order in the collection."""
    folders_order: Optional[List[str]]
    """The folder's ID."""
    id: Optional[str]
    """The user ID of the user that last updated the folder."""
    last_updated_by: Optional[str]
    """The folder's name."""
    name: Optional[str]
    """A list of request IDs and their order in the created folder."""
    order: Optional[List[str]]
    """The user ID of the folder's owner."""
    owner: Optional[str]
    """A list of requests."""
    requests: Optional[List[str]]
    """The date and time at which the folder was last updated."""
    updated_at: Optional[str]

    def __init__(self, collection: Optional[str], created_at: Optional[str], description: Optional[str], folder: Optional[str], folders: Optional[List[str]], folders_order: Optional[List[str]], id: Optional[str], last_updated_by: Optional[str], name: Optional[str], order: Optional[List[str]], owner: Optional[str], requests: Optional[List[str]], updated_at: Optional[str]) -> None:
        self.collection = collection
        self.created_at = created_at
        self.description = description
        self.folder = folder
        self.folders = folders
        self.folders_order = folders_order
        self.id = id
        self.last_updated_by = last_updated_by
        self.name = name
        self.order = order
        self.owner = owner
        self.requests = requests
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDFoldersResponseData':
        assert isinstance(obj, dict)
        collection = from_union([from_str, from_none], obj.get("collection"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        description = from_union([from_str, from_none], obj.get("description"))
        folder = from_union([from_str, from_none], obj.get("folder"))
        folders = from_union([lambda x: from_list(from_str, x), from_none], obj.get("folders"))
        folders_order = from_union([lambda x: from_list(from_str, x), from_none], obj.get("folders_order"))
        id = from_union([from_str, from_none], obj.get("id"))
        last_updated_by = from_union([from_str, from_none], obj.get("lastUpdatedBy"))
        name = from_union([from_str, from_none], obj.get("name"))
        order = from_union([lambda x: from_list(from_str, x), from_none], obj.get("order"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        requests = from_union([lambda x: from_list(from_str, x), from_none], obj.get("requests"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return PostCollectionsCollectionIDFoldersResponseData(collection, created_at, description, folder, folders, folders_order, id, last_updated_by, name, order, owner, requests, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([from_str, from_none], self.collection)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.folder is not None:
            result["folder"] = from_union([from_str, from_none], self.folder)
        if self.folders is not None:
            result["folders"] = from_union([lambda x: from_list(from_str, x), from_none], self.folders)
        if self.folders_order is not None:
            result["folders_order"] = from_union([lambda x: from_list(from_str, x), from_none], self.folders_order)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.last_updated_by is not None:
            result["lastUpdatedBy"] = from_union([from_str, from_none], self.last_updated_by)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.order is not None:
            result["order"] = from_union([lambda x: from_list(from_str, x), from_none], self.order)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.requests is not None:
            result["requests"] = from_union([lambda x: from_list(from_str, x), from_none], self.requests)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class PostCollectionsCollectionIDFoldersResponse:
    """Information about the collection folder. For a complete list of properties, refer to the
    [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    data: Optional[PostCollectionsCollectionIDFoldersResponseData]
    meta: Any
    """The folder's ID."""
    model_id: Optional[str]
    """An internal revision ID. Its value increments each time the resource changes. You can use
    this ID to track whether there were changes since the last time you fetched the resource.
    """
    revision: Optional[float]

    def __init__(self, data: Optional[PostCollectionsCollectionIDFoldersResponseData], meta: Any, model_id: Optional[str], revision: Optional[float]) -> None:
        self.data = data
        self.meta = meta
        self.model_id = model_id
        self.revision = revision

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDFoldersResponse':
        assert isinstance(obj, dict)
        data = from_union([PostCollectionsCollectionIDFoldersResponseData.from_dict, from_none], obj.get("data"))
        meta = obj.get("meta")
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        revision = from_union([from_float, from_none], obj.get("revision"))
        return PostCollectionsCollectionIDFoldersResponse(data, meta, model_id, revision)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: to_class(PostCollectionsCollectionIDFoldersResponseData, x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = self.meta
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.revision is not None:
            result["revision"] = from_union([to_float, from_none], self.revision)
        return result


class PostCollectionsCollectionIDFoldersResponse400ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The folder's ID."""
    model_id: Optional[str]
    """The user ID of the folder's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDFoldersResponse400ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PostCollectionsCollectionIDFoldersResponse400ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PostCollectionsCollectionIDFoldersResponse400Error:
    """Information about the error."""
    details: Optional[PostCollectionsCollectionIDFoldersResponse400ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PostCollectionsCollectionIDFoldersResponse400ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDFoldersResponse400Error':
        assert isinstance(obj, dict)
        details = from_union([PostCollectionsCollectionIDFoldersResponse400ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsCollectionIDFoldersResponse400Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PostCollectionsCollectionIDFoldersResponse400ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsCollectionIDFoldersResponse400:
    error: Optional[PostCollectionsCollectionIDFoldersResponse400Error]

    def __init__(self, error: Optional[PostCollectionsCollectionIDFoldersResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDFoldersResponse400':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsCollectionIDFoldersResponse400Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsCollectionIDFoldersResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsCollectionIDFoldersResponse400Error, x), from_none], self.error)
        return result


class PostCollectionsCollectionIDFoldersResponse401ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The folder's ID."""
    model_id: Optional[str]
    """The user ID of the folder's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDFoldersResponse401ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PostCollectionsCollectionIDFoldersResponse401ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PostCollectionsCollectionIDFoldersResponse401Error:
    """Information about the error."""
    details: Optional[PostCollectionsCollectionIDFoldersResponse401ErrorDetails]
    """The error's message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PostCollectionsCollectionIDFoldersResponse401ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDFoldersResponse401Error':
        assert isinstance(obj, dict)
        details = from_union([PostCollectionsCollectionIDFoldersResponse401ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsCollectionIDFoldersResponse401Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PostCollectionsCollectionIDFoldersResponse401ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsCollectionIDFoldersResponse401:
    error: Optional[PostCollectionsCollectionIDFoldersResponse401Error]

    def __init__(self, error: Optional[PostCollectionsCollectionIDFoldersResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDFoldersResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsCollectionIDFoldersResponse401Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsCollectionIDFoldersResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsCollectionIDFoldersResponse401Error, x), from_none], self.error)
        return result


class PostCollectionsCollectionIDFoldersResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDFoldersResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostCollectionsCollectionIDFoldersResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostCollectionsCollectionIDRequestsBody:
    """Information about the request. For a complete list of properties, refer to the
    `definitions.request` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    
    **Note:**
    
    It is recommended that you pass the `name` property in the request body. If you do not,
    the system uses a null value. As a result, this creates a request with a blank name.
    """
    """The request's name. It is recommended that you pass the `name` property in the request
    body. If you do not, the system uses a null value. As a result, this creates a request
    with a blank name.
    """
    name: Optional[str]

    def __init__(self, name: Optional[str]) -> None:
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDRequestsBody':
        assert isinstance(obj, dict)
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsCollectionIDRequestsBody(name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsCollectionIDRequestsResponseData:
    """Information about the created request. For a complete list of properties, refer to the
    `definitions.request` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    """The collection ID that the request belongs to."""
    collection: Optional[str]
    """The requeset's creation date and time."""
    created_at: Optional[str]
    """Information about the request's parent folder."""
    folder: Optional[str]
    """The request's ID."""
    id: Optional[str]
    """The user ID of the user that last updated the folder."""
    last_updated_by: Optional[str]
    """The request's name."""
    name: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]
    """A list of the request's responses."""
    responses: Optional[List[str]]
    """A list of response IDs and their order in the folder."""
    responses_order: Optional[List[str]]
    """The date and time at which the request was last updated."""
    updated_at: Optional[str]

    def __init__(self, collection: Optional[str], created_at: Optional[str], folder: Optional[str], id: Optional[str], last_updated_by: Optional[str], name: Optional[str], owner: Optional[str], responses: Optional[List[str]], responses_order: Optional[List[str]], updated_at: Optional[str]) -> None:
        self.collection = collection
        self.created_at = created_at
        self.folder = folder
        self.id = id
        self.last_updated_by = last_updated_by
        self.name = name
        self.owner = owner
        self.responses = responses
        self.responses_order = responses_order
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDRequestsResponseData':
        assert isinstance(obj, dict)
        collection = from_union([from_str, from_none], obj.get("collection"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        folder = from_union([from_str, from_none], obj.get("folder"))
        id = from_union([from_str, from_none], obj.get("id"))
        last_updated_by = from_union([from_str, from_none], obj.get("lastUpdatedBy"))
        name = from_union([from_str, from_none], obj.get("name"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        responses = from_union([lambda x: from_list(from_str, x), from_none], obj.get("responses"))
        responses_order = from_union([lambda x: from_list(from_str, x), from_none], obj.get("responses_order"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return PostCollectionsCollectionIDRequestsResponseData(collection, created_at, folder, id, last_updated_by, name, owner, responses, responses_order, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([from_str, from_none], self.collection)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.folder is not None:
            result["folder"] = from_union([from_str, from_none], self.folder)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.last_updated_by is not None:
            result["lastUpdatedBy"] = from_union([from_str, from_none], self.last_updated_by)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.responses is not None:
            result["responses"] = from_union([lambda x: from_list(from_str, x), from_none], self.responses)
        if self.responses_order is not None:
            result["responses_order"] = from_union([lambda x: from_list(from_str, x), from_none], self.responses_order)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class PostCollectionsCollectionIDRequestsResponse:
    """Information about the created request. For a complete list of properties, refer to the
    `definitions.request` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    data: Optional[PostCollectionsCollectionIDRequestsResponseData]
    meta: Any
    """The request's ID."""
    model_id: Optional[str]
    """An internal revision ID. Its value increments each time the resource changes. You can use
    this ID to track whether there were changes since the last time you fetched the resource.
    """
    revision: Optional[float]

    def __init__(self, data: Optional[PostCollectionsCollectionIDRequestsResponseData], meta: Any, model_id: Optional[str], revision: Optional[float]) -> None:
        self.data = data
        self.meta = meta
        self.model_id = model_id
        self.revision = revision

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDRequestsResponse':
        assert isinstance(obj, dict)
        data = from_union([PostCollectionsCollectionIDRequestsResponseData.from_dict, from_none], obj.get("data"))
        meta = obj.get("meta")
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        revision = from_union([from_float, from_none], obj.get("revision"))
        return PostCollectionsCollectionIDRequestsResponse(data, meta, model_id, revision)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: to_class(PostCollectionsCollectionIDRequestsResponseData, x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = self.meta
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.revision is not None:
            result["revision"] = from_union([to_float, from_none], self.revision)
        return result


class PostCollectionsCollectionIDRequestsResponse400ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The request's ID."""
    model_id: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDRequestsResponse400ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PostCollectionsCollectionIDRequestsResponse400ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PostCollectionsCollectionIDRequestsResponse400Error:
    """Information about the error."""
    details: Optional[PostCollectionsCollectionIDRequestsResponse400ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PostCollectionsCollectionIDRequestsResponse400ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDRequestsResponse400Error':
        assert isinstance(obj, dict)
        details = from_union([PostCollectionsCollectionIDRequestsResponse400ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsCollectionIDRequestsResponse400Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PostCollectionsCollectionIDRequestsResponse400ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsCollectionIDRequestsResponse400:
    error: Optional[PostCollectionsCollectionIDRequestsResponse400Error]

    def __init__(self, error: Optional[PostCollectionsCollectionIDRequestsResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDRequestsResponse400':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsCollectionIDRequestsResponse400Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsCollectionIDRequestsResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsCollectionIDRequestsResponse400Error, x), from_none], self.error)
        return result


class PostCollectionsCollectionIDRequestsResponse401ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The request's ID."""
    model_id: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDRequestsResponse401ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PostCollectionsCollectionIDRequestsResponse401ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PostCollectionsCollectionIDRequestsResponse401Error:
    """Information about the error."""
    details: Optional[PostCollectionsCollectionIDRequestsResponse401ErrorDetails]
    """The error's message."""
    message: Optional[str]
    """The error's name."""
    name: Optional[str]

    def __init__(self, details: Optional[PostCollectionsCollectionIDRequestsResponse401ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDRequestsResponse401Error':
        assert isinstance(obj, dict)
        details = from_union([PostCollectionsCollectionIDRequestsResponse401ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsCollectionIDRequestsResponse401Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PostCollectionsCollectionIDRequestsResponse401ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsCollectionIDRequestsResponse401:
    error: Optional[PostCollectionsCollectionIDRequestsResponse401Error]

    def __init__(self, error: Optional[PostCollectionsCollectionIDRequestsResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDRequestsResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsCollectionIDRequestsResponse401Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsCollectionIDRequestsResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsCollectionIDRequestsResponse401Error, x), from_none], self.error)
        return result


class PostCollectionsCollectionIDRequestsResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDRequestsResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostCollectionsCollectionIDRequestsResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostCollectionsCollectionIDResponsesBody:
    """Information about the response. For a complete list of properties, refer to the
    `definitions.request.responses` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    
    **Note:**
    
    It is recommended that you pass the `name` property in the request body. If you do not,
    the system uses a null value. As a result, this creates a response with a blank name.
    """
    """The response's name. It is recommended that you pass the `name` property in the request
    body. If you do not, the system uses a null value. As a result, this creates a response
    with a blank name.
    """
    name: Optional[str]

    def __init__(self, name: Optional[str]) -> None:
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDResponsesBody':
        assert isinstance(obj, dict)
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsCollectionIDResponsesBody(name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsCollectionIDResponsesResponseData:
    """Information about the response. For a complete list of properties, refer to the
    `definitions.request.responses` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    """The date and time at which the response was created."""
    created_at: Optional[str]
    """The response's ID."""
    id: Optional[str]
    """The user ID of the user who last updated the response."""
    last_updated_by: Optional[str]
    """The user ID of the response's owner."""
    owner: Optional[str]
    """The request ID of the response's associated request."""
    request: Optional[str]
    """The date and time at which the response was last updated."""
    updated_at: Optional[str]

    def __init__(self, created_at: Optional[str], id: Optional[str], last_updated_by: Optional[str], owner: Optional[str], request: Optional[str], updated_at: Optional[str]) -> None:
        self.created_at = created_at
        self.id = id
        self.last_updated_by = last_updated_by
        self.owner = owner
        self.request = request
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDResponsesResponseData':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        id = from_union([from_str, from_none], obj.get("id"))
        last_updated_by = from_union([from_str, from_none], obj.get("lastUpdatedBy"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        request = from_union([from_str, from_none], obj.get("request"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return PostCollectionsCollectionIDResponsesResponseData(created_at, id, last_updated_by, owner, request, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.last_updated_by is not None:
            result["lastUpdatedBy"] = from_union([from_str, from_none], self.last_updated_by)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.request is not None:
            result["request"] = from_union([from_str, from_none], self.request)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class PostCollectionsCollectionIDResponsesResponse:
    """Information about the response. For a complete list of properties, refer to the
    `definitions.request.responses` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    data: Optional[PostCollectionsCollectionIDResponsesResponseData]
    meta: Any
    """The response's ID."""
    model_id: Optional[str]
    """An internal revision ID. Its value increments each time the resource changes. You can use
    this ID to track whether there were changes since the last time you fetched the resource.
    """
    revision: Optional[float]

    def __init__(self, data: Optional[PostCollectionsCollectionIDResponsesResponseData], meta: Any, model_id: Optional[str], revision: Optional[float]) -> None:
        self.data = data
        self.meta = meta
        self.model_id = model_id
        self.revision = revision

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDResponsesResponse':
        assert isinstance(obj, dict)
        data = from_union([PostCollectionsCollectionIDResponsesResponseData.from_dict, from_none], obj.get("data"))
        meta = obj.get("meta")
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        revision = from_union([from_float, from_none], obj.get("revision"))
        return PostCollectionsCollectionIDResponsesResponse(data, meta, model_id, revision)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: to_class(PostCollectionsCollectionIDResponsesResponseData, x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = self.meta
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.revision is not None:
            result["revision"] = from_union([to_float, from_none], self.revision)
        return result


class PostCollectionsCollectionIDResponsesResponse400ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The response's ID."""
    model_id: Optional[str]
    """The user ID of the response's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDResponsesResponse400ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PostCollectionsCollectionIDResponsesResponse400ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PostCollectionsCollectionIDResponsesResponse400Error:
    """Information about the error."""
    details: Optional[PostCollectionsCollectionIDResponsesResponse400ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PostCollectionsCollectionIDResponsesResponse400ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDResponsesResponse400Error':
        assert isinstance(obj, dict)
        details = from_union([PostCollectionsCollectionIDResponsesResponse400ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsCollectionIDResponsesResponse400Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PostCollectionsCollectionIDResponsesResponse400ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsCollectionIDResponsesResponse400:
    error: Optional[PostCollectionsCollectionIDResponsesResponse400Error]

    def __init__(self, error: Optional[PostCollectionsCollectionIDResponsesResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDResponsesResponse400':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsCollectionIDResponsesResponse400Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsCollectionIDResponsesResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsCollectionIDResponsesResponse400Error, x), from_none], self.error)
        return result


class PostCollectionsCollectionIDResponsesResponse401ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The response's ID."""
    model_id: Optional[str]
    """The user ID of the response's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDResponsesResponse401ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PostCollectionsCollectionIDResponsesResponse401ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PostCollectionsCollectionIDResponsesResponse401Error:
    """Information about the error."""
    details: Optional[PostCollectionsCollectionIDResponsesResponse401ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PostCollectionsCollectionIDResponsesResponse401ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDResponsesResponse401Error':
        assert isinstance(obj, dict)
        details = from_union([PostCollectionsCollectionIDResponsesResponse401ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsCollectionIDResponsesResponse401Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PostCollectionsCollectionIDResponsesResponse401ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsCollectionIDResponsesResponse401:
    error: Optional[PostCollectionsCollectionIDResponsesResponse401Error]

    def __init__(self, error: Optional[PostCollectionsCollectionIDResponsesResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDResponsesResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsCollectionIDResponsesResponse401Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsCollectionIDResponsesResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsCollectionIDResponsesResponse401Error, x), from_none], self.error)
        return result


class PostCollectionsCollectionIDResponsesResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsCollectionIDResponsesResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostCollectionsCollectionIDResponsesResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostCollectionsForkCollectionIDBody:
    """The fork's label."""
    label: str

    def __init__(self, label: str) -> None:
        self.label = label

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsForkCollectionIDBody':
        assert isinstance(obj, dict)
        label = from_str(obj.get("label"))
        return PostCollectionsForkCollectionIDBody(label)

    def to_dict(self) -> dict:
        result: dict = {}
        result["label"] = from_str(self.label)
        return result


class PostCollectionsForkCollectionIDResponseCollectionFork:
    """Information about the collection's fork."""
    """The fork's creation date and time."""
    created_at: Optional[str]
    """The unique ID of fork's source collection."""
    post_collections_fork_collection_id_response_collection_fork_from: Optional[str]
    """The fork's label."""
    label: Optional[str]

    def __init__(self, created_at: Optional[str], post_collections_fork_collection_id_response_collection_fork_from: Optional[str], label: Optional[str]) -> None:
        self.created_at = created_at
        self.post_collections_fork_collection_id_response_collection_fork_from = post_collections_fork_collection_id_response_collection_fork_from
        self.label = label

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsForkCollectionIDResponseCollectionFork':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        post_collections_fork_collection_id_response_collection_fork_from = from_union([from_str, from_none], obj.get("from"))
        label = from_union([from_str, from_none], obj.get("label"))
        return PostCollectionsForkCollectionIDResponseCollectionFork(created_at, post_collections_fork_collection_id_response_collection_fork_from, label)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.post_collections_fork_collection_id_response_collection_fork_from is not None:
            result["from"] = from_union([from_str, from_none], self.post_collections_fork_collection_id_response_collection_fork_from)
        if self.label is not None:
            result["label"] = from_union([from_str, from_none], self.label)
        return result


class PostCollectionsForkCollectionIDResponseCollection:
    """Information about the forked collection."""
    """Information about the collection's fork."""
    fork: Optional[PostCollectionsForkCollectionIDResponseCollectionFork]
    """The forked collection's ID."""
    id: Optional[str]
    """The collection's name."""
    name: Optional[str]
    """The forked collection's unique ID."""
    uid: Optional[str]

    def __init__(self, fork: Optional[PostCollectionsForkCollectionIDResponseCollectionFork], id: Optional[str], name: Optional[str], uid: Optional[str]) -> None:
        self.fork = fork
        self.id = id
        self.name = name
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsForkCollectionIDResponseCollection':
        assert isinstance(obj, dict)
        fork = from_union([PostCollectionsForkCollectionIDResponseCollectionFork.from_dict, from_none], obj.get("fork"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return PostCollectionsForkCollectionIDResponseCollection(fork, id, name, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.fork is not None:
            result["fork"] = from_union([lambda x: to_class(PostCollectionsForkCollectionIDResponseCollectionFork, x), from_none], self.fork)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class PostCollectionsForkCollectionIDResponse:
    """Information about the forked collection."""
    collection: Optional[PostCollectionsForkCollectionIDResponseCollection]

    def __init__(self, collection: Optional[PostCollectionsForkCollectionIDResponseCollection]) -> None:
        self.collection = collection

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsForkCollectionIDResponse':
        assert isinstance(obj, dict)
        collection = from_union([PostCollectionsForkCollectionIDResponseCollection.from_dict, from_none], obj.get("collection"))
        return PostCollectionsForkCollectionIDResponse(collection)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([lambda x: to_class(PostCollectionsForkCollectionIDResponseCollection, x), from_none], self.collection)
        return result


class PostCollectionsForkCollectionIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsForkCollectionIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsForkCollectionIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsForkCollectionIDResponse401:
    error: Optional[PostCollectionsForkCollectionIDResponse401Error]

    def __init__(self, error: Optional[PostCollectionsForkCollectionIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsForkCollectionIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsForkCollectionIDResponse401Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsForkCollectionIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsForkCollectionIDResponse401Error, x), from_none], self.error)
        return result


class PostCollectionsForkCollectionIDResponse404ErrorDetails:
    """Information about the error."""
    """The collection ID."""
    id: Optional[str]
    """The instance item."""
    item: Optional[str]

    def __init__(self, id: Optional[str], item: Optional[str]) -> None:
        self.id = id
        self.item = item

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsForkCollectionIDResponse404ErrorDetails':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        item = from_union([from_str, from_none], obj.get("item"))
        return PostCollectionsForkCollectionIDResponse404ErrorDetails(id, item)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.item is not None:
            result["item"] = from_union([from_str, from_none], self.item)
        return result


class PostCollectionsForkCollectionIDResponse404Error:
    """Information about the error."""
    details: Optional[PostCollectionsForkCollectionIDResponse404ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PostCollectionsForkCollectionIDResponse404ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsForkCollectionIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([PostCollectionsForkCollectionIDResponse404ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsForkCollectionIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PostCollectionsForkCollectionIDResponse404ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsForkCollectionIDResponse404:
    error: Optional[PostCollectionsForkCollectionIDResponse404Error]

    def __init__(self, error: Optional[PostCollectionsForkCollectionIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsForkCollectionIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsForkCollectionIDResponse404Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsForkCollectionIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsForkCollectionIDResponse404Error, x), from_none], self.error)
        return result


class PostCollectionsForkCollectionIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsForkCollectionIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PostCollectionsForkCollectionIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PostCollectionsForkCollectionIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsForkCollectionIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsForkCollectionIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsForkCollectionIDResponse500:
    error: Optional[PostCollectionsForkCollectionIDResponse500Error]

    def __init__(self, error: Optional[PostCollectionsForkCollectionIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsForkCollectionIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsForkCollectionIDResponse500Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsForkCollectionIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsForkCollectionIDResponse500Error, x), from_none], self.error)
        return result


class Strategy(Enum):
    """The fork's merge strategy:
    
    - `deleteSource`  The system deletes the forked collection after a successful merge into
    the destination collection.
    - `updateSourceWithDestination`  The system only merges the forked collection into the
    destination collection.
    """
    DELETE_SOURCE = "deleteSource"
    UPDATE_SOURCE_WITH_DESTINATION = "updateSourceWithDestination"


class PostCollectionsMergeBody:
    """The destination collection's unique ID."""
    destination: str
    """The forked collection's unique ID."""
    source: str
    """The fork's merge strategy:
    
    - `deleteSource`  The system deletes the forked collection after a successful merge into
    the destination collection.
    - `updateSourceWithDestination`  The system only merges the forked collection into the
    destination collection.
    """
    strategy: Optional[Strategy]

    def __init__(self, destination: str, source: str, strategy: Optional[Strategy]) -> None:
        self.destination = destination
        self.source = source
        self.strategy = strategy

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsMergeBody':
        assert isinstance(obj, dict)
        destination = from_str(obj.get("destination"))
        source = from_str(obj.get("source"))
        strategy = from_union([Strategy, from_none], obj.get("strategy"))
        return PostCollectionsMergeBody(destination, source, strategy)

    def to_dict(self) -> dict:
        result: dict = {}
        result["destination"] = from_str(self.destination)
        result["source"] = from_str(self.source)
        if self.strategy is not None:
            result["strategy"] = from_union([lambda x: to_enum(Strategy, x), from_none], self.strategy)
        return result


class PostCollectionsMergeResponseCollection:
    """The source collection's ID."""
    id: Optional[str]
    """The source collection's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsMergeResponseCollection':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return PostCollectionsMergeResponseCollection(id, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class PostCollectionsMergeResponse:
    collection: Optional[PostCollectionsMergeResponseCollection]

    def __init__(self, collection: Optional[PostCollectionsMergeResponseCollection]) -> None:
        self.collection = collection

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsMergeResponse':
        assert isinstance(obj, dict)
        collection = from_union([PostCollectionsMergeResponseCollection.from_dict, from_none], obj.get("collection"))
        return PostCollectionsMergeResponse(collection)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([lambda x: to_class(PostCollectionsMergeResponseCollection, x), from_none], self.collection)
        return result


class PostCollectionsMergeResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsMergeResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsMergeResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsMergeResponse401:
    error: Optional[PostCollectionsMergeResponse401Error]

    def __init__(self, error: Optional[PostCollectionsMergeResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsMergeResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsMergeResponse401Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsMergeResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsMergeResponse401Error, x), from_none], self.error)
        return result


class PostCollectionsMergeResponse404ErrorDetails:
    """Information about the error."""
    """The collection ID."""
    id: Optional[str]
    """The instance item."""
    item: Optional[str]

    def __init__(self, id: Optional[str], item: Optional[str]) -> None:
        self.id = id
        self.item = item

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsMergeResponse404ErrorDetails':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        item = from_union([from_str, from_none], obj.get("item"))
        return PostCollectionsMergeResponse404ErrorDetails(id, item)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.item is not None:
            result["item"] = from_union([from_str, from_none], self.item)
        return result


class PostCollectionsMergeResponse404Error:
    """Information about the error."""
    details: Optional[PostCollectionsMergeResponse404ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PostCollectionsMergeResponse404ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsMergeResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([PostCollectionsMergeResponse404ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsMergeResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PostCollectionsMergeResponse404ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsMergeResponse404:
    error: Optional[PostCollectionsMergeResponse404Error]

    def __init__(self, error: Optional[PostCollectionsMergeResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsMergeResponse404':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsMergeResponse404Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsMergeResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsMergeResponse404Error, x), from_none], self.error)
        return result


class PostCollectionsMergeResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsMergeResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PostCollectionsMergeResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PostCollectionsMergeResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsMergeResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsMergeResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsMergeResponse500:
    error: Optional[PostCollectionsMergeResponse500Error]

    def __init__(self, error: Optional[PostCollectionsMergeResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsMergeResponse500':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsMergeResponse500Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsMergeResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsMergeResponse500Error, x), from_none], self.error)
        return result


class PostCollectionsResponseCollection:
    """The collection's ID."""
    id: Optional[str]
    """The collection's name."""
    name: Optional[str]
    """The collection's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.name = name
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsResponseCollection':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return PostCollectionsResponseCollection(id, name, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class PostCollectionsResponse:
    collection: Optional[PostCollectionsResponseCollection]

    def __init__(self, collection: Optional[PostCollectionsResponseCollection]) -> None:
        self.collection = collection

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsResponse':
        assert isinstance(obj, dict)
        collection = from_union([PostCollectionsResponseCollection.from_dict, from_none], obj.get("collection"))
        return PostCollectionsResponse(collection)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([lambda x: to_class(PostCollectionsResponseCollection, x), from_none], self.collection)
        return result


class PostCollectionsResponse400Error:
    """Information about the error."""
    details: Optional[List[str]]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[List[str]], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsResponse400Error':
        assert isinstance(obj, dict)
        details = from_union([lambda x: from_list(from_str, x), from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsResponse400Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: from_list(from_str, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsResponse400:
    error: Optional[PostCollectionsResponse400Error]

    def __init__(self, error: Optional[PostCollectionsResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsResponse400':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsResponse400Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsResponse400Error, x), from_none], self.error)
        return result


class PostCollectionsResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsResponse401:
    error: Optional[PostCollectionsResponse401Error]

    def __init__(self, error: Optional[PostCollectionsResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsResponse401Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsResponse401Error, x), from_none], self.error)
        return result


class PostCollectionsResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PostCollectionsResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PostCollectionsResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostCollectionsResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostCollectionsResponse500:
    error: Optional[PostCollectionsResponse500Error]

    def __init__(self, error: Optional[PostCollectionsResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostCollectionsResponse500':
        assert isinstance(obj, dict)
        error = from_union([PostCollectionsResponse500Error.from_dict, from_none], obj.get("error"))
        return PostCollectionsResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostCollectionsResponse500Error, x), from_none], self.error)
        return result


class Resolution(Enum):
    """The secret resolution status type:
    - `FALSE_POSITIVE`  The discovered secret is not an actual secret.
    - `REVOKED`  The secret is valid, but the user rotated their key to resolve the issue.
    - `ACCEPTED_RISK`  The Secret Scanner found the secret, but user accepts the risk of
    publishing it.
    
    
    The secret's updated resolution status:
    - `FALSE_POSITIVE`  The discovered secret is not an actual secret.
    - `REVOKED`  The secret is valid, but the user rotated their key to resolve the issue.
    - `ACCEPTED_RISK`  The Secret Scanner found the secret, but user accepts the risk of
    publishing it.
    """
    ACCEPTED_RISK = "ACCEPTED_RISK"
    FALSE_POSITIVE = "FALSE_POSITIVE"
    REVOKED = "REVOKED"


class PostDetectedSecretsQueriesBody:
    """If true, return secrets with a `resolved` status."""
    resolved: Optional[bool]
    """A list of secrets types to query. For a list of valid IDs, use the GET `/secret-types`
    endpoint.
    """
    secret_types: Optional[List[str]]
    """A list of the types of resolution statuses to query."""
    statuses: Optional[List[Resolution]]
    """A list of workspaces IDs to query."""
    workspace_ids: Optional[List[str]]
    """A list of workspace [visibility
    settings](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/managing-workspaces/#changing-workspace-visibility)
    to query. This currently supports the `team` and `public` settings.
    """
    workspace_visiblities: Optional[List[str]]

    def __init__(self, resolved: Optional[bool], secret_types: Optional[List[str]], statuses: Optional[List[Resolution]], workspace_ids: Optional[List[str]], workspace_visiblities: Optional[List[str]]) -> None:
        self.resolved = resolved
        self.secret_types = secret_types
        self.statuses = statuses
        self.workspace_ids = workspace_ids
        self.workspace_visiblities = workspace_visiblities

    @staticmethod
    def from_dict(obj: Any) -> 'PostDetectedSecretsQueriesBody':
        assert isinstance(obj, dict)
        resolved = from_union([from_bool, from_none], obj.get("resolved"))
        secret_types = from_union([lambda x: from_list(from_str, x), from_none], obj.get("secretTypes"))
        statuses = from_union([lambda x: from_list(Resolution, x), from_none], obj.get("statuses"))
        workspace_ids = from_union([lambda x: from_list(from_str, x), from_none], obj.get("workspaceIds"))
        workspace_visiblities = from_union([lambda x: from_list(from_str, x), from_none], obj.get("workspaceVisiblities"))
        return PostDetectedSecretsQueriesBody(resolved, secret_types, statuses, workspace_ids, workspace_visiblities)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.resolved is not None:
            result["resolved"] = from_union([from_bool, from_none], self.resolved)
        if self.secret_types is not None:
            result["secretTypes"] = from_union([lambda x: from_list(from_str, x), from_none], self.secret_types)
        if self.statuses is not None:
            result["statuses"] = from_union([lambda x: from_list(lambda x: to_enum(Resolution, x), x), from_none], self.statuses)
        if self.workspace_ids is not None:
            result["workspaceIds"] = from_union([lambda x: from_list(from_str, x), from_none], self.workspace_ids)
        if self.workspace_visiblities is not None:
            result["workspaceVisiblities"] = from_union([lambda x: from_list(from_str, x), from_none], self.workspace_visiblities)
        return result


class WorkspaceVisibility(Enum):
    """The workspace's [visibility
    setting](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/managing-workspaces/#changing-workspace-visibility).
    
    The new workspace visibility
    [type](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/managing-workspaces/#changing-workspace-visibility).
    This property does **not** support the following workspace visibility changes:
    - `private` to `public`
    - `public` to `private`
    - `private` to `personal`
    - `team` to `personal`
    - `public` to `personal` for a team user
    """
    PERSONAL = "personal"
    PRIVATE = "private"
    PUBLIC = "public"
    TEAM = "team"


class PostDetectedSecretsQueriesResponseDataItem:
    """Information about the secret finding."""
    """The date and time at which the secret was first detected."""
    detected_at: Optional[str]
    """The secret's obfuscated value."""
    obfuscated_secret: Optional[str]
    """The number of times the secret was found in the workspace."""
    occurrences: Optional[float]
    """The secret's current status:
    - `ACTIVE`  The secret is active.
    - `FALSE_POSITIVE`  The discovered secret is not an actual secret.
    - `REVOKED`  The secret is valid, but the user rotated their key to resolve the issue.
    - `ACCEPTED_RISK`  The Secret Scanner found the secret, but user accepts the risk of
    publishing it.
    """
    resolution: Optional[ResolutionEnum]
    """The SHA-256 hash of the detected secret."""
    secret_hash: Optional[str]
    """The detected secret's ID."""
    secret_id: Optional[str]
    """The type of the secret."""
    secret_type: Optional[str]
    """The ID of the workspace that contains the secret."""
    workspace_id: Optional[str]
    """The workspace's [visibility
    setting](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/managing-workspaces/#changing-workspace-visibility).
    """
    workspace_visibility: Optional[WorkspaceVisibility]

    def __init__(self, detected_at: Optional[str], obfuscated_secret: Optional[str], occurrences: Optional[float], resolution: Optional[ResolutionEnum], secret_hash: Optional[str], secret_id: Optional[str], secret_type: Optional[str], workspace_id: Optional[str], workspace_visibility: Optional[WorkspaceVisibility]) -> None:
        self.detected_at = detected_at
        self.obfuscated_secret = obfuscated_secret
        self.occurrences = occurrences
        self.resolution = resolution
        self.secret_hash = secret_hash
        self.secret_id = secret_id
        self.secret_type = secret_type
        self.workspace_id = workspace_id
        self.workspace_visibility = workspace_visibility

    @staticmethod
    def from_dict(obj: Any) -> 'PostDetectedSecretsQueriesResponseDataItem':
        assert isinstance(obj, dict)
        detected_at = from_union([from_str, from_none], obj.get("detectedAt"))
        obfuscated_secret = from_union([from_str, from_none], obj.get("obfuscatedSecret"))
        occurrences = from_union([from_float, from_none], obj.get("occurrences"))
        resolution = from_union([ResolutionEnum, from_none], obj.get("resolution"))
        secret_hash = from_union([from_str, from_none], obj.get("secretHash"))
        secret_id = from_union([from_str, from_none], obj.get("secretId"))
        secret_type = from_union([from_str, from_none], obj.get("secretType"))
        workspace_id = from_union([from_str, from_none], obj.get("workspaceId"))
        workspace_visibility = from_union([WorkspaceVisibility, from_none], obj.get("workspaceVisibility"))
        return PostDetectedSecretsQueriesResponseDataItem(detected_at, obfuscated_secret, occurrences, resolution, secret_hash, secret_id, secret_type, workspace_id, workspace_visibility)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detected_at is not None:
            result["detectedAt"] = from_union([from_str, from_none], self.detected_at)
        if self.obfuscated_secret is not None:
            result["obfuscatedSecret"] = from_union([from_str, from_none], self.obfuscated_secret)
        if self.occurrences is not None:
            result["occurrences"] = from_union([to_float, from_none], self.occurrences)
        if self.resolution is not None:
            result["resolution"] = from_union([lambda x: to_enum(ResolutionEnum, x), from_none], self.resolution)
        if self.secret_hash is not None:
            result["secretHash"] = from_union([from_str, from_none], self.secret_hash)
        if self.secret_id is not None:
            result["secretId"] = from_union([from_str, from_none], self.secret_id)
        if self.secret_type is not None:
            result["secretType"] = from_union([from_str, from_none], self.secret_type)
        if self.workspace_id is not None:
            result["workspaceId"] = from_union([from_str, from_none], self.workspace_id)
        if self.workspace_visibility is not None:
            result["workspaceVisibility"] = from_union([lambda x: to_enum(WorkspaceVisibility, x), from_none], self.workspace_visibility)
        return result


class PostDetectedSecretsQueriesResponseMeta:
    """The response's meta information for paginated results."""
    """The maximum number of records in the paginated response."""
    limit: Optional[float]
    """The Base64-encoded value that points to the next record in the results set."""
    next_cursor: Optional[str]
    """The number of records that match the defined criteria. This will only be present if the
    `include` query parameter is specified with the `meta.total` value.
    """
    total: Optional[float]

    def __init__(self, limit: Optional[float], next_cursor: Optional[str], total: Optional[float]) -> None:
        self.limit = limit
        self.next_cursor = next_cursor
        self.total = total

    @staticmethod
    def from_dict(obj: Any) -> 'PostDetectedSecretsQueriesResponseMeta':
        assert isinstance(obj, dict)
        limit = from_union([from_float, from_none], obj.get("limit"))
        next_cursor = from_union([from_none, from_str], obj.get("nextCursor"))
        total = from_union([from_float, from_none], obj.get("total"))
        return PostDetectedSecretsQueriesResponseMeta(limit, next_cursor, total)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.limit is not None:
            result["limit"] = from_union([to_float, from_none], self.limit)
        if self.next_cursor is not None:
            result["nextCursor"] = from_union([from_none, from_str], self.next_cursor)
        if self.total is not None:
            result["total"] = from_union([to_float, from_none], self.total)
        return result


class PostDetectedSecretsQueriesResponse:
    data: Optional[List[PostDetectedSecretsQueriesResponseDataItem]]
    """The response's meta information for paginated results."""
    meta: Optional[PostDetectedSecretsQueriesResponseMeta]

    def __init__(self, data: Optional[List[PostDetectedSecretsQueriesResponseDataItem]], meta: Optional[PostDetectedSecretsQueriesResponseMeta]) -> None:
        self.data = data
        self.meta = meta

    @staticmethod
    def from_dict(obj: Any) -> 'PostDetectedSecretsQueriesResponse':
        assert isinstance(obj, dict)
        data = from_union([lambda x: from_list(PostDetectedSecretsQueriesResponseDataItem.from_dict, x), from_none], obj.get("data"))
        meta = from_union([PostDetectedSecretsQueriesResponseMeta.from_dict, from_none], obj.get("meta"))
        return PostDetectedSecretsQueriesResponse(data, meta)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: from_list(lambda x: to_class(PostDetectedSecretsQueriesResponseDataItem, x), x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(PostDetectedSecretsQueriesResponseMeta, x), from_none], self.meta)
        return result


class PostDetectedSecretsQueriesResponse400:
    """The instance identifying the specific occurrence of the problem."""
    instance: Optional[str]
    """The HTTP status code generated by the origin server."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostDetectedSecretsQueriesResponse400':
        assert isinstance(obj, dict)
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostDetectedSecretsQueriesResponse400(instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostDetectedSecretsQueriesResponse401:
    """The instance identifying the specific occurrence of the problem."""
    instance: Optional[str]
    """The HTTP status code generated by the origin server."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostDetectedSecretsQueriesResponse401':
        assert isinstance(obj, dict)
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostDetectedSecretsQueriesResponse401(instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostDetectedSecretsQueriesResponse403:
    """The instance identifying the specific occurrence of the problem."""
    instance: Optional[str]
    """The HTTP status code generated by the origin server."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostDetectedSecretsQueriesResponse403':
        assert isinstance(obj, dict)
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostDetectedSecretsQueriesResponse403(instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostDetectedSecretsQueriesResponse500:
    """The instance identifying the specific occurrence of the problem."""
    instance: Optional[str]
    """The HTTP status code generated by the origin server."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostDetectedSecretsQueriesResponse500':
        assert isinstance(obj, dict)
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PostDetectedSecretsQueriesResponse500(instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PostEnvironmentsBodyEnvironmentValuesItemItem:
    """If true, the variable is enabled."""
    enabled: Optional[bool]
    """The variable's name."""
    key: Optional[str]
    """The variable type."""
    type: Optional[PurpleType]
    """The variable's value."""
    value: Optional[str]

    def __init__(self, enabled: Optional[bool], key: Optional[str], type: Optional[PurpleType], value: Optional[str]) -> None:
        self.enabled = enabled
        self.key = key
        self.type = type
        self.value = value

    @staticmethod
    def from_dict(obj: Any) -> 'PostEnvironmentsBodyEnvironmentValuesItemItem':
        assert isinstance(obj, dict)
        enabled = from_union([from_bool, from_none], obj.get("enabled"))
        key = from_union([from_str, from_none], obj.get("key"))
        type = from_union([PurpleType, from_none], obj.get("type"))
        value = from_union([from_str, from_none], obj.get("value"))
        return PostEnvironmentsBodyEnvironmentValuesItemItem(enabled, key, type, value)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.enabled is not None:
            result["enabled"] = from_union([from_bool, from_none], self.enabled)
        if self.key is not None:
            result["key"] = from_union([from_str, from_none], self.key)
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(PurpleType, x), from_none], self.type)
        if self.value is not None:
            result["value"] = from_union([from_str, from_none], self.value)
        return result


class PostEnvironmentsBodyEnvironment:
    """The environment's name."""
    name: str
    """Information about the environment's variables."""
    values: Optional[List[List[PostEnvironmentsBodyEnvironmentValuesItemItem]]]

    def __init__(self, name: str, values: Optional[List[List[PostEnvironmentsBodyEnvironmentValuesItemItem]]]) -> None:
        self.name = name
        self.values = values

    @staticmethod
    def from_dict(obj: Any) -> 'PostEnvironmentsBodyEnvironment':
        assert isinstance(obj, dict)
        name = from_str(obj.get("name"))
        values = from_union([lambda x: from_list(lambda x: from_list(PostEnvironmentsBodyEnvironmentValuesItemItem.from_dict, x), x), from_none], obj.get("values"))
        return PostEnvironmentsBodyEnvironment(name, values)

    def to_dict(self) -> dict:
        result: dict = {}
        result["name"] = from_str(self.name)
        if self.values is not None:
            result["values"] = from_union([lambda x: from_list(lambda x: from_list(lambda x: to_class(PostEnvironmentsBodyEnvironmentValuesItemItem, x), x), x), from_none], self.values)
        return result


class PostEnvironmentsBody:
    environment: Optional[PostEnvironmentsBodyEnvironment]

    def __init__(self, environment: Optional[PostEnvironmentsBodyEnvironment]) -> None:
        self.environment = environment

    @staticmethod
    def from_dict(obj: Any) -> 'PostEnvironmentsBody':
        assert isinstance(obj, dict)
        environment = from_union([PostEnvironmentsBodyEnvironment.from_dict, from_none], obj.get("environment"))
        return PostEnvironmentsBody(environment)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.environment is not None:
            result["environment"] = from_union([lambda x: to_class(PostEnvironmentsBodyEnvironment, x), from_none], self.environment)
        return result


class PostEnvironmentsResponseEnvironment:
    """The environment's ID."""
    id: Optional[str]
    """The environment's name."""
    name: Optional[str]
    """The environment's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.name = name
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'PostEnvironmentsResponseEnvironment':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return PostEnvironmentsResponseEnvironment(id, name, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class PostEnvironmentsResponse:
    environment: Optional[PostEnvironmentsResponseEnvironment]

    def __init__(self, environment: Optional[PostEnvironmentsResponseEnvironment]) -> None:
        self.environment = environment

    @staticmethod
    def from_dict(obj: Any) -> 'PostEnvironmentsResponse':
        assert isinstance(obj, dict)
        environment = from_union([PostEnvironmentsResponseEnvironment.from_dict, from_none], obj.get("environment"))
        return PostEnvironmentsResponse(environment)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.environment is not None:
            result["environment"] = from_union([lambda x: to_class(PostEnvironmentsResponseEnvironment, x), from_none], self.environment)
        return result


class PostEnvironmentsResponse400Error:
    details: Optional[List[str]]
    message: Optional[str]
    name: Optional[str]

    def __init__(self, details: Optional[List[str]], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostEnvironmentsResponse400Error':
        assert isinstance(obj, dict)
        details = from_union([lambda x: from_list(from_str, x), from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostEnvironmentsResponse400Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: from_list(from_str, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostEnvironmentsResponse400:
    error: Optional[PostEnvironmentsResponse400Error]

    def __init__(self, error: Optional[PostEnvironmentsResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostEnvironmentsResponse400':
        assert isinstance(obj, dict)
        error = from_union([PostEnvironmentsResponse400Error.from_dict, from_none], obj.get("error"))
        return PostEnvironmentsResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostEnvironmentsResponse400Error, x), from_none], self.error)
        return result


class PostEnvironmentsResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostEnvironmentsResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostEnvironmentsResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostEnvironmentsResponse401:
    error: Optional[PostEnvironmentsResponse401Error]

    def __init__(self, error: Optional[PostEnvironmentsResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostEnvironmentsResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostEnvironmentsResponse401Error.from_dict, from_none], obj.get("error"))
        return PostEnvironmentsResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostEnvironmentsResponse401Error, x), from_none], self.error)
        return result


class PostEnvironmentsResponse403Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostEnvironmentsResponse403Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostEnvironmentsResponse403Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostEnvironmentsResponse403:
    error: Optional[PostEnvironmentsResponse403Error]

    def __init__(self, error: Optional[PostEnvironmentsResponse403Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostEnvironmentsResponse403':
        assert isinstance(obj, dict)
        error = from_union([PostEnvironmentsResponse403Error.from_dict, from_none], obj.get("error"))
        return PostEnvironmentsResponse403(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostEnvironmentsResponse403Error, x), from_none], self.error)
        return result


class PostEnvironmentsResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PostEnvironmentsResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PostEnvironmentsResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PostEnvironmentsResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostEnvironmentsResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostEnvironmentsResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostEnvironmentsResponse500:
    error: Optional[PostEnvironmentsResponse500Error]

    def __init__(self, error: Optional[PostEnvironmentsResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostEnvironmentsResponse500':
        assert isinstance(obj, dict)
        error = from_union([PostEnvironmentsResponse500Error.from_dict, from_none], obj.get("error"))
        return PostEnvironmentsResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostEnvironmentsResponse500Error, x), from_none], self.error)
        return result


class PostImportOpenapiResponseCollectionsItem:
    """The collection's ID."""
    id: Optional[str]
    """The collection's name."""
    name: Optional[str]
    """The collection's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.name = name
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'PostImportOpenapiResponseCollectionsItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return PostImportOpenapiResponseCollectionsItem(id, name, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class PostImportOpenapiResponse:
    collections: Optional[List[PostImportOpenapiResponseCollectionsItem]]

    def __init__(self, collections: Optional[List[PostImportOpenapiResponseCollectionsItem]]) -> None:
        self.collections = collections

    @staticmethod
    def from_dict(obj: Any) -> 'PostImportOpenapiResponse':
        assert isinstance(obj, dict)
        collections = from_union([lambda x: from_list(PostImportOpenapiResponseCollectionsItem.from_dict, x), from_none], obj.get("collections"))
        return PostImportOpenapiResponse(collections)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collections is not None:
            result["collections"] = from_union([lambda x: from_list(lambda x: to_class(PostImportOpenapiResponseCollectionsItem, x), x), from_none], self.collections)
        return result


class PostImportOpenapiResponse400ErrorDetails:
    """Information about the error."""
    """The parameter name."""
    param: Optional[str]

    def __init__(self, param: Optional[str]) -> None:
        self.param = param

    @staticmethod
    def from_dict(obj: Any) -> 'PostImportOpenapiResponse400ErrorDetails':
        assert isinstance(obj, dict)
        param = from_union([from_str, from_none], obj.get("param"))
        return PostImportOpenapiResponse400ErrorDetails(param)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.param is not None:
            result["param"] = from_union([from_str, from_none], self.param)
        return result


class PostImportOpenapiResponse400Error:
    """Information about the error."""
    details: Optional[PostImportOpenapiResponse400ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PostImportOpenapiResponse400ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostImportOpenapiResponse400Error':
        assert isinstance(obj, dict)
        details = from_union([PostImportOpenapiResponse400ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostImportOpenapiResponse400Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PostImportOpenapiResponse400ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostImportOpenapiResponse400:
    error: Optional[PostImportOpenapiResponse400Error]

    def __init__(self, error: Optional[PostImportOpenapiResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostImportOpenapiResponse400':
        assert isinstance(obj, dict)
        error = from_union([PostImportOpenapiResponse400Error.from_dict, from_none], obj.get("error"))
        return PostImportOpenapiResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostImportOpenapiResponse400Error, x), from_none], self.error)
        return result


class PostImportOpenapiResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostImportOpenapiResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostImportOpenapiResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostImportOpenapiResponse401:
    error: Optional[PostImportOpenapiResponse401Error]

    def __init__(self, error: Optional[PostImportOpenapiResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostImportOpenapiResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostImportOpenapiResponse401Error.from_dict, from_none], obj.get("error"))
        return PostImportOpenapiResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostImportOpenapiResponse401Error, x), from_none], self.error)
        return result


class PostImportOpenapiResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PostImportOpenapiResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PostImportOpenapiResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PostImportOpenapiResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostImportOpenapiResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostImportOpenapiResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostImportOpenapiResponse500:
    error: Optional[PostImportOpenapiResponse500Error]

    def __init__(self, error: Optional[PostImportOpenapiResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostImportOpenapiResponse500':
        assert isinstance(obj, dict)
        error = from_union([PostImportOpenapiResponse500Error.from_dict, from_none], obj.get("error"))
        return PostImportOpenapiResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostImportOpenapiResponse500Error, x), from_none], self.error)
        return result


class PostMocksBodyMock:
    """The mock's associated collection unique ID."""
    collection: str
    """The mock server's associated environment ID."""
    environment: Optional[str]
    """The mock server's name."""
    name: Optional[str]
    """If true, the mock server is set private. By default, mock servers are public and can
    receive requests from anyone and anywhere.
    """
    private: Optional[bool]

    def __init__(self, collection: str, environment: Optional[str], name: Optional[str], private: Optional[bool]) -> None:
        self.collection = collection
        self.environment = environment
        self.name = name
        self.private = private

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksBodyMock':
        assert isinstance(obj, dict)
        collection = from_str(obj.get("collection"))
        environment = from_union([from_str, from_none], obj.get("environment"))
        name = from_union([from_str, from_none], obj.get("name"))
        private = from_union([from_bool, from_none], obj.get("private"))
        return PostMocksBodyMock(collection, environment, name, private)

    def to_dict(self) -> dict:
        result: dict = {}
        result["collection"] = from_str(self.collection)
        if self.environment is not None:
            result["environment"] = from_union([from_str, from_none], self.environment)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.private is not None:
            result["private"] = from_union([from_bool, from_none], self.private)
        return result


class PostMocksBody:
    mock: Optional[PostMocksBodyMock]

    def __init__(self, mock: Optional[PostMocksBodyMock]) -> None:
        self.mock = mock

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksBody':
        assert isinstance(obj, dict)
        mock = from_union([PostMocksBodyMock.from_dict, from_none], obj.get("mock"))
        return PostMocksBody(mock)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.mock is not None:
            result["mock"] = from_union([lambda x: to_class(PostMocksBodyMock, x), from_none], self.mock)
        return result


class PostMocksMockIDPublishResponseMock:
    """The mock server's ID."""
    id: Optional[str]

    def __init__(self, id: Optional[str]) -> None:
        self.id = id

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDPublishResponseMock':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        return PostMocksMockIDPublishResponseMock(id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        return result


class PostMocksMockIDPublishResponse:
    mock: Optional[PostMocksMockIDPublishResponseMock]

    def __init__(self, mock: Optional[PostMocksMockIDPublishResponseMock]) -> None:
        self.mock = mock

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDPublishResponse':
        assert isinstance(obj, dict)
        mock = from_union([PostMocksMockIDPublishResponseMock.from_dict, from_none], obj.get("mock"))
        return PostMocksMockIDPublishResponse(mock)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.mock is not None:
            result["mock"] = from_union([lambda x: to_class(PostMocksMockIDPublishResponseMock, x), from_none], self.mock)
        return result


class PostMocksMockIDPublishResponse400Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDPublishResponse400Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMocksMockIDPublishResponse400Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMocksMockIDPublishResponse400:
    error: Optional[PostMocksMockIDPublishResponse400Error]

    def __init__(self, error: Optional[PostMocksMockIDPublishResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDPublishResponse400':
        assert isinstance(obj, dict)
        error = from_union([PostMocksMockIDPublishResponse400Error.from_dict, from_none], obj.get("error"))
        return PostMocksMockIDPublishResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMocksMockIDPublishResponse400Error, x), from_none], self.error)
        return result


class PostMocksMockIDPublishResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDPublishResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMocksMockIDPublishResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMocksMockIDPublishResponse401:
    error: Optional[PostMocksMockIDPublishResponse401Error]

    def __init__(self, error: Optional[PostMocksMockIDPublishResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDPublishResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostMocksMockIDPublishResponse401Error.from_dict, from_none], obj.get("error"))
        return PostMocksMockIDPublishResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMocksMockIDPublishResponse401Error, x), from_none], self.error)
        return result


class PostMocksMockIDPublishResponse404Error:
    """Information about the error."""
    details: Optional[List[str]]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[List[str]], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDPublishResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([lambda x: from_list(from_str, x), from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMocksMockIDPublishResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: from_list(from_str, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMocksMockIDPublishResponse404:
    error: Optional[PostMocksMockIDPublishResponse404Error]

    def __init__(self, error: Optional[PostMocksMockIDPublishResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDPublishResponse404':
        assert isinstance(obj, dict)
        error = from_union([PostMocksMockIDPublishResponse404Error.from_dict, from_none], obj.get("error"))
        return PostMocksMockIDPublishResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMocksMockIDPublishResponse404Error, x), from_none], self.error)
        return result


class PostMocksMockIDPublishResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDPublishResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PostMocksMockIDPublishResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PostMocksMockIDPublishResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDPublishResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMocksMockIDPublishResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMocksMockIDPublishResponse500:
    error: Optional[PostMocksMockIDPublishResponse500Error]

    def __init__(self, error: Optional[PostMocksMockIDPublishResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDPublishResponse500':
        assert isinstance(obj, dict)
        error = from_union([PostMocksMockIDPublishResponse500Error.from_dict, from_none], obj.get("error"))
        return PostMocksMockIDPublishResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMocksMockIDPublishResponse500Error, x), from_none], self.error)
        return result


class PostMocksMockIDServerResponsesBodyServerResponseHeadersItem:
    """The request header's key value."""
    key: Optional[str]
    """The request header's value."""
    value: Optional[str]

    def __init__(self, key: Optional[str], value: Optional[str]) -> None:
        self.key = key
        self.value = value

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDServerResponsesBodyServerResponseHeadersItem':
        assert isinstance(obj, dict)
        key = from_union([from_str, from_none], obj.get("key"))
        value = from_union([from_str, from_none], obj.get("value"))
        return PostMocksMockIDServerResponsesBodyServerResponseHeadersItem(key, value)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.key is not None:
            result["key"] = from_union([from_str, from_none], self.key)
        if self.value is not None:
            result["value"] = from_union([from_str, from_none], self.value)
        return result


class PostMocksMockIDServerResponsesBodyServerResponse:
    """The server response's body that returns when calling the mock server."""
    body: Optional[str]
    """The server response's request headers, such as Content-Type, Accept, encoding, and other
    information.
    """
    headers: Optional[List[PostMocksMockIDServerResponsesBodyServerResponseHeadersItem]]
    """The server response's body language type."""
    language: Optional[DeleteMocksMockIDServerResponsesServerResponseIDResponseLanguage]
    """The server response's name."""
    name: str
    """The server response's 5xx HTTP response code. This property **only** accepts 5xx values."""
    status_code: int

    def __init__(self, body: Optional[str], headers: Optional[List[PostMocksMockIDServerResponsesBodyServerResponseHeadersItem]], language: Optional[DeleteMocksMockIDServerResponsesServerResponseIDResponseLanguage], name: str, status_code: int) -> None:
        self.body = body
        self.headers = headers
        self.language = language
        self.name = name
        self.status_code = status_code

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDServerResponsesBodyServerResponse':
        assert isinstance(obj, dict)
        body = from_union([from_str, from_none], obj.get("body"))
        headers = from_union([lambda x: from_list(PostMocksMockIDServerResponsesBodyServerResponseHeadersItem.from_dict, x), from_none], obj.get("headers"))
        language = from_union([DeleteMocksMockIDServerResponsesServerResponseIDResponseLanguage, from_none], obj.get("language"))
        name = from_str(obj.get("name"))
        status_code = from_int(obj.get("statusCode"))
        return PostMocksMockIDServerResponsesBodyServerResponse(body, headers, language, name, status_code)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.body is not None:
            result["body"] = from_union([from_str, from_none], self.body)
        if self.headers is not None:
            result["headers"] = from_union([lambda x: from_list(lambda x: to_class(PostMocksMockIDServerResponsesBodyServerResponseHeadersItem, x), x), from_none], self.headers)
        if self.language is not None:
            result["language"] = from_union([lambda x: to_enum(DeleteMocksMockIDServerResponsesServerResponseIDResponseLanguage, x), from_none], self.language)
        result["name"] = from_str(self.name)
        result["statusCode"] = from_int(self.status_code)
        return result


class PostMocksMockIDServerResponsesBody:
    server_response: Optional[PostMocksMockIDServerResponsesBodyServerResponse]

    def __init__(self, server_response: Optional[PostMocksMockIDServerResponsesBodyServerResponse]) -> None:
        self.server_response = server_response

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDServerResponsesBody':
        assert isinstance(obj, dict)
        server_response = from_union([PostMocksMockIDServerResponsesBodyServerResponse.from_dict, from_none], obj.get("serverResponse"))
        return PostMocksMockIDServerResponsesBody(server_response)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.server_response is not None:
            result["serverResponse"] = from_union([lambda x: to_class(PostMocksMockIDServerResponsesBodyServerResponse, x), from_none], self.server_response)
        return result


class PostMocksMockIDServerResponsesResponse400ErrorDetails:
    """Information about the error."""
    """Information about the missing parameter."""
    param: Optional[List[str]]

    def __init__(self, param: Optional[List[str]]) -> None:
        self.param = param

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDServerResponsesResponse400ErrorDetails':
        assert isinstance(obj, dict)
        param = from_union([lambda x: from_list(from_str, x), from_none], obj.get("param"))
        return PostMocksMockIDServerResponsesResponse400ErrorDetails(param)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.param is not None:
            result["param"] = from_union([lambda x: from_list(from_str, x), from_none], self.param)
        return result


class PostMocksMockIDServerResponsesResponse400Error:
    """Information about the error."""
    details: Optional[PostMocksMockIDServerResponsesResponse400ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PostMocksMockIDServerResponsesResponse400ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDServerResponsesResponse400Error':
        assert isinstance(obj, dict)
        details = from_union([PostMocksMockIDServerResponsesResponse400ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMocksMockIDServerResponsesResponse400Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PostMocksMockIDServerResponsesResponse400ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMocksMockIDServerResponsesResponse400:
    error: Optional[PostMocksMockIDServerResponsesResponse400Error]

    def __init__(self, error: Optional[PostMocksMockIDServerResponsesResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDServerResponsesResponse400':
        assert isinstance(obj, dict)
        error = from_union([PostMocksMockIDServerResponsesResponse400Error.from_dict, from_none], obj.get("error"))
        return PostMocksMockIDServerResponsesResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMocksMockIDServerResponsesResponse400Error, x), from_none], self.error)
        return result


class PostMocksMockIDServerResponsesResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDServerResponsesResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMocksMockIDServerResponsesResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMocksMockIDServerResponsesResponse401:
    error: Optional[PostMocksMockIDServerResponsesResponse401Error]

    def __init__(self, error: Optional[PostMocksMockIDServerResponsesResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDServerResponsesResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostMocksMockIDServerResponsesResponse401Error.from_dict, from_none], obj.get("error"))
        return PostMocksMockIDServerResponsesResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMocksMockIDServerResponsesResponse401Error, x), from_none], self.error)
        return result


class PostMocksMockIDServerResponsesResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDServerResponsesResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PostMocksMockIDServerResponsesResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PostMocksMockIDServerResponsesResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDServerResponsesResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMocksMockIDServerResponsesResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMocksMockIDServerResponsesResponse500:
    error: Optional[PostMocksMockIDServerResponsesResponse500Error]

    def __init__(self, error: Optional[PostMocksMockIDServerResponsesResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDServerResponsesResponse500':
        assert isinstance(obj, dict)
        error = from_union([PostMocksMockIDServerResponsesResponse500Error.from_dict, from_none], obj.get("error"))
        return PostMocksMockIDServerResponsesResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMocksMockIDServerResponsesResponse500Error, x), from_none], self.error)
        return result


class PostMocksMockIDServerResponsesResponseItem:
    """Information about the server response."""
    """The date and time at which the server response was created."""
    created_at: Optional[str]
    """The user ID of the user who created the server response."""
    created_by: Optional[str]
    """The server response's ID."""
    id: Optional[str]
    """The server response's name."""
    name: Optional[str]
    """The server response's 5xx HTTP response code."""
    status_code: Optional[float]
    """The date and time at which the server response was last updated."""
    updated_at: Optional[str]
    """The user ID of the user who last updated the server response."""
    updated_by: Optional[str]

    def __init__(self, created_at: Optional[str], created_by: Optional[str], id: Optional[str], name: Optional[str], status_code: Optional[float], updated_at: Optional[str], updated_by: Optional[str]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.id = id
        self.name = name
        self.status_code = status_code
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksMockIDServerResponsesResponseItem':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_str, from_none], obj.get("createdBy"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        status_code = from_union([from_float, from_none], obj.get("statusCode"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_str, from_none], obj.get("updatedBy"))
        return PostMocksMockIDServerResponsesResponseItem(created_at, created_by, id, name, status_code, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_str, from_none], self.created_by)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.status_code is not None:
            result["statusCode"] = from_union([to_float, from_none], self.status_code)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_str, from_none], self.updated_by)
        return result


class PostMocksResponseMockConfigDelay:
    """The configured delay, in milliseconds."""
    duration: Optional[int]
    """The simulated fixed network delay value:
    
    - `1`  2G (300 ms).
    - `2`  3G (100 ms).
    
    The object does not return this value for custom delay values.
    """
    preset: Optional[Preset]
    """The type of simulated delay value:
    
    - `fixed`  The delay value is a fixed value.
    """
    type: Optional[GetMocksResponseMocksItemConfigDelayType]

    def __init__(self, duration: Optional[int], preset: Optional[Preset], type: Optional[GetMocksResponseMocksItemConfigDelayType]) -> None:
        self.duration = duration
        self.preset = preset
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksResponseMockConfigDelay':
        assert isinstance(obj, dict)
        duration = from_union([from_int, from_none], obj.get("duration"))
        preset = from_union([Preset, from_none], obj.get("preset"))
        type = from_union([GetMocksResponseMocksItemConfigDelayType, from_none], obj.get("type"))
        return PostMocksResponseMockConfigDelay(duration, preset, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.duration is not None:
            result["duration"] = from_union([from_int, from_none], self.duration)
        if self.preset is not None:
            result["preset"] = from_union([lambda x: to_enum(Preset, x), from_none], self.preset)
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(GetMocksResponseMocksItemConfigDelayType, x), from_none], self.type)
        return result


class PostMocksResponseMockConfig:
    """Information about the mock server's configuration."""
    """Information about the mock server's simulated network delay settings. This returns a null
    value if there are no configured network delay settings.
    """
    delay: Optional[PostMocksResponseMockConfigDelay]
    """A list of the mock server's headers."""
    headers: Optional[List[str]]
    """If true, match the request body."""
    match_body: Optional[bool]
    """If true, match query parameters."""
    match_query_params: Optional[bool]
    """If true, use wildcard variable matching."""
    match_wildcards: Optional[bool]
    """The ID of mock server's default response for requests. All calls to the mock server will
    return the defined response.
    """
    server_response_id: Optional[str]

    def __init__(self, delay: Optional[PostMocksResponseMockConfigDelay], headers: Optional[List[str]], match_body: Optional[bool], match_query_params: Optional[bool], match_wildcards: Optional[bool], server_response_id: Optional[str]) -> None:
        self.delay = delay
        self.headers = headers
        self.match_body = match_body
        self.match_query_params = match_query_params
        self.match_wildcards = match_wildcards
        self.server_response_id = server_response_id

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksResponseMockConfig':
        assert isinstance(obj, dict)
        delay = from_union([from_none, PostMocksResponseMockConfigDelay.from_dict], obj.get("delay"))
        headers = from_union([lambda x: from_list(from_str, x), from_none], obj.get("headers"))
        match_body = from_union([from_bool, from_none], obj.get("matchBody"))
        match_query_params = from_union([from_bool, from_none], obj.get("matchQueryParams"))
        match_wildcards = from_union([from_bool, from_none], obj.get("matchWildcards"))
        server_response_id = from_union([from_none, from_str], obj.get("serverResponseId"))
        return PostMocksResponseMockConfig(delay, headers, match_body, match_query_params, match_wildcards, server_response_id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.delay is not None:
            result["delay"] = from_union([from_none, lambda x: to_class(PostMocksResponseMockConfigDelay, x)], self.delay)
        if self.headers is not None:
            result["headers"] = from_union([lambda x: from_list(from_str, x), from_none], self.headers)
        if self.match_body is not None:
            result["matchBody"] = from_union([from_bool, from_none], self.match_body)
        if self.match_query_params is not None:
            result["matchQueryParams"] = from_union([from_bool, from_none], self.match_query_params)
        if self.match_wildcards is not None:
            result["matchWildcards"] = from_union([from_bool, from_none], self.match_wildcards)
        if self.server_response_id is not None:
            result["serverResponseId"] = from_union([from_none, from_str], self.server_response_id)
        return result


class PostMocksResponseMock:
    """The mock's associated collection unique ID."""
    collection: Optional[str]
    """Information about the mock server's configuration."""
    config: Optional[PostMocksResponseMockConfig]
    """The date and time at which the mock server was created."""
    created_at: Optional[str]
    """The mock's associated environment unique ID."""
    environment: Optional[str]
    """The mock server's ID."""
    id: Optional[str]
    """The mock server URL."""
    mock_url: Optional[str]
    """The ID of mock server's owner."""
    owner: Optional[str]
    """The mock server's unique ID."""
    uid: Optional[str]
    """The date and time at which the mock server was last updated."""
    updated_at: Optional[str]

    def __init__(self, collection: Optional[str], config: Optional[PostMocksResponseMockConfig], created_at: Optional[str], environment: Optional[str], id: Optional[str], mock_url: Optional[str], owner: Optional[str], uid: Optional[str], updated_at: Optional[str]) -> None:
        self.collection = collection
        self.config = config
        self.created_at = created_at
        self.environment = environment
        self.id = id
        self.mock_url = mock_url
        self.owner = owner
        self.uid = uid
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksResponseMock':
        assert isinstance(obj, dict)
        collection = from_union([from_str, from_none], obj.get("collection"))
        config = from_union([PostMocksResponseMockConfig.from_dict, from_none], obj.get("config"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        environment = from_union([from_str, from_none], obj.get("environment"))
        id = from_union([from_str, from_none], obj.get("id"))
        mock_url = from_union([from_str, from_none], obj.get("mockUrl"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return PostMocksResponseMock(collection, config, created_at, environment, id, mock_url, owner, uid, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([from_str, from_none], self.collection)
        if self.config is not None:
            result["config"] = from_union([lambda x: to_class(PostMocksResponseMockConfig, x), from_none], self.config)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.environment is not None:
            result["environment"] = from_union([from_str, from_none], self.environment)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.mock_url is not None:
            result["mockUrl"] = from_union([from_str, from_none], self.mock_url)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class PostMocksResponse:
    mock: Optional[PostMocksResponseMock]

    def __init__(self, mock: Optional[PostMocksResponseMock]) -> None:
        self.mock = mock

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksResponse':
        assert isinstance(obj, dict)
        mock = from_union([PostMocksResponseMock.from_dict, from_none], obj.get("mock"))
        return PostMocksResponse(mock)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.mock is not None:
            result["mock"] = from_union([lambda x: to_class(PostMocksResponseMock, x), from_none], self.mock)
        return result


class PostMocksResponse400ErrorDetails:
    """Information about the error."""
    """Information about the missing parameter."""
    param: Optional[List[str]]

    def __init__(self, param: Optional[List[str]]) -> None:
        self.param = param

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksResponse400ErrorDetails':
        assert isinstance(obj, dict)
        param = from_union([lambda x: from_list(from_str, x), from_none], obj.get("param"))
        return PostMocksResponse400ErrorDetails(param)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.param is not None:
            result["param"] = from_union([lambda x: from_list(from_str, x), from_none], self.param)
        return result


class PostMocksResponse400Error:
    """Information about the error."""
    details: Optional[PostMocksResponse400ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PostMocksResponse400ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksResponse400Error':
        assert isinstance(obj, dict)
        details = from_union([PostMocksResponse400ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMocksResponse400Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PostMocksResponse400ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMocksResponse400:
    error: Optional[PostMocksResponse400Error]

    def __init__(self, error: Optional[PostMocksResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksResponse400':
        assert isinstance(obj, dict)
        error = from_union([PostMocksResponse400Error.from_dict, from_none], obj.get("error"))
        return PostMocksResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMocksResponse400Error, x), from_none], self.error)
        return result


class PostMocksResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMocksResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMocksResponse401:
    error: Optional[PostMocksResponse401Error]

    def __init__(self, error: Optional[PostMocksResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostMocksResponse401Error.from_dict, from_none], obj.get("error"))
        return PostMocksResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMocksResponse401Error, x), from_none], self.error)
        return result


class PostMocksResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PostMocksResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PostMocksResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMocksResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMocksResponse500:
    error: Optional[PostMocksResponse500Error]

    def __init__(self, error: Optional[PostMocksResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMocksResponse500':
        assert isinstance(obj, dict)
        error = from_union([PostMocksResponse500Error.from_dict, from_none], obj.get("error"))
        return PostMocksResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMocksResponse500Error, x), from_none], self.error)
        return result


class PostMonitorsBodyMonitorSchedule:
    """Information about the monitor's schedule."""
    """The monitor's run frequency, based on the given cron pattern.
    At this time you can only create monitors with limited schedules. For information about
    the available schedules, see our [Postman Monitors](https://monitor.getpostman.com)
    collection.
    """
    cron: Optional[str]
    """The monitor's [timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)."""
    timezone: Optional[str]

    def __init__(self, cron: Optional[str], timezone: Optional[str]) -> None:
        self.cron = cron
        self.timezone = timezone

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsBodyMonitorSchedule':
        assert isinstance(obj, dict)
        cron = from_union([from_str, from_none], obj.get("cron"))
        timezone = from_union([from_str, from_none], obj.get("timezone"))
        return PostMonitorsBodyMonitorSchedule(cron, timezone)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.cron is not None:
            result["cron"] = from_union([from_str, from_none], self.cron)
        if self.timezone is not None:
            result["timezone"] = from_union([from_str, from_none], self.timezone)
        return result


class PostMonitorsBodyMonitor:
    """The monitor's associated collection unique ID."""
    collection: Optional[str]
    """The monitor's associated environment unique ID."""
    environment: Optional[str]
    """The monitor's name."""
    name: Optional[str]
    """Information about the monitor's schedule."""
    schedule: Optional[PostMonitorsBodyMonitorSchedule]

    def __init__(self, collection: Optional[str], environment: Optional[str], name: Optional[str], schedule: Optional[PostMonitorsBodyMonitorSchedule]) -> None:
        self.collection = collection
        self.environment = environment
        self.name = name
        self.schedule = schedule

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsBodyMonitor':
        assert isinstance(obj, dict)
        collection = from_union([from_str, from_none], obj.get("collection"))
        environment = from_union([from_str, from_none], obj.get("environment"))
        name = from_union([from_str, from_none], obj.get("name"))
        schedule = from_union([PostMonitorsBodyMonitorSchedule.from_dict, from_none], obj.get("schedule"))
        return PostMonitorsBodyMonitor(collection, environment, name, schedule)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([from_str, from_none], self.collection)
        if self.environment is not None:
            result["environment"] = from_union([from_str, from_none], self.environment)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.schedule is not None:
            result["schedule"] = from_union([lambda x: to_class(PostMonitorsBodyMonitorSchedule, x), from_none], self.schedule)
        return result


class PostMonitorsBody:
    monitor: Optional[PostMonitorsBodyMonitor]

    def __init__(self, monitor: Optional[PostMonitorsBodyMonitor]) -> None:
        self.monitor = monitor

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsBody':
        assert isinstance(obj, dict)
        monitor = from_union([PostMonitorsBodyMonitor.from_dict, from_none], obj.get("monitor"))
        return PostMonitorsBody(monitor)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.monitor is not None:
            result["monitor"] = from_union([lambda x: to_class(PostMonitorsBodyMonitor, x), from_none], self.monitor)
        return result


class PostMonitorsMonitorIDRunResponseRunExecutionsItemItem:
    """Information about the executed item."""
    """The executed item's name."""
    name: Optional[str]

    def __init__(self, name: Optional[str]) -> None:
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponseRunExecutionsItemItem':
        assert isinstance(obj, dict)
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMonitorsMonitorIDRunResponseRunExecutionsItemItem(name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMonitorsMonitorIDRunResponseRunExecutionsItemRequest:
    """Information about the monitor run's requests."""
    body: Any
    headers: Any
    """The request method."""
    method: Optional[str]
    """The date and time of the request."""
    timestamp: Optional[str]
    """The request's URL."""
    url: Optional[str]

    def __init__(self, body: Any, headers: Any, method: Optional[str], timestamp: Optional[str], url: Optional[str]) -> None:
        self.body = body
        self.headers = headers
        self.method = method
        self.timestamp = timestamp
        self.url = url

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponseRunExecutionsItemRequest':
        assert isinstance(obj, dict)
        body = obj.get("body")
        headers = obj.get("headers")
        method = from_union([from_str, from_none], obj.get("method"))
        timestamp = from_union([from_str, from_none], obj.get("timestamp"))
        url = from_union([from_str, from_none], obj.get("url"))
        return PostMonitorsMonitorIDRunResponseRunExecutionsItemRequest(body, headers, method, timestamp, url)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.body is not None:
            result["body"] = self.body
        if self.headers is not None:
            result["headers"] = self.headers
        if self.method is not None:
            result["method"] = from_union([from_str, from_none], self.method)
        if self.timestamp is not None:
            result["timestamp"] = from_union([from_str, from_none], self.timestamp)
        if self.url is not None:
            result["url"] = from_union([from_str, from_none], self.url)
        return result


class PostMonitorsMonitorIDRunResponseRunExecutionsItemResponse:
    """Information about the monitor run's response."""
    body: Any
    """The response's HTTP status code."""
    code: Optional[float]
    headers: Any
    """The response size, in bytes."""
    response_size: Optional[float]
    """The response time, in milliseconds."""
    response_time: Optional[float]

    def __init__(self, body: Any, code: Optional[float], headers: Any, response_size: Optional[float], response_time: Optional[float]) -> None:
        self.body = body
        self.code = code
        self.headers = headers
        self.response_size = response_size
        self.response_time = response_time

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponseRunExecutionsItemResponse':
        assert isinstance(obj, dict)
        body = obj.get("body")
        code = from_union([from_float, from_none], obj.get("code"))
        headers = obj.get("headers")
        response_size = from_union([from_float, from_none], obj.get("responseSize"))
        response_time = from_union([from_float, from_none], obj.get("responseTime"))
        return PostMonitorsMonitorIDRunResponseRunExecutionsItemResponse(body, code, headers, response_size, response_time)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.body is not None:
            result["body"] = self.body
        if self.code is not None:
            result["code"] = from_union([to_float, from_none], self.code)
        if self.headers is not None:
            result["headers"] = self.headers
        if self.response_size is not None:
            result["responseSize"] = from_union([to_float, from_none], self.response_size)
        if self.response_time is not None:
            result["responseTime"] = from_union([to_float, from_none], self.response_time)
        return result


class PostMonitorsMonitorIDRunResponseRunExecutionsItem:
    """The execution ID."""
    id: Optional[float]
    """Information about the executed item."""
    item: Optional[PostMonitorsMonitorIDRunResponseRunExecutionsItemItem]
    """Information about the monitor run's requests."""
    request: Optional[PostMonitorsMonitorIDRunResponseRunExecutionsItemRequest]
    """Information about the monitor run's response."""
    response: Optional[PostMonitorsMonitorIDRunResponseRunExecutionsItemResponse]

    def __init__(self, id: Optional[float], item: Optional[PostMonitorsMonitorIDRunResponseRunExecutionsItemItem], request: Optional[PostMonitorsMonitorIDRunResponseRunExecutionsItemRequest], response: Optional[PostMonitorsMonitorIDRunResponseRunExecutionsItemResponse]) -> None:
        self.id = id
        self.item = item
        self.request = request
        self.response = response

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponseRunExecutionsItem':
        assert isinstance(obj, dict)
        id = from_union([from_float, from_none], obj.get("id"))
        item = from_union([PostMonitorsMonitorIDRunResponseRunExecutionsItemItem.from_dict, from_none], obj.get("item"))
        request = from_union([PostMonitorsMonitorIDRunResponseRunExecutionsItemRequest.from_dict, from_none], obj.get("request"))
        response = from_union([PostMonitorsMonitorIDRunResponseRunExecutionsItemResponse.from_dict, from_none], obj.get("response"))
        return PostMonitorsMonitorIDRunResponseRunExecutionsItem(id, item, request, response)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([to_float, from_none], self.id)
        if self.item is not None:
            result["item"] = from_union([lambda x: to_class(PostMonitorsMonitorIDRunResponseRunExecutionsItemItem, x), from_none], self.item)
        if self.request is not None:
            result["request"] = from_union([lambda x: to_class(PostMonitorsMonitorIDRunResponseRunExecutionsItemRequest, x), from_none], self.request)
        if self.response is not None:
            result["response"] = from_union([lambda x: to_class(PostMonitorsMonitorIDRunResponseRunExecutionsItemResponse, x), from_none], self.response)
        return result


class PostMonitorsMonitorIDRunResponseRunInfo:
    """Information about the monitor."""
    """The monitor's associated collection unique ID."""
    collection_uid: Optional[str]
    """The monitor's associated environment unique ID."""
    environment_uid: Optional[str]
    """The date and time at which the monitor's run completed."""
    finished_at: Optional[str]
    """The monitor's run job ID."""
    job_id: Optional[str]
    """The monitor's ID."""
    monitor_id: Optional[str]
    """The monitor's name."""
    name: Optional[str]
    """The date and time at which the monitor run began."""
    started_at: Optional[str]
    """The monitor run's status."""
    status: Optional[str]

    def __init__(self, collection_uid: Optional[str], environment_uid: Optional[str], finished_at: Optional[str], job_id: Optional[str], monitor_id: Optional[str], name: Optional[str], started_at: Optional[str], status: Optional[str]) -> None:
        self.collection_uid = collection_uid
        self.environment_uid = environment_uid
        self.finished_at = finished_at
        self.job_id = job_id
        self.monitor_id = monitor_id
        self.name = name
        self.started_at = started_at
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponseRunInfo':
        assert isinstance(obj, dict)
        collection_uid = from_union([from_str, from_none], obj.get("collectionUid"))
        environment_uid = from_union([from_str, from_none], obj.get("environmentUid"))
        finished_at = from_union([from_str, from_none], obj.get("finishedAt"))
        job_id = from_union([from_str, from_none], obj.get("jobId"))
        monitor_id = from_union([from_str, from_none], obj.get("monitorId"))
        name = from_union([from_str, from_none], obj.get("name"))
        started_at = from_union([from_str, from_none], obj.get("startedAt"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PostMonitorsMonitorIDRunResponseRunInfo(collection_uid, environment_uid, finished_at, job_id, monitor_id, name, started_at, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection_uid is not None:
            result["collectionUid"] = from_union([from_str, from_none], self.collection_uid)
        if self.environment_uid is not None:
            result["environmentUid"] = from_union([from_str, from_none], self.environment_uid)
        if self.finished_at is not None:
            result["finishedAt"] = from_union([from_str, from_none], self.finished_at)
        if self.job_id is not None:
            result["jobId"] = from_union([from_str, from_none], self.job_id)
        if self.monitor_id is not None:
            result["monitorId"] = from_union([from_str, from_none], self.monitor_id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.started_at is not None:
            result["startedAt"] = from_union([from_str, from_none], self.started_at)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PostMonitorsMonitorIDRunResponseRunStatsAssertions:
    """The monitor run's assertions stats."""
    """The total number of test failures."""
    failed: Optional[float]
    """The total number of tests performed."""
    total: Optional[float]

    def __init__(self, failed: Optional[float], total: Optional[float]) -> None:
        self.failed = failed
        self.total = total

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponseRunStatsAssertions':
        assert isinstance(obj, dict)
        failed = from_union([from_float, from_none], obj.get("failed"))
        total = from_union([from_float, from_none], obj.get("total"))
        return PostMonitorsMonitorIDRunResponseRunStatsAssertions(failed, total)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.failed is not None:
            result["failed"] = from_union([to_float, from_none], self.failed)
        if self.total is not None:
            result["total"] = from_union([to_float, from_none], self.total)
        return result


class PostMonitorsMonitorIDRunResponseRunStatsRequests:
    """The monitor run's request stats."""
    """The number of request failures."""
    failed: Optional[float]
    """The total number of requests."""
    total: Optional[float]

    def __init__(self, failed: Optional[float], total: Optional[float]) -> None:
        self.failed = failed
        self.total = total

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponseRunStatsRequests':
        assert isinstance(obj, dict)
        failed = from_union([from_float, from_none], obj.get("failed"))
        total = from_union([from_float, from_none], obj.get("total"))
        return PostMonitorsMonitorIDRunResponseRunStatsRequests(failed, total)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.failed is not None:
            result["failed"] = from_union([to_float, from_none], self.failed)
        if self.total is not None:
            result["total"] = from_union([to_float, from_none], self.total)
        return result


class PostMonitorsMonitorIDRunResponseRunStats:
    """Information about the monitor run's stats."""
    """The monitor run's assertions stats."""
    assertions: Optional[PostMonitorsMonitorIDRunResponseRunStatsAssertions]
    """The monitor run's request stats."""
    requests: Optional[PostMonitorsMonitorIDRunResponseRunStatsRequests]

    def __init__(self, assertions: Optional[PostMonitorsMonitorIDRunResponseRunStatsAssertions], requests: Optional[PostMonitorsMonitorIDRunResponseRunStatsRequests]) -> None:
        self.assertions = assertions
        self.requests = requests

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponseRunStats':
        assert isinstance(obj, dict)
        assertions = from_union([PostMonitorsMonitorIDRunResponseRunStatsAssertions.from_dict, from_none], obj.get("assertions"))
        requests = from_union([PostMonitorsMonitorIDRunResponseRunStatsRequests.from_dict, from_none], obj.get("requests"))
        return PostMonitorsMonitorIDRunResponseRunStats(assertions, requests)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.assertions is not None:
            result["assertions"] = from_union([lambda x: to_class(PostMonitorsMonitorIDRunResponseRunStatsAssertions, x), from_none], self.assertions)
        if self.requests is not None:
            result["requests"] = from_union([lambda x: to_class(PostMonitorsMonitorIDRunResponseRunStatsRequests, x), from_none], self.requests)
        return result


class PostMonitorsMonitorIDRunResponseRun:
    """Information about the monitor run."""
    """Information about the monitor run's executions."""
    executions: Optional[List[PostMonitorsMonitorIDRunResponseRunExecutionsItem]]
    """If the monitor run failed, information about the run's failures."""
    failures: Optional[List[Any]]
    """Information about the monitor."""
    info: Optional[PostMonitorsMonitorIDRunResponseRunInfo]
    """Information about the monitor run's stats."""
    stats: Optional[PostMonitorsMonitorIDRunResponseRunStats]

    def __init__(self, executions: Optional[List[PostMonitorsMonitorIDRunResponseRunExecutionsItem]], failures: Optional[List[Any]], info: Optional[PostMonitorsMonitorIDRunResponseRunInfo], stats: Optional[PostMonitorsMonitorIDRunResponseRunStats]) -> None:
        self.executions = executions
        self.failures = failures
        self.info = info
        self.stats = stats

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponseRun':
        assert isinstance(obj, dict)
        executions = from_union([lambda x: from_list(PostMonitorsMonitorIDRunResponseRunExecutionsItem.from_dict, x), from_none], obj.get("executions"))
        failures = from_union([lambda x: from_list(lambda x: x, x), from_none], obj.get("failures"))
        info = from_union([PostMonitorsMonitorIDRunResponseRunInfo.from_dict, from_none], obj.get("info"))
        stats = from_union([PostMonitorsMonitorIDRunResponseRunStats.from_dict, from_none], obj.get("stats"))
        return PostMonitorsMonitorIDRunResponseRun(executions, failures, info, stats)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.executions is not None:
            result["executions"] = from_union([lambda x: from_list(lambda x: to_class(PostMonitorsMonitorIDRunResponseRunExecutionsItem, x), x), from_none], self.executions)
        if self.failures is not None:
            result["failures"] = from_union([lambda x: from_list(lambda x: x, x), from_none], self.failures)
        if self.info is not None:
            result["info"] = from_union([lambda x: to_class(PostMonitorsMonitorIDRunResponseRunInfo, x), from_none], self.info)
        if self.stats is not None:
            result["stats"] = from_union([lambda x: to_class(PostMonitorsMonitorIDRunResponseRunStats, x), from_none], self.stats)
        return result


class PostMonitorsMonitorIDRunResponse:
    """Information about the monitor run."""
    run: Optional[PostMonitorsMonitorIDRunResponseRun]

    def __init__(self, run: Optional[PostMonitorsMonitorIDRunResponseRun]) -> None:
        self.run = run

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponse':
        assert isinstance(obj, dict)
        run = from_union([PostMonitorsMonitorIDRunResponseRun.from_dict, from_none], obj.get("run"))
        return PostMonitorsMonitorIDRunResponse(run)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.run is not None:
            result["run"] = from_union([lambda x: to_class(PostMonitorsMonitorIDRunResponseRun, x), from_none], self.run)
        return result


class PostMonitorsMonitorIDRunResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMonitorsMonitorIDRunResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMonitorsMonitorIDRunResponse401:
    error: Optional[PostMonitorsMonitorIDRunResponse401Error]

    def __init__(self, error: Optional[PostMonitorsMonitorIDRunResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostMonitorsMonitorIDRunResponse401Error.from_dict, from_none], obj.get("error"))
        return PostMonitorsMonitorIDRunResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMonitorsMonitorIDRunResponse401Error, x), from_none], self.error)
        return result


class PostMonitorsMonitorIDRunResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PostMonitorsMonitorIDRunResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PostMonitorsMonitorIDRunResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMonitorsMonitorIDRunResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMonitorsMonitorIDRunResponse500:
    error: Optional[PostMonitorsMonitorIDRunResponse500Error]

    def __init__(self, error: Optional[PostMonitorsMonitorIDRunResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsMonitorIDRunResponse500':
        assert isinstance(obj, dict)
        error = from_union([PostMonitorsMonitorIDRunResponse500Error.from_dict, from_none], obj.get("error"))
        return PostMonitorsMonitorIDRunResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMonitorsMonitorIDRunResponse500Error, x), from_none], self.error)
        return result


class PostMonitorsResponseMonitor:
    """The monitor's ID."""
    id: Optional[str]
    """The monitor's name."""
    name: Optional[str]
    """The monitor's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.name = name
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsResponseMonitor':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return PostMonitorsResponseMonitor(id, name, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class PostMonitorsResponse:
    monitor: Optional[PostMonitorsResponseMonitor]

    def __init__(self, monitor: Optional[PostMonitorsResponseMonitor]) -> None:
        self.monitor = monitor

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsResponse':
        assert isinstance(obj, dict)
        monitor = from_union([PostMonitorsResponseMonitor.from_dict, from_none], obj.get("monitor"))
        return PostMonitorsResponse(monitor)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.monitor is not None:
            result["monitor"] = from_union([lambda x: to_class(PostMonitorsResponseMonitor, x), from_none], self.monitor)
        return result


class PostMonitorsResponse400Error:
    details: Any
    message: Optional[str]
    name: Optional[str]

    def __init__(self, details: Any, message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsResponse400Error':
        assert isinstance(obj, dict)
        details = obj.get("details")
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMonitorsResponse400Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = self.details
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMonitorsResponse400:
    error: Optional[PostMonitorsResponse400Error]

    def __init__(self, error: Optional[PostMonitorsResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsResponse400':
        assert isinstance(obj, dict)
        error = from_union([PostMonitorsResponse400Error.from_dict, from_none], obj.get("error"))
        return PostMonitorsResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMonitorsResponse400Error, x), from_none], self.error)
        return result


class PostMonitorsResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMonitorsResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMonitorsResponse401:
    error: Optional[PostMonitorsResponse401Error]

    def __init__(self, error: Optional[PostMonitorsResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostMonitorsResponse401Error.from_dict, from_none], obj.get("error"))
        return PostMonitorsResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMonitorsResponse401Error, x), from_none], self.error)
        return result


class PostMonitorsResponse403Error:
    """The error description."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsResponse403Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMonitorsResponse403Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMonitorsResponse403:
    error: Optional[PostMonitorsResponse403Error]

    def __init__(self, error: Optional[PostMonitorsResponse403Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsResponse403':
        assert isinstance(obj, dict)
        error = from_union([PostMonitorsResponse403Error.from_dict, from_none], obj.get("error"))
        return PostMonitorsResponse403(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMonitorsResponse403Error, x), from_none], self.error)
        return result


class PostMonitorsResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PostMonitorsResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PostMonitorsResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostMonitorsResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostMonitorsResponse500:
    error: Optional[PostMonitorsResponse500Error]

    def __init__(self, error: Optional[PostMonitorsResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostMonitorsResponse500':
        assert isinstance(obj, dict)
        error = from_union([PostMonitorsResponse500Error.from_dict, from_none], obj.get("error"))
        return PostMonitorsResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostMonitorsResponse500Error, x), from_none], self.error)
        return result


class PostNetworkPrivateResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostNetworkPrivateResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostNetworkPrivateResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostNetworkPrivateResponse401:
    error: Optional[PostNetworkPrivateResponse401Error]

    def __init__(self, error: Optional[PostNetworkPrivateResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostNetworkPrivateResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostNetworkPrivateResponse401Error.from_dict, from_none], obj.get("error"))
        return PostNetworkPrivateResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostNetworkPrivateResponse401Error, x), from_none], self.error)
        return result


class PostNetworkPrivateResponse403Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostNetworkPrivateResponse403Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostNetworkPrivateResponse403Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostNetworkPrivateResponse403:
    error: Optional[PostNetworkPrivateResponse403Error]

    def __init__(self, error: Optional[PostNetworkPrivateResponse403Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostNetworkPrivateResponse403':
        assert isinstance(obj, dict)
        error = from_union([PostNetworkPrivateResponse403Error.from_dict, from_none], obj.get("error"))
        return PostNetworkPrivateResponse403(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostNetworkPrivateResponse403Error, x), from_none], self.error)
        return result


class PostNetworkPrivateResponse404Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostNetworkPrivateResponse404Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostNetworkPrivateResponse404Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostNetworkPrivateResponse404:
    error: Optional[PostNetworkPrivateResponse404Error]

    def __init__(self, error: Optional[PostNetworkPrivateResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostNetworkPrivateResponse404':
        assert isinstance(obj, dict)
        error = from_union([PostNetworkPrivateResponse404Error.from_dict, from_none], obj.get("error"))
        return PostNetworkPrivateResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostNetworkPrivateResponse404Error, x), from_none], self.error)
        return result


class PostNetworkPrivateResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PostNetworkPrivateResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PostNetworkPrivateResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PostNetworkPrivateResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostNetworkPrivateResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostNetworkPrivateResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostNetworkPrivateResponse500:
    error: Optional[PostNetworkPrivateResponse500Error]

    def __init__(self, error: Optional[PostNetworkPrivateResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostNetworkPrivateResponse500':
        assert isinstance(obj, dict)
        error = from_union([PostNetworkPrivateResponse500Error.from_dict, from_none], obj.get("error"))
        return PostNetworkPrivateResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostNetworkPrivateResponse500Error, x), from_none], self.error)
        return result


class PostScimV2GroupsBodyName:
    """Information about the user's name."""
    """The user's last name."""
    family_name: Optional[str]
    """The user's first name."""
    given_name: Optional[str]

    def __init__(self, family_name: Optional[str], given_name: Optional[str]) -> None:
        self.family_name = family_name
        self.given_name = given_name

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2GroupsBodyName':
        assert isinstance(obj, dict)
        family_name = from_union([from_str, from_none], obj.get("familyName"))
        given_name = from_union([from_str, from_none], obj.get("givenName"))
        return PostScimV2GroupsBodyName(family_name, given_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.family_name is not None:
            result["familyName"] = from_union([from_str, from_none], self.family_name)
        if self.given_name is not None:
            result["givenName"] = from_union([from_str, from_none], self.given_name)
        return result


class PostScimV2GroupsBody:
    """If true, activates the user. This lets them authenticate in to your Postman team."""
    active: Optional[bool]
    """The user's external ID."""
    external_id: Optional[str]
    """A list of groups to which to assign the user to."""
    groups: Optional[List[str]]
    """The user's IETF locale."""
    locale: Optional[str]
    """Information about the user's name."""
    name: Optional[PostScimV2GroupsBodyName]
    """The SCIM schema resource URI."""
    schemas: Optional[List[str]]
    """The user's username."""
    user_name: Optional[str]

    def __init__(self, active: Optional[bool], external_id: Optional[str], groups: Optional[List[str]], locale: Optional[str], name: Optional[PostScimV2GroupsBodyName], schemas: Optional[List[str]], user_name: Optional[str]) -> None:
        self.active = active
        self.external_id = external_id
        self.groups = groups
        self.locale = locale
        self.name = name
        self.schemas = schemas
        self.user_name = user_name

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2GroupsBody':
        assert isinstance(obj, dict)
        active = from_union([from_bool, from_none], obj.get("active"))
        external_id = from_union([from_str, from_none], obj.get("externalId"))
        groups = from_union([lambda x: from_list(from_str, x), from_none], obj.get("groups"))
        locale = from_union([from_str, from_none], obj.get("locale"))
        name = from_union([PostScimV2GroupsBodyName.from_dict, from_none], obj.get("name"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        user_name = from_union([from_str, from_none], obj.get("userName"))
        return PostScimV2GroupsBody(active, external_id, groups, locale, name, schemas, user_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.active is not None:
            result["active"] = from_union([from_bool, from_none], self.active)
        if self.external_id is not None:
            result["externalId"] = from_union([from_str, from_none], self.external_id)
        if self.groups is not None:
            result["groups"] = from_union([lambda x: from_list(from_str, x), from_none], self.groups)
        if self.locale is not None:
            result["locale"] = from_union([from_str, from_none], self.locale)
        if self.name is not None:
            result["name"] = from_union([lambda x: to_class(PostScimV2GroupsBodyName, x), from_none], self.name)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.user_name is not None:
            result["userName"] = from_union([from_str, from_none], self.user_name)
        return result


class MetaResourceType(Enum):
    """The SCIM resource type."""
    USER = "User"


class PostScimV2GroupsResponseMeta:
    """The response's non-standard meta information."""
    """The date and time at which the user was created."""
    created: Optional[str]
    """The date and time at which the user was last modified."""
    last_modified: Optional[str]
    """The SCIM resource type."""
    resource_type: Optional[MetaResourceType]

    def __init__(self, created: Optional[str], last_modified: Optional[str], resource_type: Optional[MetaResourceType]) -> None:
        self.created = created
        self.last_modified = last_modified
        self.resource_type = resource_type

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2GroupsResponseMeta':
        assert isinstance(obj, dict)
        created = from_union([from_str, from_none], obj.get("created"))
        last_modified = from_union([from_str, from_none], obj.get("lastModified"))
        resource_type = from_union([MetaResourceType, from_none], obj.get("resourceType"))
        return PostScimV2GroupsResponseMeta(created, last_modified, resource_type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created is not None:
            result["created"] = from_union([from_str, from_none], self.created)
        if self.last_modified is not None:
            result["lastModified"] = from_union([from_str, from_none], self.last_modified)
        if self.resource_type is not None:
            result["resourceType"] = from_union([lambda x: to_enum(MetaResourceType, x), from_none], self.resource_type)
        return result


class PostScimV2GroupsResponseName:
    """The user's last name."""
    family_name: Optional[str]
    """The user's first name."""
    given_name: Optional[str]

    def __init__(self, family_name: Optional[str], given_name: Optional[str]) -> None:
        self.family_name = family_name
        self.given_name = given_name

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2GroupsResponseName':
        assert isinstance(obj, dict)
        family_name = from_union([from_str, from_none], obj.get("familyName"))
        given_name = from_union([from_str, from_none], obj.get("givenName"))
        return PostScimV2GroupsResponseName(family_name, given_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.family_name is not None:
            result["familyName"] = from_union([from_str, from_none], self.family_name)
        if self.given_name is not None:
            result["givenName"] = from_union([from_str, from_none], self.given_name)
        return result


class PostScimV2GroupsResponse:
    """If true, the user is active."""
    active: Optional[bool]
    """The user's external ID."""
    external_id: Optional[str]
    """The user's SCIM ID."""
    id: Optional[str]
    """The response's non-standard meta information."""
    meta: Optional[PostScimV2GroupsResponseMeta]
    name: Optional[PostScimV2GroupsResponseName]
    """The SCIM schema URI."""
    schemas: Optional[List[str]]
    """The user's username."""
    user_name: Optional[str]

    def __init__(self, active: Optional[bool], external_id: Optional[str], id: Optional[str], meta: Optional[PostScimV2GroupsResponseMeta], name: Optional[PostScimV2GroupsResponseName], schemas: Optional[List[str]], user_name: Optional[str]) -> None:
        self.active = active
        self.external_id = external_id
        self.id = id
        self.meta = meta
        self.name = name
        self.schemas = schemas
        self.user_name = user_name

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2GroupsResponse':
        assert isinstance(obj, dict)
        active = from_union([from_bool, from_none], obj.get("active"))
        external_id = from_union([from_str, from_none], obj.get("externalId"))
        id = from_union([from_str, from_none], obj.get("id"))
        meta = from_union([PostScimV2GroupsResponseMeta.from_dict, from_none], obj.get("meta"))
        name = from_union([PostScimV2GroupsResponseName.from_dict, from_none], obj.get("name"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        user_name = from_union([from_str, from_none], obj.get("userName"))
        return PostScimV2GroupsResponse(active, external_id, id, meta, name, schemas, user_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.active is not None:
            result["active"] = from_union([from_bool, from_none], self.active)
        if self.external_id is not None:
            result["externalId"] = from_union([from_str, from_none], self.external_id)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(PostScimV2GroupsResponseMeta, x), from_none], self.meta)
        if self.name is not None:
            result["name"] = from_union([lambda x: to_class(PostScimV2GroupsResponseName, x), from_none], self.name)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.user_name is not None:
            result["userName"] = from_union([from_str, from_none], self.user_name)
        return result


class PostScimV2GroupsResponse400:
    """Information about the error."""
    detail: Optional[str]
    """A list of SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The SCIM type."""
    scim_type: Optional[str]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], scim_type: Optional[str], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.scim_type = scim_type
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2GroupsResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        scim_type = from_union([from_str, from_none], obj.get("scimType"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PostScimV2GroupsResponse400(detail, schemas, scim_type, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.scim_type is not None:
            result["scimType"] = from_union([from_str, from_none], self.scim_type)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PostScimV2GroupsResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2GroupsResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PostScimV2GroupsResponse401(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PostScimV2GroupsResponse403:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2GroupsResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PostScimV2GroupsResponse403(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PostScimV2GroupsResponse409:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The SCIM type."""
    scim_type: Optional[str]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], scim_type: Optional[str], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.scim_type = scim_type
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2GroupsResponse409':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        scim_type = from_union([from_str, from_none], obj.get("scimType"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PostScimV2GroupsResponse409(detail, schemas, scim_type, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.scim_type is not None:
            result["scimType"] = from_union([from_str, from_none], self.scim_type)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PostScimV2GroupsResponse429:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[float]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[float]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2GroupsResponse429':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_float, from_none], obj.get("status"))
        return PostScimV2GroupsResponse429(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        return result


class PostScimV2GroupsResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2GroupsResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PostScimV2GroupsResponse500(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PostScimV2UsersBodyName:
    """Information about the user's name."""
    """The user's last name."""
    family_name: Optional[str]
    """The user's first name."""
    given_name: Optional[str]

    def __init__(self, family_name: Optional[str], given_name: Optional[str]) -> None:
        self.family_name = family_name
        self.given_name = given_name

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2UsersBodyName':
        assert isinstance(obj, dict)
        family_name = from_union([from_str, from_none], obj.get("familyName"))
        given_name = from_union([from_str, from_none], obj.get("givenName"))
        return PostScimV2UsersBodyName(family_name, given_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.family_name is not None:
            result["familyName"] = from_union([from_str, from_none], self.family_name)
        if self.given_name is not None:
            result["givenName"] = from_union([from_str, from_none], self.given_name)
        return result


class PostScimV2UsersBody:
    """If true, activates the user. This lets them authenticate in to your Postman team."""
    active: Optional[bool]
    """The user's external ID."""
    external_id: Optional[str]
    """A list of groups to which to assign the user to."""
    groups: Optional[List[str]]
    """The user's IETF locale."""
    locale: Optional[str]
    """Information about the user's name."""
    name: Optional[PostScimV2UsersBodyName]
    """The SCIM schema resource URI."""
    schemas: Optional[List[str]]
    """The user's username."""
    user_name: Optional[str]

    def __init__(self, active: Optional[bool], external_id: Optional[str], groups: Optional[List[str]], locale: Optional[str], name: Optional[PostScimV2UsersBodyName], schemas: Optional[List[str]], user_name: Optional[str]) -> None:
        self.active = active
        self.external_id = external_id
        self.groups = groups
        self.locale = locale
        self.name = name
        self.schemas = schemas
        self.user_name = user_name

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2UsersBody':
        assert isinstance(obj, dict)
        active = from_union([from_bool, from_none], obj.get("active"))
        external_id = from_union([from_str, from_none], obj.get("externalId"))
        groups = from_union([lambda x: from_list(from_str, x), from_none], obj.get("groups"))
        locale = from_union([from_str, from_none], obj.get("locale"))
        name = from_union([PostScimV2UsersBodyName.from_dict, from_none], obj.get("name"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        user_name = from_union([from_str, from_none], obj.get("userName"))
        return PostScimV2UsersBody(active, external_id, groups, locale, name, schemas, user_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.active is not None:
            result["active"] = from_union([from_bool, from_none], self.active)
        if self.external_id is not None:
            result["externalId"] = from_union([from_str, from_none], self.external_id)
        if self.groups is not None:
            result["groups"] = from_union([lambda x: from_list(from_str, x), from_none], self.groups)
        if self.locale is not None:
            result["locale"] = from_union([from_str, from_none], self.locale)
        if self.name is not None:
            result["name"] = from_union([lambda x: to_class(PostScimV2UsersBodyName, x), from_none], self.name)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.user_name is not None:
            result["userName"] = from_union([from_str, from_none], self.user_name)
        return result


class PostScimV2UsersResponseMeta:
    """The response's non-standard meta information."""
    """The date and time at which the user was created."""
    created: Optional[str]
    """The date and time at which the user was last modified."""
    last_modified: Optional[str]
    """The SCIM resource type."""
    resource_type: Optional[MetaResourceType]

    def __init__(self, created: Optional[str], last_modified: Optional[str], resource_type: Optional[MetaResourceType]) -> None:
        self.created = created
        self.last_modified = last_modified
        self.resource_type = resource_type

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2UsersResponseMeta':
        assert isinstance(obj, dict)
        created = from_union([from_str, from_none], obj.get("created"))
        last_modified = from_union([from_str, from_none], obj.get("lastModified"))
        resource_type = from_union([MetaResourceType, from_none], obj.get("resourceType"))
        return PostScimV2UsersResponseMeta(created, last_modified, resource_type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created is not None:
            result["created"] = from_union([from_str, from_none], self.created)
        if self.last_modified is not None:
            result["lastModified"] = from_union([from_str, from_none], self.last_modified)
        if self.resource_type is not None:
            result["resourceType"] = from_union([lambda x: to_enum(MetaResourceType, x), from_none], self.resource_type)
        return result


class PostScimV2UsersResponseName:
    """The user's last name."""
    family_name: Optional[str]
    """The user's first name."""
    given_name: Optional[str]

    def __init__(self, family_name: Optional[str], given_name: Optional[str]) -> None:
        self.family_name = family_name
        self.given_name = given_name

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2UsersResponseName':
        assert isinstance(obj, dict)
        family_name = from_union([from_str, from_none], obj.get("familyName"))
        given_name = from_union([from_str, from_none], obj.get("givenName"))
        return PostScimV2UsersResponseName(family_name, given_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.family_name is not None:
            result["familyName"] = from_union([from_str, from_none], self.family_name)
        if self.given_name is not None:
            result["givenName"] = from_union([from_str, from_none], self.given_name)
        return result


class PostScimV2UsersResponse:
    """If true, the user is active."""
    active: Optional[bool]
    """The user's external ID."""
    external_id: Optional[str]
    """The user's SCIM ID."""
    id: Optional[str]
    """The response's non-standard meta information."""
    meta: Optional[PostScimV2UsersResponseMeta]
    name: Optional[PostScimV2UsersResponseName]
    """The SCIM schema URI."""
    schemas: Optional[List[str]]
    """The user's username."""
    user_name: Optional[str]

    def __init__(self, active: Optional[bool], external_id: Optional[str], id: Optional[str], meta: Optional[PostScimV2UsersResponseMeta], name: Optional[PostScimV2UsersResponseName], schemas: Optional[List[str]], user_name: Optional[str]) -> None:
        self.active = active
        self.external_id = external_id
        self.id = id
        self.meta = meta
        self.name = name
        self.schemas = schemas
        self.user_name = user_name

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2UsersResponse':
        assert isinstance(obj, dict)
        active = from_union([from_bool, from_none], obj.get("active"))
        external_id = from_union([from_str, from_none], obj.get("externalId"))
        id = from_union([from_str, from_none], obj.get("id"))
        meta = from_union([PostScimV2UsersResponseMeta.from_dict, from_none], obj.get("meta"))
        name = from_union([PostScimV2UsersResponseName.from_dict, from_none], obj.get("name"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        user_name = from_union([from_str, from_none], obj.get("userName"))
        return PostScimV2UsersResponse(active, external_id, id, meta, name, schemas, user_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.active is not None:
            result["active"] = from_union([from_bool, from_none], self.active)
        if self.external_id is not None:
            result["externalId"] = from_union([from_str, from_none], self.external_id)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(PostScimV2UsersResponseMeta, x), from_none], self.meta)
        if self.name is not None:
            result["name"] = from_union([lambda x: to_class(PostScimV2UsersResponseName, x), from_none], self.name)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.user_name is not None:
            result["userName"] = from_union([from_str, from_none], self.user_name)
        return result


class PostScimV2UsersResponse400:
    """Information about the error."""
    detail: Optional[str]
    """A list of SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The SCIM type."""
    scim_type: Optional[str]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], scim_type: Optional[str], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.scim_type = scim_type
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2UsersResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        scim_type = from_union([from_str, from_none], obj.get("scimType"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PostScimV2UsersResponse400(detail, schemas, scim_type, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.scim_type is not None:
            result["scimType"] = from_union([from_str, from_none], self.scim_type)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PostScimV2UsersResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2UsersResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PostScimV2UsersResponse401(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PostScimV2UsersResponse403:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2UsersResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PostScimV2UsersResponse403(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PostScimV2UsersResponse409:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The SCIM type."""
    scim_type: Optional[str]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], scim_type: Optional[str], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.scim_type = scim_type
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2UsersResponse409':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        scim_type = from_union([from_str, from_none], obj.get("scimType"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PostScimV2UsersResponse409(detail, schemas, scim_type, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.scim_type is not None:
            result["scimType"] = from_union([from_str, from_none], self.scim_type)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PostScimV2UsersResponse429:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[float]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[float]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2UsersResponse429':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_float, from_none], obj.get("status"))
        return PostScimV2UsersResponse429(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        return result


class PostScimV2UsersResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PostScimV2UsersResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PostScimV2UsersResponse500(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class SchemaLanguage(Enum):
    """The definition format."""
    JSON = "json"
    YAML = "yaml"


class FluffyType(Enum):
    """The definition type."""
    OPENAPI2 = "openapi2"
    OPENAPI3 = "openapi3"


class PostSecurityAPIValidationBodySchema:
    """The definition format."""
    language: SchemaLanguage
    """The stringified API definition."""
    schema: str
    """The definition type."""
    type: FluffyType

    def __init__(self, language: SchemaLanguage, schema: str, type: FluffyType) -> None:
        self.language = language
        self.schema = schema
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostSecurityAPIValidationBodySchema':
        assert isinstance(obj, dict)
        language = SchemaLanguage(obj.get("language"))
        schema = from_str(obj.get("schema"))
        type = FluffyType(obj.get("type"))
        return PostSecurityAPIValidationBodySchema(language, schema, type)

    def to_dict(self) -> dict:
        result: dict = {}
        result["language"] = to_enum(SchemaLanguage, self.language)
        result["schema"] = from_str(self.schema)
        result["type"] = to_enum(FluffyType, self.type)
        return result


class PostSecurityAPIValidationBody:
    schema: Optional[PostSecurityAPIValidationBodySchema]

    def __init__(self, schema: Optional[PostSecurityAPIValidationBodySchema]) -> None:
        self.schema = schema

    @staticmethod
    def from_dict(obj: Any) -> 'PostSecurityAPIValidationBody':
        assert isinstance(obj, dict)
        schema = from_union([PostSecurityAPIValidationBodySchema.from_dict, from_none], obj.get("schema"))
        return PostSecurityAPIValidationBody(schema)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.schema is not None:
            result["schema"] = from_union([lambda x: to_class(PostSecurityAPIValidationBodySchema, x), from_none], self.schema)
        return result


class PostSecurityAPIValidationResponse:
    """Information about each issue discovered in the analysis. Each object includes the
    violation's severity and category, the location of the issue, data paths, and other
    information. This returns an empty object if there are no issues present in the schema.
    
    If there are issues, this returns the `possibleFixUrl` response in each warning object.
    This provides a link to documentation you can use to resolve the warning.
    """
    warnings: Optional[List[Any]]

    def __init__(self, warnings: Optional[List[Any]]) -> None:
        self.warnings = warnings

    @staticmethod
    def from_dict(obj: Any) -> 'PostSecurityAPIValidationResponse':
        assert isinstance(obj, dict)
        warnings = from_union([lambda x: from_list(lambda x: x, x), from_none], obj.get("warnings"))
        return PostSecurityAPIValidationResponse(warnings)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.warnings is not None:
            result["warnings"] = from_union([lambda x: from_list(lambda x: x, x), from_none], self.warnings)
        return result


class PostSecurityAPIValidationResponse400Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostSecurityAPIValidationResponse400Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostSecurityAPIValidationResponse400Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostSecurityAPIValidationResponse400:
    error: Optional[PostSecurityAPIValidationResponse400Error]

    def __init__(self, error: Optional[PostSecurityAPIValidationResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostSecurityAPIValidationResponse400':
        assert isinstance(obj, dict)
        error = from_union([PostSecurityAPIValidationResponse400Error.from_dict, from_none], obj.get("error"))
        return PostSecurityAPIValidationResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostSecurityAPIValidationResponse400Error, x), from_none], self.error)
        return result


class PostSecurityAPIValidationResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostSecurityAPIValidationResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostSecurityAPIValidationResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostSecurityAPIValidationResponse401:
    error: Optional[PostSecurityAPIValidationResponse401Error]

    def __init__(self, error: Optional[PostSecurityAPIValidationResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostSecurityAPIValidationResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostSecurityAPIValidationResponse401Error.from_dict, from_none], obj.get("error"))
        return PostSecurityAPIValidationResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostSecurityAPIValidationResponse401Error, x), from_none], self.error)
        return result


class PostSecurityAPIValidationResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PostSecurityAPIValidationResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PostSecurityAPIValidationResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PostSecurityAPIValidationResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostSecurityAPIValidationResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostSecurityAPIValidationResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostSecurityAPIValidationResponse500:
    error: Optional[PostSecurityAPIValidationResponse500Error]

    def __init__(self, error: Optional[PostSecurityAPIValidationResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostSecurityAPIValidationResponse500':
        assert isinstance(obj, dict)
        error = from_union([PostSecurityAPIValidationResponse500Error.from_dict, from_none], obj.get("error"))
        return PostSecurityAPIValidationResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostSecurityAPIValidationResponse500Error, x), from_none], self.error)
        return result


class PostWebhooksBodyWebhook:
    """The unique ID of the collection to trigger when calling this webhook."""
    collection: Optional[str]
    """The webhook's name. On success, the system creates a new monitor with this name in the
    **Monitors** tab.
    """
    name: Optional[str]

    def __init__(self, collection: Optional[str], name: Optional[str]) -> None:
        self.collection = collection
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostWebhooksBodyWebhook':
        assert isinstance(obj, dict)
        collection = from_union([from_str, from_none], obj.get("collection"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostWebhooksBodyWebhook(collection, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([from_str, from_none], self.collection)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostWebhooksBody:
    webhook: Optional[PostWebhooksBodyWebhook]

    def __init__(self, webhook: Optional[PostWebhooksBodyWebhook]) -> None:
        self.webhook = webhook

    @staticmethod
    def from_dict(obj: Any) -> 'PostWebhooksBody':
        assert isinstance(obj, dict)
        webhook = from_union([PostWebhooksBodyWebhook.from_dict, from_none], obj.get("webhook"))
        return PostWebhooksBody(webhook)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.webhook is not None:
            result["webhook"] = from_union([lambda x: to_class(PostWebhooksBodyWebhook, x), from_none], self.webhook)
        return result


class PostWebhooksResponseWebhook:
    """Information about the webhook."""
    """The unique ID of the webhook's associated collection."""
    collection: Optional[str]
    """The webhook's ID."""
    id: Optional[str]
    """The webhook's name."""
    name: Optional[str]
    """The webhook's unique ID."""
    uid: Optional[str]
    """The webhook's URL."""
    webhook_url: Optional[str]

    def __init__(self, collection: Optional[str], id: Optional[str], name: Optional[str], uid: Optional[str], webhook_url: Optional[str]) -> None:
        self.collection = collection
        self.id = id
        self.name = name
        self.uid = uid
        self.webhook_url = webhook_url

    @staticmethod
    def from_dict(obj: Any) -> 'PostWebhooksResponseWebhook':
        assert isinstance(obj, dict)
        collection = from_union([from_str, from_none], obj.get("collection"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        webhook_url = from_union([from_str, from_none], obj.get("webhookUrl"))
        return PostWebhooksResponseWebhook(collection, id, name, uid, webhook_url)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([from_str, from_none], self.collection)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        if self.webhook_url is not None:
            result["webhookUrl"] = from_union([from_str, from_none], self.webhook_url)
        return result


class PostWebhooksResponse:
    """Information about the webhook."""
    webhook: Optional[PostWebhooksResponseWebhook]

    def __init__(self, webhook: Optional[PostWebhooksResponseWebhook]) -> None:
        self.webhook = webhook

    @staticmethod
    def from_dict(obj: Any) -> 'PostWebhooksResponse':
        assert isinstance(obj, dict)
        webhook = from_union([PostWebhooksResponseWebhook.from_dict, from_none], obj.get("webhook"))
        return PostWebhooksResponse(webhook)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.webhook is not None:
            result["webhook"] = from_union([lambda x: to_class(PostWebhooksResponseWebhook, x), from_none], self.webhook)
        return result


class PostWebhooksResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostWebhooksResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostWebhooksResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostWebhooksResponse401:
    error: Optional[PostWebhooksResponse401Error]

    def __init__(self, error: Optional[PostWebhooksResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostWebhooksResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostWebhooksResponse401Error.from_dict, from_none], obj.get("error"))
        return PostWebhooksResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostWebhooksResponse401Error, x), from_none], self.error)
        return result


class PostWebhooksResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PostWebhooksResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PostWebhooksResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PostWebhooksResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostWebhooksResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostWebhooksResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostWebhooksResponse500:
    error: Optional[PostWebhooksResponse500Error]

    def __init__(self, error: Optional[PostWebhooksResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostWebhooksResponse500':
        assert isinstance(obj, dict)
        error = from_union([PostWebhooksResponse500Error.from_dict, from_none], obj.get("error"))
        return PostWebhooksResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostWebhooksResponse500Error, x), from_none], self.error)
        return result


class PostWorkspacesBodyWorkspace:
    """Information about the workspace."""
    """The workspace's description."""
    description: Optional[str]
    """The workspace's name."""
    name: str
    """The type of workspace:
    
    - `personal`
    - `private`  Private workspaces are available on Postman [Professional and Enterprise
    plans](https://www.postman.com/pricing).
    - `public`
    - `team`
    - `partner`  [Partner
    Workspaces](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/partner-workspaces/)
    are available on Postman [Enterprise Ultimate plans](https://www.postman.com/pricing).
    """
    type: VisibilityEnum

    def __init__(self, description: Optional[str], name: str, type: VisibilityEnum) -> None:
        self.description = description
        self.name = name
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PostWorkspacesBodyWorkspace':
        assert isinstance(obj, dict)
        description = from_union([from_str, from_none], obj.get("description"))
        name = from_str(obj.get("name"))
        type = VisibilityEnum(obj.get("type"))
        return PostWorkspacesBodyWorkspace(description, name, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        result["name"] = from_str(self.name)
        result["type"] = to_enum(VisibilityEnum, self.type)
        return result


class PostWorkspacesBody:
    """Information about the workspace."""
    workspace: Optional[PostWorkspacesBodyWorkspace]

    def __init__(self, workspace: Optional[PostWorkspacesBodyWorkspace]) -> None:
        self.workspace = workspace

    @staticmethod
    def from_dict(obj: Any) -> 'PostWorkspacesBody':
        assert isinstance(obj, dict)
        workspace = from_union([PostWorkspacesBodyWorkspace.from_dict, from_none], obj.get("workspace"))
        return PostWorkspacesBody(workspace)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.workspace is not None:
            result["workspace"] = from_union([lambda x: to_class(PostWorkspacesBodyWorkspace, x), from_none], self.workspace)
        return result


class PostWorkspacesResponseWorkspace:
    """Information about the created workspace."""
    """The workspace's ID."""
    id: Optional[str]
    """The workspace's name."""
    name: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str]) -> None:
        self.id = id
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostWorkspacesResponseWorkspace':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostWorkspacesResponseWorkspace(id, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostWorkspacesResponse:
    """Information about the created workspace."""
    workspace: Optional[PostWorkspacesResponseWorkspace]

    def __init__(self, workspace: Optional[PostWorkspacesResponseWorkspace]) -> None:
        self.workspace = workspace

    @staticmethod
    def from_dict(obj: Any) -> 'PostWorkspacesResponse':
        assert isinstance(obj, dict)
        workspace = from_union([PostWorkspacesResponseWorkspace.from_dict, from_none], obj.get("workspace"))
        return PostWorkspacesResponse(workspace)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.workspace is not None:
            result["workspace"] = from_union([lambda x: to_class(PostWorkspacesResponseWorkspace, x), from_none], self.workspace)
        return result


class PostWorkspacesResponse400:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostWorkspacesResponse400':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostWorkspacesResponse400(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostWorkspacesResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostWorkspacesResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostWorkspacesResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostWorkspacesResponse401:
    error: Optional[PostWorkspacesResponse401Error]

    def __init__(self, error: Optional[PostWorkspacesResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostWorkspacesResponse401':
        assert isinstance(obj, dict)
        error = from_union([PostWorkspacesResponse401Error.from_dict, from_none], obj.get("error"))
        return PostWorkspacesResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostWorkspacesResponse401Error, x), from_none], self.error)
        return result


class PostWorkspacesResponse404Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostWorkspacesResponse404Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostWorkspacesResponse404Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostWorkspacesResponse404:
    error: Optional[PostWorkspacesResponse404Error]

    def __init__(self, error: Optional[PostWorkspacesResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostWorkspacesResponse404':
        assert isinstance(obj, dict)
        error = from_union([PostWorkspacesResponse404Error.from_dict, from_none], obj.get("error"))
        return PostWorkspacesResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostWorkspacesResponse404Error, x), from_none], self.error)
        return result


class PostWorkspacesResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PostWorkspacesResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PostWorkspacesResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PostWorkspacesResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PostWorkspacesResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PostWorkspacesResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PostWorkspacesResponse500:
    error: Optional[PostWorkspacesResponse500Error]

    def __init__(self, error: Optional[PostWorkspacesResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PostWorkspacesResponse500':
        assert isinstance(obj, dict)
        error = from_union([PostWorkspacesResponse500Error.from_dict, from_none], obj.get("error"))
        return PostWorkspacesResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PostWorkspacesResponse500Error, x), from_none], self.error)
        return result


class PutApisAPIIDBody:
    """Information about the API."""
    """The API's description. This supports Markdown formatting."""
    description: Optional[str]
    """The API's name."""
    name: str
    """The API's short summary."""
    summary: Optional[str]

    def __init__(self, description: Optional[str], name: str, summary: Optional[str]) -> None:
        self.description = description
        self.name = name
        self.summary = summary

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDBody':
        assert isinstance(obj, dict)
        description = from_union([from_str, from_none], obj.get("description"))
        name = from_str(obj.get("name"))
        summary = from_union([from_str, from_none], obj.get("summary"))
        return PutApisAPIIDBody(description, name, summary)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        result["name"] = from_str(self.name)
        if self.summary is not None:
            result["summary"] = from_union([from_str, from_none], self.summary)
        return result


class PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse:
    """The created task ID. You can use this ID to track the status of syncing an API collection
    with an API schema.
    """
    task_id: Optional[str]

    def __init__(self, task_id: Optional[str]) -> None:
        self.task_id = task_id

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse':
        assert isinstance(obj, dict)
        task_id = from_union([from_str, from_none], obj.get("taskId"))
        return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse(task_id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.task_id is not None:
            result["taskId"] = from_union([from_str, from_none], self.task_id)
        return result


class PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse400:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse400(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse403:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse403(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse422:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse422':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse422(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDResponse:
    """Information about the API."""
    """The date and time at which the API was created."""
    created_at: Optional[str]
    """The user ID of the user that created the API."""
    created_by: Optional[str]
    """The API's description. This supports Markdown formatting."""
    description: Optional[str]
    """The API's ID."""
    id: Optional[str]
    """The API's name."""
    name: str
    """The API's summary."""
    summary: Optional[str]
    """The date and time at which the API was last updated."""
    updated_at: Optional[str]
    """The user ID of the user that updated the API."""
    updated_by: Optional[str]

    def __init__(self, created_at: Optional[str], created_by: Optional[str], description: Optional[str], id: Optional[str], name: str, summary: Optional[str], updated_at: Optional[str], updated_by: Optional[str]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.description = description
        self.id = id
        self.name = name
        self.summary = summary
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDResponse':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_str, from_none], obj.get("createdBy"))
        description = from_union([from_str, from_none], obj.get("description"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_str(obj.get("name"))
        summary = from_union([from_str, from_none], obj.get("summary"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_str, from_none], obj.get("updatedBy"))
        return PutApisAPIIDResponse(created_at, created_by, description, id, name, summary, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_str, from_none], self.created_by)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        result["name"] = from_str(self.name)
        if self.summary is not None:
            result["summary"] = from_union([from_str, from_none], self.summary)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_str, from_none], self.updated_by)
        return result


class PutApisAPIIDResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDResponse403:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDResponse403(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDResponse422:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDResponse422':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDResponse422(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDSchemasSchemaIDFilesFilePathBodyRoot:
    """Information about the schema's root file. This tag only applies to protobuf
    specifications.
    """
    """If true, tag the file as the root file."""
    enabled: Optional[bool]

    def __init__(self, enabled: Optional[bool]) -> None:
        self.enabled = enabled

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDSchemasSchemaIDFilesFilePathBodyRoot':
        assert isinstance(obj, dict)
        enabled = from_union([from_bool, from_none], obj.get("enabled"))
        return PutApisAPIIDSchemasSchemaIDFilesFilePathBodyRoot(enabled)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.enabled is not None:
            result["enabled"] = from_union([from_bool, from_none], self.enabled)
        return result


class PutApisAPIIDSchemasSchemaIDFilesFilePathBody:
    """Information about schema file."""
    """The schema file's content."""
    content: str
    """The schema file's name."""
    name: Optional[str]
    """Information about the schema's root file. This tag only applies to protobuf
    specifications.
    """
    root: Optional[PutApisAPIIDSchemasSchemaIDFilesFilePathBodyRoot]

    def __init__(self, content: str, name: Optional[str], root: Optional[PutApisAPIIDSchemasSchemaIDFilesFilePathBodyRoot]) -> None:
        self.content = content
        self.name = name
        self.root = root

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDSchemasSchemaIDFilesFilePathBody':
        assert isinstance(obj, dict)
        content = from_str(obj.get("content"))
        name = from_union([from_str, from_none], obj.get("name"))
        root = from_union([PutApisAPIIDSchemasSchemaIDFilesFilePathBodyRoot.from_dict, from_none], obj.get("root"))
        return PutApisAPIIDSchemasSchemaIDFilesFilePathBody(content, name, root)

    def to_dict(self) -> dict:
        result: dict = {}
        result["content"] = from_str(self.content)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.root is not None:
            result["root"] = from_union([lambda x: to_class(PutApisAPIIDSchemasSchemaIDFilesFilePathBodyRoot, x), from_none], self.root)
        return result


class PutApisAPIIDSchemasSchemaIDFilesFilePathResponse:
    """Information about the schema file."""
    """The date and time at which the file was created."""
    created_at: Optional[str]
    """The user Id of the user that created the file."""
    created_by: Optional[str]
    """The schema file's ID."""
    id: Optional[str]
    """The schema file's name."""
    name: Optional[str]
    """The file system path to the schema file."""
    path: Optional[str]
    """The date and time at which the file was last updated."""
    updated_at: Optional[str]
    """The user ID of the user that last updated the file."""
    updated_by: Optional[str]

    def __init__(self, created_at: Optional[str], created_by: Optional[str], id: Optional[str], name: Optional[str], path: Optional[str], updated_at: Optional[str], updated_by: Optional[str]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.id = id
        self.name = name
        self.path = path
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDSchemasSchemaIDFilesFilePathResponse':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_str, from_none], obj.get("createdBy"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        path = from_union([from_str, from_none], obj.get("path"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_str, from_none], obj.get("updatedBy"))
        return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse(created_at, created_by, id, name, path, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_str, from_none], self.created_by)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.path is not None:
            result["path"] = from_union([from_str, from_none], self.path)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_str, from_none], self.updated_by)
        return result


class PutApisAPIIDSchemasSchemaIDFilesFilePathResponse400:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDSchemasSchemaIDFilesFilePathResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse400(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDSchemasSchemaIDFilesFilePathResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDSchemasSchemaIDFilesFilePathResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDSchemasSchemaIDFilesFilePathResponse403:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDSchemasSchemaIDFilesFilePathResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse403(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDSchemasSchemaIDFilesFilePathResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDSchemasSchemaIDFilesFilePathResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDSchemasSchemaIDFilesFilePathResponse422:
    """Details about the error."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDSchemasSchemaIDFilesFilePathResponse422':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse422(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDSchemasSchemaIDFilesFilePathResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDSchemasSchemaIDFilesFilePathResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDTagsBodyTagsItem:
    """Information about the tag."""
    """The tag's ID within a team or individual (non-team) user scope."""
    slug: str

    def __init__(self, slug: str) -> None:
        self.slug = slug

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDTagsBodyTagsItem':
        assert isinstance(obj, dict)
        slug = from_str(obj.get("slug"))
        return PutApisAPIIDTagsBodyTagsItem(slug)

    def to_dict(self) -> dict:
        result: dict = {}
        result["slug"] = from_str(self.slug)
        return result


class PutApisAPIIDTagsBody:
    """A list of the associated tags as slugs."""
    tags: List[PutApisAPIIDTagsBodyTagsItem]

    def __init__(self, tags: List[PutApisAPIIDTagsBodyTagsItem]) -> None:
        self.tags = tags

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDTagsBody':
        assert isinstance(obj, dict)
        tags = from_list(PutApisAPIIDTagsBodyTagsItem.from_dict, obj.get("tags"))
        return PutApisAPIIDTagsBody(tags)

    def to_dict(self) -> dict:
        result: dict = {}
        result["tags"] = from_list(lambda x: to_class(PutApisAPIIDTagsBodyTagsItem, x), self.tags)
        return result


class PutApisAPIIDTagsResponseTagsItem:
    """Information about the tag."""
    """The tag's ID within a team or individual (non-team) user scope."""
    slug: Optional[str]

    def __init__(self, slug: Optional[str]) -> None:
        self.slug = slug

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDTagsResponseTagsItem':
        assert isinstance(obj, dict)
        slug = from_union([from_str, from_none], obj.get("slug"))
        return PutApisAPIIDTagsResponseTagsItem(slug)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.slug is not None:
            result["slug"] = from_union([from_str, from_none], self.slug)
        return result


class PutApisAPIIDTagsResponse:
    """A list of associated tags."""
    tags: Optional[List[PutApisAPIIDTagsResponseTagsItem]]

    def __init__(self, tags: Optional[List[PutApisAPIIDTagsResponseTagsItem]]) -> None:
        self.tags = tags

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDTagsResponse':
        assert isinstance(obj, dict)
        tags = from_union([lambda x: from_list(PutApisAPIIDTagsResponseTagsItem.from_dict, x), from_none], obj.get("tags"))
        return PutApisAPIIDTagsResponse(tags)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.tags is not None:
            result["tags"] = from_union([lambda x: from_list(lambda x: to_class(PutApisAPIIDTagsResponseTagsItem, x), x), from_none], self.tags)
        return result


class PutApisAPIIDTagsResponse400:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDTagsResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDTagsResponse400(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDTagsResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDTagsResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDTagsResponse401(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDTagsResponse403:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDTagsResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDTagsResponse403(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDTagsResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The URI reference that identifies the specific occurrence of the problem."""
    instance: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDTagsResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDTagsResponse500(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDVersionsVersionIDBody:
    """Information about the API version."""
    """The version's name."""
    name: str
    """The version's Markdown-supported release notes."""
    release_notes: Optional[str]

    def __init__(self, name: str, release_notes: Optional[str]) -> None:
        self.name = name
        self.release_notes = release_notes

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDVersionsVersionIDBody':
        assert isinstance(obj, dict)
        name = from_str(obj.get("name"))
        release_notes = from_union([from_str, from_none], obj.get("releaseNotes"))
        return PutApisAPIIDVersionsVersionIDBody(name, release_notes)

    def to_dict(self) -> dict:
        result: dict = {}
        result["name"] = from_str(self.name)
        if self.release_notes is not None:
            result["releaseNotes"] = from_union([from_str, from_none], self.release_notes)
        return result


class PutApisAPIIDVersionsVersionIDResponse:
    """The date and time at which the version was created."""
    created_at: Optional[str]
    """The version's ID."""
    id: Optional[str]
    """The version's name."""
    name: Optional[str]
    """The version's release notes."""
    release_notes: Optional[str]
    """The date and time at which the version was last updated."""
    updated_at: Optional[str]

    def __init__(self, created_at: Optional[str], id: Optional[str], name: Optional[str], release_notes: Optional[str], updated_at: Optional[str]) -> None:
        self.created_at = created_at
        self.id = id
        self.name = name
        self.release_notes = release_notes
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDVersionsVersionIDResponse':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        release_notes = from_union([from_str, from_none], obj.get("releaseNotes"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return PutApisAPIIDVersionsVersionIDResponse(created_at, id, name, release_notes, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.release_notes is not None:
            result["releaseNotes"] = from_union([from_str, from_none], self.release_notes)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class PutApisAPIIDVersionsVersionIDResponse401:
    """Details about the error."""
    detail: Optional[str]
    """The error instance."""
    instance: Optional[str]
    """The HTTP status code."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The error type."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDVersionsVersionIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDVersionsVersionIDResponse401(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDVersionsVersionIDResponse403:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDVersionsVersionIDResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDVersionsVersionIDResponse403(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDVersionsVersionIDResponse404:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDVersionsVersionIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDVersionsVersionIDResponse404(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutApisAPIIDVersionsVersionIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutApisAPIIDVersionsVersionIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutApisAPIIDVersionsVersionIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutCollectionsCollectionIDBodyCollectionInfo:
    """An object that contains basic information about the collection. For a complete list of
    values, refer to the `definitions.info` entry in the [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    """The collection's description."""
    description: Optional[str]
    """The collection's name."""
    name: str
    """A URL to the collection's schema."""
    schema: str

    def __init__(self, description: Optional[str], name: str, schema: str) -> None:
        self.description = description
        self.name = name
        self.schema = schema

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDBodyCollectionInfo':
        assert isinstance(obj, dict)
        description = from_union([from_str, from_none], obj.get("description"))
        name = from_str(obj.get("name"))
        schema = from_str(obj.get("schema"))
        return PutCollectionsCollectionIDBodyCollectionInfo(description, name, schema)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        result["name"] = from_str(self.name)
        result["schema"] = from_str(self.schema)
        return result


class PutCollectionsCollectionIDBodyCollectionItemItem:
    """The collection item's ID."""
    id: Optional[str]
    """The collection item's name."""
    name: Optional[str]
    """The collection item's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.name = name
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDBodyCollectionItemItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return PutCollectionsCollectionIDBodyCollectionItemItem(id, name, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class PutCollectionsCollectionIDBodyCollection:
    """For a complete list of values, refer to the [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    """An object that contains basic information about the collection. For a complete list of
    values, refer to the `definitions.info` entry in the [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    info: PutCollectionsCollectionIDBodyCollectionInfo
    """Information about the collection's contents, such as folders, requests, and responses.
    For a complete list of values, refer to the `/tmp/.tmpuwcs7M/item.json-group` entry in
    the [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    item: List[PutCollectionsCollectionIDBodyCollectionItemItem]

    def __init__(self, info: PutCollectionsCollectionIDBodyCollectionInfo, item: List[PutCollectionsCollectionIDBodyCollectionItemItem]) -> None:
        self.info = info
        self.item = item

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDBodyCollection':
        assert isinstance(obj, dict)
        info = PutCollectionsCollectionIDBodyCollectionInfo.from_dict(obj.get("info"))
        item = from_list(PutCollectionsCollectionIDBodyCollectionItemItem.from_dict, obj.get("item"))
        return PutCollectionsCollectionIDBodyCollection(info, item)

    def to_dict(self) -> dict:
        result: dict = {}
        result["info"] = to_class(PutCollectionsCollectionIDBodyCollectionInfo, self.info)
        result["item"] = from_list(lambda x: to_class(PutCollectionsCollectionIDBodyCollectionItemItem, x), self.item)
        return result


class PutCollectionsCollectionIDBody:
    """For a complete list of values, refer to the [collection.json schema
    file](https://schema.postman.com/json/collection/v2.1.0/collection.json).
    """
    collection: Optional[PutCollectionsCollectionIDBodyCollection]

    def __init__(self, collection: Optional[PutCollectionsCollectionIDBodyCollection]) -> None:
        self.collection = collection

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDBody':
        assert isinstance(obj, dict)
        collection = from_union([PutCollectionsCollectionIDBodyCollection.from_dict, from_none], obj.get("collection"))
        return PutCollectionsCollectionIDBody(collection)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([lambda x: to_class(PutCollectionsCollectionIDBodyCollection, x), from_none], self.collection)
        return result


class PutCollectionsCollectionIDFoldersFolderIDBody:
    """The folder properties to update. For a complete list of properties, refer to the
    [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    """The folder's description."""
    description: Optional[str]
    """The folder's name."""
    name: Optional[str]

    def __init__(self, description: Optional[str], name: Optional[str]) -> None:
        self.description = description
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDFoldersFolderIDBody':
        assert isinstance(obj, dict)
        description = from_union([from_str, from_none], obj.get("description"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDFoldersFolderIDBody(description, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDFoldersFolderIDResponseData:
    """The folder's updated information, including the updated properties. For a complete list
    of properties, refer to the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    """The collection ID that the folder belongs to."""
    collection: Optional[str]
    """The folder's creation date and time."""
    created_at: Optional[str]
    """The folder's description."""
    description: Optional[str]
    """Information about the folder."""
    folder: Optional[str]
    """The folder's ID."""
    id: Optional[str]
    """An internal revision ID. Its value increments each time the resource changes. You can use
    this ID to track whether there were changes since the last time you fetched the resource.
    """
    last_revision: Optional[float]
    """The user ID of the user that last updated the folder."""
    last_updated_by: Optional[str]
    """The folder's name."""
    name: Optional[str]
    """The user ID of the folder's owner."""
    owner: Optional[str]
    """The date and time at which the folder was last updated."""
    updated_at: Optional[str]

    def __init__(self, collection: Optional[str], created_at: Optional[str], description: Optional[str], folder: Optional[str], id: Optional[str], last_revision: Optional[float], last_updated_by: Optional[str], name: Optional[str], owner: Optional[str], updated_at: Optional[str]) -> None:
        self.collection = collection
        self.created_at = created_at
        self.description = description
        self.folder = folder
        self.id = id
        self.last_revision = last_revision
        self.last_updated_by = last_updated_by
        self.name = name
        self.owner = owner
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDFoldersFolderIDResponseData':
        assert isinstance(obj, dict)
        collection = from_union([from_str, from_none], obj.get("collection"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        description = from_union([from_str, from_none], obj.get("description"))
        folder = from_union([from_str, from_none], obj.get("folder"))
        id = from_union([from_str, from_none], obj.get("id"))
        last_revision = from_union([from_float, from_none], obj.get("lastRevision"))
        last_updated_by = from_union([from_str, from_none], obj.get("lastUpdatedBy"))
        name = from_union([from_str, from_none], obj.get("name"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return PutCollectionsCollectionIDFoldersFolderIDResponseData(collection, created_at, description, folder, id, last_revision, last_updated_by, name, owner, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([from_str, from_none], self.collection)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.folder is not None:
            result["folder"] = from_union([from_str, from_none], self.folder)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.last_revision is not None:
            result["lastRevision"] = from_union([to_float, from_none], self.last_revision)
        if self.last_updated_by is not None:
            result["lastUpdatedBy"] = from_union([from_str, from_none], self.last_updated_by)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class PutCollectionsCollectionIDFoldersFolderIDResponse:
    """The folder's updated information, including the updated properties. For a complete list
    of properties, refer to the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    data: Optional[PutCollectionsCollectionIDFoldersFolderIDResponseData]
    meta: Any
    """The folder's ID."""
    model_id: Optional[str]
    """An internal revision ID. Its value increments each time the resource changes. You can use
    this ID to track whether there were changes since the last time you fetched the resource.
    """
    revision: Optional[float]

    def __init__(self, data: Optional[PutCollectionsCollectionIDFoldersFolderIDResponseData], meta: Any, model_id: Optional[str], revision: Optional[float]) -> None:
        self.data = data
        self.meta = meta
        self.model_id = model_id
        self.revision = revision

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDFoldersFolderIDResponse':
        assert isinstance(obj, dict)
        data = from_union([PutCollectionsCollectionIDFoldersFolderIDResponseData.from_dict, from_none], obj.get("data"))
        meta = obj.get("meta")
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        revision = from_union([from_float, from_none], obj.get("revision"))
        return PutCollectionsCollectionIDFoldersFolderIDResponse(data, meta, model_id, revision)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: to_class(PutCollectionsCollectionIDFoldersFolderIDResponseData, x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = self.meta
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.revision is not None:
            result["revision"] = from_union([to_float, from_none], self.revision)
        return result


class PutCollectionsCollectionIDFoldersFolderIDResponse400ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The folder's ID."""
    model_id: Optional[str]
    """The user ID of the folder's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDFoldersFolderIDResponse400ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PutCollectionsCollectionIDFoldersFolderIDResponse400ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PutCollectionsCollectionIDFoldersFolderIDResponse400Error:
    """Information about the error."""
    details: Optional[PutCollectionsCollectionIDFoldersFolderIDResponse400ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PutCollectionsCollectionIDFoldersFolderIDResponse400ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDFoldersFolderIDResponse400Error':
        assert isinstance(obj, dict)
        details = from_union([PutCollectionsCollectionIDFoldersFolderIDResponse400ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDFoldersFolderIDResponse400Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PutCollectionsCollectionIDFoldersFolderIDResponse400ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDFoldersFolderIDResponse400:
    error: Optional[PutCollectionsCollectionIDFoldersFolderIDResponse400Error]

    def __init__(self, error: Optional[PutCollectionsCollectionIDFoldersFolderIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDFoldersFolderIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([PutCollectionsCollectionIDFoldersFolderIDResponse400Error.from_dict, from_none], obj.get("error"))
        return PutCollectionsCollectionIDFoldersFolderIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutCollectionsCollectionIDFoldersFolderIDResponse400Error, x), from_none], self.error)
        return result


class PutCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The folder's ID."""
    model_id: Optional[str]
    """The user ID of the folder's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PutCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PutCollectionsCollectionIDFoldersFolderIDResponse401Error:
    """Information about the error."""
    details: Optional[PutCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails]
    """The error's message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PutCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDFoldersFolderIDResponse401Error':
        assert isinstance(obj, dict)
        details = from_union([PutCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDFoldersFolderIDResponse401Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PutCollectionsCollectionIDFoldersFolderIDResponse401ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDFoldersFolderIDResponse401:
    error: Optional[PutCollectionsCollectionIDFoldersFolderIDResponse401Error]

    def __init__(self, error: Optional[PutCollectionsCollectionIDFoldersFolderIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDFoldersFolderIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([PutCollectionsCollectionIDFoldersFolderIDResponse401Error.from_dict, from_none], obj.get("error"))
        return PutCollectionsCollectionIDFoldersFolderIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutCollectionsCollectionIDFoldersFolderIDResponse401Error, x), from_none], self.error)
        return result


class PutCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The folder's ID."""
    model_id: Optional[str]
    """The user ID of the folder's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PutCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PutCollectionsCollectionIDFoldersFolderIDResponse404Error:
    """Information about the error."""
    details: Optional[PutCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PutCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDFoldersFolderIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([PutCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDFoldersFolderIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PutCollectionsCollectionIDFoldersFolderIDResponse404ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDFoldersFolderIDResponse404:
    error: Optional[PutCollectionsCollectionIDFoldersFolderIDResponse404Error]

    def __init__(self, error: Optional[PutCollectionsCollectionIDFoldersFolderIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDFoldersFolderIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([PutCollectionsCollectionIDFoldersFolderIDResponse404Error.from_dict, from_none], obj.get("error"))
        return PutCollectionsCollectionIDFoldersFolderIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutCollectionsCollectionIDFoldersFolderIDResponse404Error, x), from_none], self.error)
        return result


class PutCollectionsCollectionIDFoldersFolderIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDFoldersFolderIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutCollectionsCollectionIDFoldersFolderIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class Method(Enum):
    """The request's method."""
    COPY = "COPY"
    DELETE = "DELETE"
    GET = "GET"
    HEAD = "HEAD"
    LINK = "LINK"
    LOCK = "LOCK"
    OPTIONS = "OPTIONS"
    PATCH = "PATCH"
    POST = "POST"
    PROPFIND = "PROPFIND"
    PURGE = "PURGE"
    PUT = "PUT"
    UNLINK = "UNLINK"
    UNLOCK = "UNLOCK"
    VIEW = "VIEW"


class PutCollectionsCollectionIDRequestsRequestIDBody:
    """The request properties to update. For a complete list of properties, refer to the
    `definitions.request` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    """The request's method."""
    method: Optional[Method]
    """The request's name."""
    name: Optional[str]

    def __init__(self, method: Optional[Method], name: Optional[str]) -> None:
        self.method = method
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDRequestsRequestIDBody':
        assert isinstance(obj, dict)
        method = from_union([Method, from_none], obj.get("method"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDRequestsRequestIDBody(method, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.method is not None:
            result["method"] = from_union([lambda x: to_enum(Method, x), from_none], self.method)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDRequestsRequestIDResponseData:
    """Information about the updated request. For a complete list of properties, refer to the
    `definitions.request` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    """The request's creation date and time."""
    created_at: Optional[str]
    """The request's description."""
    description: Optional[str]
    """The request's ID."""
    id: Optional[str]
    """An internal revision ID. Its value increments each time the resource changes. You can use
    this ID to track whether there were changes since the last time you fetched the resource.
    """
    last_revision: Optional[float]
    """The user ID of the user that last updated the request."""
    last_updated_by: Optional[str]
    """The request's name."""
    name: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]
    """The date and time at which the request was last updated."""
    updated_at: Optional[str]

    def __init__(self, created_at: Optional[str], description: Optional[str], id: Optional[str], last_revision: Optional[float], last_updated_by: Optional[str], name: Optional[str], owner: Optional[str], updated_at: Optional[str]) -> None:
        self.created_at = created_at
        self.description = description
        self.id = id
        self.last_revision = last_revision
        self.last_updated_by = last_updated_by
        self.name = name
        self.owner = owner
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDRequestsRequestIDResponseData':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        description = from_union([from_str, from_none], obj.get("description"))
        id = from_union([from_str, from_none], obj.get("id"))
        last_revision = from_union([from_float, from_none], obj.get("lastRevision"))
        last_updated_by = from_union([from_str, from_none], obj.get("lastUpdatedBy"))
        name = from_union([from_str, from_none], obj.get("name"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return PutCollectionsCollectionIDRequestsRequestIDResponseData(created_at, description, id, last_revision, last_updated_by, name, owner, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.last_revision is not None:
            result["lastRevision"] = from_union([to_float, from_none], self.last_revision)
        if self.last_updated_by is not None:
            result["lastUpdatedBy"] = from_union([from_str, from_none], self.last_updated_by)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class PutCollectionsCollectionIDRequestsRequestIDResponse:
    """Information about the updated request. For a complete list of properties, refer to the
    `definitions.request` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    data: Optional[PutCollectionsCollectionIDRequestsRequestIDResponseData]
    meta: Any
    """The request's ID."""
    model_id: Optional[str]
    """An internal revision ID. Its value increments each time the resource changes. You can use
    this ID to track whether there were changes since the last time you fetched the resource.
    """
    revision: Optional[float]

    def __init__(self, data: Optional[PutCollectionsCollectionIDRequestsRequestIDResponseData], meta: Any, model_id: Optional[str], revision: Optional[float]) -> None:
        self.data = data
        self.meta = meta
        self.model_id = model_id
        self.revision = revision

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDRequestsRequestIDResponse':
        assert isinstance(obj, dict)
        data = from_union([PutCollectionsCollectionIDRequestsRequestIDResponseData.from_dict, from_none], obj.get("data"))
        meta = obj.get("meta")
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        revision = from_union([from_float, from_none], obj.get("revision"))
        return PutCollectionsCollectionIDRequestsRequestIDResponse(data, meta, model_id, revision)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: to_class(PutCollectionsCollectionIDRequestsRequestIDResponseData, x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = self.meta
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.revision is not None:
            result["revision"] = from_union([to_float, from_none], self.revision)
        return result


class PutCollectionsCollectionIDRequestsRequestIDResponse400ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The request's ID."""
    model_id: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDRequestsRequestIDResponse400ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PutCollectionsCollectionIDRequestsRequestIDResponse400ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PutCollectionsCollectionIDRequestsRequestIDResponse400Error:
    """Information about the error."""
    details: Optional[PutCollectionsCollectionIDRequestsRequestIDResponse400ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PutCollectionsCollectionIDRequestsRequestIDResponse400ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDRequestsRequestIDResponse400Error':
        assert isinstance(obj, dict)
        details = from_union([PutCollectionsCollectionIDRequestsRequestIDResponse400ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDRequestsRequestIDResponse400Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PutCollectionsCollectionIDRequestsRequestIDResponse400ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDRequestsRequestIDResponse400:
    error: Optional[PutCollectionsCollectionIDRequestsRequestIDResponse400Error]

    def __init__(self, error: Optional[PutCollectionsCollectionIDRequestsRequestIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDRequestsRequestIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([PutCollectionsCollectionIDRequestsRequestIDResponse400Error.from_dict, from_none], obj.get("error"))
        return PutCollectionsCollectionIDRequestsRequestIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutCollectionsCollectionIDRequestsRequestIDResponse400Error, x), from_none], self.error)
        return result


class PutCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The request's ID."""
    model_id: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PutCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PutCollectionsCollectionIDRequestsRequestIDResponse401Error:
    """Information about the error."""
    details: Optional[PutCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails]
    """The error's message."""
    message: Optional[str]
    """The error's name."""
    name: Optional[str]

    def __init__(self, details: Optional[PutCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDRequestsRequestIDResponse401Error':
        assert isinstance(obj, dict)
        details = from_union([PutCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDRequestsRequestIDResponse401Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PutCollectionsCollectionIDRequestsRequestIDResponse401ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDRequestsRequestIDResponse401:
    error: Optional[PutCollectionsCollectionIDRequestsRequestIDResponse401Error]

    def __init__(self, error: Optional[PutCollectionsCollectionIDRequestsRequestIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDRequestsRequestIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([PutCollectionsCollectionIDRequestsRequestIDResponse401Error.from_dict, from_none], obj.get("error"))
        return PutCollectionsCollectionIDRequestsRequestIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutCollectionsCollectionIDRequestsRequestIDResponse401Error, x), from_none], self.error)
        return result


class PutCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The request's ID."""
    model_id: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PutCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PutCollectionsCollectionIDRequestsRequestIDResponse404Error:
    """Information about the error."""
    details: Optional[PutCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PutCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDRequestsRequestIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([PutCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDRequestsRequestIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PutCollectionsCollectionIDRequestsRequestIDResponse404ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDRequestsRequestIDResponse404:
    error: Optional[PutCollectionsCollectionIDRequestsRequestIDResponse404Error]

    def __init__(self, error: Optional[PutCollectionsCollectionIDRequestsRequestIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDRequestsRequestIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([PutCollectionsCollectionIDRequestsRequestIDResponse404Error.from_dict, from_none], obj.get("error"))
        return PutCollectionsCollectionIDRequestsRequestIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutCollectionsCollectionIDRequestsRequestIDResponse404Error, x), from_none], self.error)
        return result


class PutCollectionsCollectionIDRequestsRequestIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDRequestsRequestIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutCollectionsCollectionIDRequestsRequestIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutCollectionsCollectionIDResponseCollection:
    """The collection's ID."""
    id: Optional[str]
    """The collection's name."""
    name: Optional[str]
    """The collection's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.name = name
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponseCollection':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return PutCollectionsCollectionIDResponseCollection(id, name, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class PutCollectionsCollectionIDResponse:
    collection: Optional[PutCollectionsCollectionIDResponseCollection]

    def __init__(self, collection: Optional[PutCollectionsCollectionIDResponseCollection]) -> None:
        self.collection = collection

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponse':
        assert isinstance(obj, dict)
        collection = from_union([PutCollectionsCollectionIDResponseCollection.from_dict, from_none], obj.get("collection"))
        return PutCollectionsCollectionIDResponse(collection)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponseCollection, x), from_none], self.collection)
        return result


class PutCollectionsCollectionIDResponse400Error:
    """Information about the error."""
    details: Optional[List[str]]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[List[str]], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponse400Error':
        assert isinstance(obj, dict)
        details = from_union([lambda x: from_list(from_str, x), from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDResponse400Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: from_list(from_str, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDResponse400:
    error: Optional[PutCollectionsCollectionIDResponse400Error]

    def __init__(self, error: Optional[PutCollectionsCollectionIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([PutCollectionsCollectionIDResponse400Error.from_dict, from_none], obj.get("error"))
        return PutCollectionsCollectionIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponse400Error, x), from_none], self.error)
        return result


class PutCollectionsCollectionIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDResponse401:
    error: Optional[PutCollectionsCollectionIDResponse401Error]

    def __init__(self, error: Optional[PutCollectionsCollectionIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([PutCollectionsCollectionIDResponse401Error.from_dict, from_none], obj.get("error"))
        return PutCollectionsCollectionIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponse401Error, x), from_none], self.error)
        return result


class PutCollectionsCollectionIDResponse403Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponse403Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDResponse403Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDResponse403:
    error: Optional[PutCollectionsCollectionIDResponse403Error]

    def __init__(self, error: Optional[PutCollectionsCollectionIDResponse403Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponse403':
        assert isinstance(obj, dict)
        error = from_union([PutCollectionsCollectionIDResponse403Error.from_dict, from_none], obj.get("error"))
        return PutCollectionsCollectionIDResponse403(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponse403Error, x), from_none], self.error)
        return result


class PutCollectionsCollectionIDResponse404ErrorDetails:
    """Information about the error."""
    """The collection ID."""
    id: Optional[str]
    """The instance item."""
    item: Optional[str]

    def __init__(self, id: Optional[str], item: Optional[str]) -> None:
        self.id = id
        self.item = item

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponse404ErrorDetails':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        item = from_union([from_str, from_none], obj.get("item"))
        return PutCollectionsCollectionIDResponse404ErrorDetails(id, item)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.item is not None:
            result["item"] = from_union([from_str, from_none], self.item)
        return result


class PutCollectionsCollectionIDResponse404Error:
    """Information about the error."""
    details: Optional[PutCollectionsCollectionIDResponse404ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PutCollectionsCollectionIDResponse404ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([PutCollectionsCollectionIDResponse404ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponse404ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDResponse404:
    error: Optional[PutCollectionsCollectionIDResponse404Error]

    def __init__(self, error: Optional[PutCollectionsCollectionIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([PutCollectionsCollectionIDResponse404Error.from_dict, from_none], obj.get("error"))
        return PutCollectionsCollectionIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponse404Error, x), from_none], self.error)
        return result


class PutCollectionsCollectionIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PutCollectionsCollectionIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PutCollectionsCollectionIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDResponse500:
    error: Optional[PutCollectionsCollectionIDResponse500Error]

    def __init__(self, error: Optional[PutCollectionsCollectionIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([PutCollectionsCollectionIDResponse500Error.from_dict, from_none], obj.get("error"))
        return PutCollectionsCollectionIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponse500Error, x), from_none], self.error)
        return result


class PutCollectionsCollectionIDResponsesResponseIDBodyResponseCode:
    """The response's HTTP response code information."""
    """The response's HTTP response status code."""
    code: Optional[float]
    """The name of the status code."""
    name: Optional[str]

    def __init__(self, code: Optional[float], name: Optional[str]) -> None:
        self.code = code
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponsesResponseIDBodyResponseCode':
        assert isinstance(obj, dict)
        code = from_union([from_float, from_none], obj.get("code"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDResponsesResponseIDBodyResponseCode(code, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.code is not None:
            result["code"] = from_union([to_float, from_none], self.code)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDResponsesResponseIDBody:
    """The response properties to update. For a complete list of properties, refer to the
    `definitions.request.responses` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    """The response's name."""
    name: Optional[str]
    """The response's HTTP response code information."""
    response_code: Optional[PutCollectionsCollectionIDResponsesResponseIDBodyResponseCode]

    def __init__(self, name: Optional[str], response_code: Optional[PutCollectionsCollectionIDResponsesResponseIDBodyResponseCode]) -> None:
        self.name = name
        self.response_code = response_code

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponsesResponseIDBody':
        assert isinstance(obj, dict)
        name = from_union([from_str, from_none], obj.get("name"))
        response_code = from_union([PutCollectionsCollectionIDResponsesResponseIDBodyResponseCode.from_dict, from_none], obj.get("responseCode"))
        return PutCollectionsCollectionIDResponsesResponseIDBody(name, response_code)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.response_code is not None:
            result["responseCode"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponsesResponseIDBodyResponseCode, x), from_none], self.response_code)
        return result


class PutCollectionsCollectionIDResponsesResponseIDResponseData:
    """Information about the updated response. For a complete list of request properties, refer
    to the `definitions.request` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    """The request's creation date and time."""
    created_at: Optional[str]
    """The request's ID."""
    id: Optional[str]
    """An internal revision ID. Its value increments each time the resource changes. You can use
    this ID to track whether there were changes since the last time you fetched the resource.
    """
    last_revision: Optional[int]
    """The user ID of the user that last updated the request."""
    last_updated_by: Optional[str]
    """The request's name."""
    name: Optional[str]
    """The user ID of the request's owner."""
    owner: Optional[str]
    """The date and time at which the request was last updated."""
    updated_at: Optional[str]

    def __init__(self, created_at: Optional[str], id: Optional[str], last_revision: Optional[int], last_updated_by: Optional[str], name: Optional[str], owner: Optional[str], updated_at: Optional[str]) -> None:
        self.created_at = created_at
        self.id = id
        self.last_revision = last_revision
        self.last_updated_by = last_updated_by
        self.name = name
        self.owner = owner
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponsesResponseIDResponseData':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        id = from_union([from_str, from_none], obj.get("id"))
        last_revision = from_union([from_int, from_none], obj.get("lastRevision"))
        last_updated_by = from_union([from_str, from_none], obj.get("lastUpdatedBy"))
        name = from_union([from_str, from_none], obj.get("name"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return PutCollectionsCollectionIDResponsesResponseIDResponseData(created_at, id, last_revision, last_updated_by, name, owner, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.last_revision is not None:
            result["lastRevision"] = from_union([from_int, from_none], self.last_revision)
        if self.last_updated_by is not None:
            result["lastUpdatedBy"] = from_union([from_str, from_none], self.last_updated_by)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class PutCollectionsCollectionIDResponsesResponseIDResponse:
    """Information about the updated response. For a complete list of request properties, refer
    to the `definitions.request` property in the [collection.json schema
    file](https://schema.postman.com/collection/json/v1.0.0/draft-07/collection.json).
    """
    data: Optional[PutCollectionsCollectionIDResponsesResponseIDResponseData]
    meta: Any
    """The request's ID."""
    model_id: Optional[str]

    def __init__(self, data: Optional[PutCollectionsCollectionIDResponsesResponseIDResponseData], meta: Any, model_id: Optional[str]) -> None:
        self.data = data
        self.meta = meta
        self.model_id = model_id

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponsesResponseIDResponse':
        assert isinstance(obj, dict)
        data = from_union([PutCollectionsCollectionIDResponsesResponseIDResponseData.from_dict, from_none], obj.get("data"))
        meta = obj.get("meta")
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        return PutCollectionsCollectionIDResponsesResponseIDResponse(data, meta, model_id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.data is not None:
            result["data"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponsesResponseIDResponseData, x), from_none], self.data)
        if self.meta is not None:
            result["meta"] = self.meta
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        return result


class PutCollectionsCollectionIDResponsesResponseIDResponse400ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The response's ID."""
    model_id: Optional[str]
    """The user ID of the response's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponsesResponseIDResponse400ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PutCollectionsCollectionIDResponsesResponseIDResponse400ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PutCollectionsCollectionIDResponsesResponseIDResponse400Error:
    """Information about the error."""
    details: Optional[PutCollectionsCollectionIDResponsesResponseIDResponse400ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PutCollectionsCollectionIDResponsesResponseIDResponse400ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponsesResponseIDResponse400Error':
        assert isinstance(obj, dict)
        details = from_union([PutCollectionsCollectionIDResponsesResponseIDResponse400ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDResponsesResponseIDResponse400Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponsesResponseIDResponse400ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDResponsesResponseIDResponse400:
    error: Optional[PutCollectionsCollectionIDResponsesResponseIDResponse400Error]

    def __init__(self, error: Optional[PutCollectionsCollectionIDResponsesResponseIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponsesResponseIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([PutCollectionsCollectionIDResponsesResponseIDResponse400Error.from_dict, from_none], obj.get("error"))
        return PutCollectionsCollectionIDResponsesResponseIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponsesResponseIDResponse400Error, x), from_none], self.error)
        return result


class PutCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The response's ID."""
    model_id: Optional[str]
    """The user ID of the response's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PutCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PutCollectionsCollectionIDResponsesResponseIDResponse401Error:
    """Information about the error."""
    details: Optional[PutCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PutCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponsesResponseIDResponse401Error':
        assert isinstance(obj, dict)
        details = from_union([PutCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDResponsesResponseIDResponse401Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponsesResponseIDResponse401ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDResponsesResponseIDResponse401:
    error: Optional[PutCollectionsCollectionIDResponsesResponseIDResponse401Error]

    def __init__(self, error: Optional[PutCollectionsCollectionIDResponsesResponseIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponsesResponseIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([PutCollectionsCollectionIDResponsesResponseIDResponse401Error.from_dict, from_none], obj.get("error"))
        return PutCollectionsCollectionIDResponsesResponseIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponsesResponseIDResponse401Error, x), from_none], self.error)
        return result


class PutCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails:
    """Information about the error."""
    """The resource name."""
    model: Optional[str]
    """The response's ID."""
    model_id: Optional[str]
    """The user ID of the response's owner."""
    owner: Optional[str]

    def __init__(self, model: Optional[str], model_id: Optional[str], owner: Optional[str]) -> None:
        self.model = model
        self.model_id = model_id
        self.owner = owner

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails':
        assert isinstance(obj, dict)
        model = from_union([from_str, from_none], obj.get("model"))
        model_id = from_union([from_str, from_none], obj.get("model_id"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        return PutCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails(model, model_id, owner)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.model is not None:
            result["model"] = from_union([from_str, from_none], self.model)
        if self.model_id is not None:
            result["model_id"] = from_union([from_str, from_none], self.model_id)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        return result


class PutCollectionsCollectionIDResponsesResponseIDResponse404Error:
    """Information about the error."""
    details: Optional[PutCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PutCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponsesResponseIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([PutCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutCollectionsCollectionIDResponsesResponseIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponsesResponseIDResponse404ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutCollectionsCollectionIDResponsesResponseIDResponse404:
    error: Optional[PutCollectionsCollectionIDResponsesResponseIDResponse404Error]

    def __init__(self, error: Optional[PutCollectionsCollectionIDResponsesResponseIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponsesResponseIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([PutCollectionsCollectionIDResponsesResponseIDResponse404Error.from_dict, from_none], obj.get("error"))
        return PutCollectionsCollectionIDResponsesResponseIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutCollectionsCollectionIDResponsesResponseIDResponse404Error, x), from_none], self.error)
        return result


class PutCollectionsCollectionIDResponsesResponseIDResponse500:
    """Details about the error message."""
    detail: Optional[str]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDResponsesResponseIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutCollectionsCollectionIDResponsesResponseIDResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutCollectionsCollectionIDTagsBodyTagsItem:
    """Information about the tag."""
    """The tag's ID within a team or individual (non-team) user scope."""
    slug: str

    def __init__(self, slug: str) -> None:
        self.slug = slug

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDTagsBodyTagsItem':
        assert isinstance(obj, dict)
        slug = from_str(obj.get("slug"))
        return PutCollectionsCollectionIDTagsBodyTagsItem(slug)

    def to_dict(self) -> dict:
        result: dict = {}
        result["slug"] = from_str(self.slug)
        return result


class PutCollectionsCollectionIDTagsBody:
    """A list of the associated tags as slugs."""
    tags: List[PutCollectionsCollectionIDTagsBodyTagsItem]

    def __init__(self, tags: List[PutCollectionsCollectionIDTagsBodyTagsItem]) -> None:
        self.tags = tags

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDTagsBody':
        assert isinstance(obj, dict)
        tags = from_list(PutCollectionsCollectionIDTagsBodyTagsItem.from_dict, obj.get("tags"))
        return PutCollectionsCollectionIDTagsBody(tags)

    def to_dict(self) -> dict:
        result: dict = {}
        result["tags"] = from_list(lambda x: to_class(PutCollectionsCollectionIDTagsBodyTagsItem, x), self.tags)
        return result


class PutCollectionsCollectionIDTagsResponseTagsItem:
    """Information about the tag."""
    """The tag's ID within a team or individual (non-team) user scope."""
    slug: Optional[str]

    def __init__(self, slug: Optional[str]) -> None:
        self.slug = slug

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDTagsResponseTagsItem':
        assert isinstance(obj, dict)
        slug = from_union([from_str, from_none], obj.get("slug"))
        return PutCollectionsCollectionIDTagsResponseTagsItem(slug)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.slug is not None:
            result["slug"] = from_union([from_str, from_none], self.slug)
        return result


class PutCollectionsCollectionIDTagsResponse:
    """A list of associated tags."""
    tags: Optional[List[PutCollectionsCollectionIDTagsResponseTagsItem]]

    def __init__(self, tags: Optional[List[PutCollectionsCollectionIDTagsResponseTagsItem]]) -> None:
        self.tags = tags

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDTagsResponse':
        assert isinstance(obj, dict)
        tags = from_union([lambda x: from_list(PutCollectionsCollectionIDTagsResponseTagsItem.from_dict, x), from_none], obj.get("tags"))
        return PutCollectionsCollectionIDTagsResponse(tags)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.tags is not None:
            result["tags"] = from_union([lambda x: from_list(lambda x: to_class(PutCollectionsCollectionIDTagsResponseTagsItem, x), x), from_none], self.tags)
        return result


class PutCollectionsCollectionIDTagsResponse400:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDTagsResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutCollectionsCollectionIDTagsResponse400(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutCollectionsCollectionIDTagsResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDTagsResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutCollectionsCollectionIDTagsResponse401(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutCollectionsCollectionIDTagsResponse403:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDTagsResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutCollectionsCollectionIDTagsResponse403(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutCollectionsCollectionIDTagsResponse404:
    """Information about the error."""
    detail: Optional[str]
    """The URI reference that identifies the specific occurrence of the problem."""
    instance: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDTagsResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutCollectionsCollectionIDTagsResponse404(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutCollectionsCollectionIDTagsResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The URI reference that identifies the specific occurrence of the problem."""
    instance: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutCollectionsCollectionIDTagsResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutCollectionsCollectionIDTagsResponse500(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutDetectedSecretsSecretIDBody:
    """The secret's updated resolution status:
    - `FALSE_POSITIVE`  The discovered secret is not an actual secret.
    - `REVOKED`  The secret is valid, but the user rotated their key to resolve the issue.
    - `ACCEPTED_RISK`  The Secret Scanner found the secret, but user accepts the risk of
    publishing it.
    """
    resolution: Resolution
    """The ID of the workspace that contains the secret."""
    workspace_id: str

    def __init__(self, resolution: Resolution, workspace_id: str) -> None:
        self.resolution = resolution
        self.workspace_id = workspace_id

    @staticmethod
    def from_dict(obj: Any) -> 'PutDetectedSecretsSecretIDBody':
        assert isinstance(obj, dict)
        resolution = Resolution(obj.get("resolution"))
        workspace_id = from_str(obj.get("workspaceId"))
        return PutDetectedSecretsSecretIDBody(resolution, workspace_id)

    def to_dict(self) -> dict:
        result: dict = {}
        result["resolution"] = to_enum(Resolution, self.resolution)
        result["workspaceId"] = from_str(self.workspace_id)
        return result


class PutDetectedSecretsSecretIDResponseHistoryItem:
    """The ID of the user that updated the secret's resolution status."""
    actor: Optional[float]
    """The date and time at which the resolution status was updated."""
    created_at: Optional[str]
    """The secret's updated resolution status:
    - `ACTIVE`  The secret is active.
    - `FALSE_POSITIVE`  The discovered secret is not an actual secret.
    - `REVOKED`  The secret is valid, but the user rotated their key to resolve the issue.
    - `ACCEPTED_RISK`  The Secret Scanner found the secret, but user accepts the risk of
    publishing it.
    """
    resolution: Optional[ResolutionEnum]

    def __init__(self, actor: Optional[float], created_at: Optional[str], resolution: Optional[ResolutionEnum]) -> None:
        self.actor = actor
        self.created_at = created_at
        self.resolution = resolution

    @staticmethod
    def from_dict(obj: Any) -> 'PutDetectedSecretsSecretIDResponseHistoryItem':
        assert isinstance(obj, dict)
        actor = from_union([from_float, from_none], obj.get("actor"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        resolution = from_union([ResolutionEnum, from_none], obj.get("resolution"))
        return PutDetectedSecretsSecretIDResponseHistoryItem(actor, created_at, resolution)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.actor is not None:
            result["actor"] = from_union([to_float, from_none], self.actor)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.resolution is not None:
            result["resolution"] = from_union([lambda x: to_enum(ResolutionEnum, x), from_none], self.resolution)
        return result


class PutDetectedSecretsSecretIDResponse:
    """The history of the secret's resolution status changes."""
    history: Optional[List[PutDetectedSecretsSecretIDResponseHistoryItem]]
    """The secret's current resolution status:
    - `ACTIVE`  The secret is active.
    - `FALSE_POSITIVE`  The discovered secret is not an actual secret.
    - `REVOKED`  The secret is valid, but the user rotated their key to resolve the issue.
    - `ACCEPTED_RISK`  The Secret Scanner found the secret, but user accepts the risk of
    publishing it.
    """
    resolution: Optional[ResolutionEnum]
    """The SHA-256 hash of the detected secret."""
    secret_hash: Optional[str]
    """The ID of the workspace that contains the secret."""
    workspace_id: Optional[str]

    def __init__(self, history: Optional[List[PutDetectedSecretsSecretIDResponseHistoryItem]], resolution: Optional[ResolutionEnum], secret_hash: Optional[str], workspace_id: Optional[str]) -> None:
        self.history = history
        self.resolution = resolution
        self.secret_hash = secret_hash
        self.workspace_id = workspace_id

    @staticmethod
    def from_dict(obj: Any) -> 'PutDetectedSecretsSecretIDResponse':
        assert isinstance(obj, dict)
        history = from_union([lambda x: from_list(PutDetectedSecretsSecretIDResponseHistoryItem.from_dict, x), from_none], obj.get("history"))
        resolution = from_union([ResolutionEnum, from_none], obj.get("resolution"))
        secret_hash = from_union([from_str, from_none], obj.get("secretHash"))
        workspace_id = from_union([from_str, from_none], obj.get("workspaceId"))
        return PutDetectedSecretsSecretIDResponse(history, resolution, secret_hash, workspace_id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.history is not None:
            result["history"] = from_union([lambda x: from_list(lambda x: to_class(PutDetectedSecretsSecretIDResponseHistoryItem, x), x), from_none], self.history)
        if self.resolution is not None:
            result["resolution"] = from_union([lambda x: to_enum(ResolutionEnum, x), from_none], self.resolution)
        if self.secret_hash is not None:
            result["secretHash"] = from_union([from_str, from_none], self.secret_hash)
        if self.workspace_id is not None:
            result["workspaceId"] = from_union([from_str, from_none], self.workspace_id)
        return result


class PutDetectedSecretsSecretIDResponse401:
    """The instance identifying the specific occurrence of the problem."""
    instance: Optional[str]
    """The HTTP status code generated by the origin server."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutDetectedSecretsSecretIDResponse401':
        assert isinstance(obj, dict)
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutDetectedSecretsSecretIDResponse401(instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutDetectedSecretsSecretIDResponse403:
    """The instance identifying the specific occurrence of the problem."""
    instance: Optional[str]
    """The HTTP status code generated by the origin server."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutDetectedSecretsSecretIDResponse403':
        assert isinstance(obj, dict)
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutDetectedSecretsSecretIDResponse403(instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutDetectedSecretsSecretIDResponse500:
    """The instance identifying the specific occurrence of the problem."""
    instance: Optional[str]
    """The HTTP status code generated by the origin server."""
    status: Optional[float]
    """The generic description for the error's class."""
    title: Optional[str]
    """The type of error."""
    type: Optional[str]

    def __init__(self, instance: Optional[str], status: Optional[float], title: Optional[str], type: Optional[str]) -> None:
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutDetectedSecretsSecretIDResponse500':
        assert isinstance(obj, dict)
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_float, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutDetectedSecretsSecretIDResponse500(instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutEnvironmentsEnvironmentIDBodyEnvironmentValuesItemItem:
    """If true, the variable is enabled."""
    enabled: Optional[bool]
    """The variable's name."""
    key: Optional[str]
    """The variable type."""
    type: Optional[PurpleType]
    """The variable's value."""
    value: Optional[str]

    def __init__(self, enabled: Optional[bool], key: Optional[str], type: Optional[PurpleType], value: Optional[str]) -> None:
        self.enabled = enabled
        self.key = key
        self.type = type
        self.value = value

    @staticmethod
    def from_dict(obj: Any) -> 'PutEnvironmentsEnvironmentIDBodyEnvironmentValuesItemItem':
        assert isinstance(obj, dict)
        enabled = from_union([from_bool, from_none], obj.get("enabled"))
        key = from_union([from_str, from_none], obj.get("key"))
        type = from_union([PurpleType, from_none], obj.get("type"))
        value = from_union([from_str, from_none], obj.get("value"))
        return PutEnvironmentsEnvironmentIDBodyEnvironmentValuesItemItem(enabled, key, type, value)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.enabled is not None:
            result["enabled"] = from_union([from_bool, from_none], self.enabled)
        if self.key is not None:
            result["key"] = from_union([from_str, from_none], self.key)
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(PurpleType, x), from_none], self.type)
        if self.value is not None:
            result["value"] = from_union([from_str, from_none], self.value)
        return result


class PutEnvironmentsEnvironmentIDBodyEnvironment:
    """The environment's name."""
    name: str
    """Information about the environment's variables."""
    values: Optional[List[List[PutEnvironmentsEnvironmentIDBodyEnvironmentValuesItemItem]]]

    def __init__(self, name: str, values: Optional[List[List[PutEnvironmentsEnvironmentIDBodyEnvironmentValuesItemItem]]]) -> None:
        self.name = name
        self.values = values

    @staticmethod
    def from_dict(obj: Any) -> 'PutEnvironmentsEnvironmentIDBodyEnvironment':
        assert isinstance(obj, dict)
        name = from_str(obj.get("name"))
        values = from_union([lambda x: from_list(lambda x: from_list(PutEnvironmentsEnvironmentIDBodyEnvironmentValuesItemItem.from_dict, x), x), from_none], obj.get("values"))
        return PutEnvironmentsEnvironmentIDBodyEnvironment(name, values)

    def to_dict(self) -> dict:
        result: dict = {}
        result["name"] = from_str(self.name)
        if self.values is not None:
            result["values"] = from_union([lambda x: from_list(lambda x: from_list(lambda x: to_class(PutEnvironmentsEnvironmentIDBodyEnvironmentValuesItemItem, x), x), x), from_none], self.values)
        return result


class PutEnvironmentsEnvironmentIDBody:
    environment: Optional[PutEnvironmentsEnvironmentIDBodyEnvironment]

    def __init__(self, environment: Optional[PutEnvironmentsEnvironmentIDBodyEnvironment]) -> None:
        self.environment = environment

    @staticmethod
    def from_dict(obj: Any) -> 'PutEnvironmentsEnvironmentIDBody':
        assert isinstance(obj, dict)
        environment = from_union([PutEnvironmentsEnvironmentIDBodyEnvironment.from_dict, from_none], obj.get("environment"))
        return PutEnvironmentsEnvironmentIDBody(environment)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.environment is not None:
            result["environment"] = from_union([lambda x: to_class(PutEnvironmentsEnvironmentIDBodyEnvironment, x), from_none], self.environment)
        return result


class PutEnvironmentsEnvironmentIDResponseEnvironment:
    id: Optional[str]
    name: Optional[str]
    uid: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.name = name
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'PutEnvironmentsEnvironmentIDResponseEnvironment':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return PutEnvironmentsEnvironmentIDResponseEnvironment(id, name, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class PutEnvironmentsEnvironmentIDResponse:
    environment: Optional[PutEnvironmentsEnvironmentIDResponseEnvironment]

    def __init__(self, environment: Optional[PutEnvironmentsEnvironmentIDResponseEnvironment]) -> None:
        self.environment = environment

    @staticmethod
    def from_dict(obj: Any) -> 'PutEnvironmentsEnvironmentIDResponse':
        assert isinstance(obj, dict)
        environment = from_union([PutEnvironmentsEnvironmentIDResponseEnvironment.from_dict, from_none], obj.get("environment"))
        return PutEnvironmentsEnvironmentIDResponse(environment)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.environment is not None:
            result["environment"] = from_union([lambda x: to_class(PutEnvironmentsEnvironmentIDResponseEnvironment, x), from_none], self.environment)
        return result


class PutEnvironmentsEnvironmentIDResponse400Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutEnvironmentsEnvironmentIDResponse400Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutEnvironmentsEnvironmentIDResponse400Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutEnvironmentsEnvironmentIDResponse400:
    error: Optional[PutEnvironmentsEnvironmentIDResponse400Error]

    def __init__(self, error: Optional[PutEnvironmentsEnvironmentIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutEnvironmentsEnvironmentIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([PutEnvironmentsEnvironmentIDResponse400Error.from_dict, from_none], obj.get("error"))
        return PutEnvironmentsEnvironmentIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutEnvironmentsEnvironmentIDResponse400Error, x), from_none], self.error)
        return result


class PutEnvironmentsEnvironmentIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutEnvironmentsEnvironmentIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutEnvironmentsEnvironmentIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutEnvironmentsEnvironmentIDResponse401:
    error: Optional[PutEnvironmentsEnvironmentIDResponse401Error]

    def __init__(self, error: Optional[PutEnvironmentsEnvironmentIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutEnvironmentsEnvironmentIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([PutEnvironmentsEnvironmentIDResponse401Error.from_dict, from_none], obj.get("error"))
        return PutEnvironmentsEnvironmentIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutEnvironmentsEnvironmentIDResponse401Error, x), from_none], self.error)
        return result


class PutEnvironmentsEnvironmentIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PutEnvironmentsEnvironmentIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PutEnvironmentsEnvironmentIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PutEnvironmentsEnvironmentIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutEnvironmentsEnvironmentIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutEnvironmentsEnvironmentIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutEnvironmentsEnvironmentIDResponse500:
    error: Optional[PutEnvironmentsEnvironmentIDResponse500Error]

    def __init__(self, error: Optional[PutEnvironmentsEnvironmentIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutEnvironmentsEnvironmentIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([PutEnvironmentsEnvironmentIDResponse500Error.from_dict, from_none], obj.get("error"))
        return PutEnvironmentsEnvironmentIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutEnvironmentsEnvironmentIDResponse500Error, x), from_none], self.error)
        return result


class PutMocksMockIDBodyMockConfig:
    """The mock server's configuration settings."""
    """The server response ID. This sets the given server response as the default response for
    each request.
    
    To deactivate a server response, pass a null value.
    """
    server_response_id: Optional[str]

    def __init__(self, server_response_id: Optional[str]) -> None:
        self.server_response_id = server_response_id

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDBodyMockConfig':
        assert isinstance(obj, dict)
        server_response_id = from_union([from_none, from_str], obj.get("serverResponseId"))
        return PutMocksMockIDBodyMockConfig(server_response_id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.server_response_id is not None:
            result["serverResponseId"] = from_union([from_none, from_str], self.server_response_id)
        return result


class PutMocksMockIDBodyMock:
    """The mock server's configuration settings."""
    config: Optional[PutMocksMockIDBodyMockConfig]
    """The mock server's description."""
    description: Optional[str]
    """The associated environment's unique ID."""
    environment: Optional[str]
    """The mock server's name."""
    name: Optional[str]
    """If true, the mock server is set private. By default, mock servers are public and can
    receive requests from anyone and anywhere.
    """
    private: Optional[bool]
    """The API's version tag ID."""
    version_tag: Optional[str]

    def __init__(self, config: Optional[PutMocksMockIDBodyMockConfig], description: Optional[str], environment: Optional[str], name: Optional[str], private: Optional[bool], version_tag: Optional[str]) -> None:
        self.config = config
        self.description = description
        self.environment = environment
        self.name = name
        self.private = private
        self.version_tag = version_tag

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDBodyMock':
        assert isinstance(obj, dict)
        config = from_union([PutMocksMockIDBodyMockConfig.from_dict, from_none], obj.get("config"))
        description = from_union([from_str, from_none], obj.get("description"))
        environment = from_union([from_str, from_none], obj.get("environment"))
        name = from_union([from_str, from_none], obj.get("name"))
        private = from_union([from_bool, from_none], obj.get("private"))
        version_tag = from_union([from_str, from_none], obj.get("versionTag"))
        return PutMocksMockIDBodyMock(config, description, environment, name, private, version_tag)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.config is not None:
            result["config"] = from_union([lambda x: to_class(PutMocksMockIDBodyMockConfig, x), from_none], self.config)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.environment is not None:
            result["environment"] = from_union([from_str, from_none], self.environment)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.private is not None:
            result["private"] = from_union([from_bool, from_none], self.private)
        if self.version_tag is not None:
            result["versionTag"] = from_union([from_str, from_none], self.version_tag)
        return result


class PutMocksMockIDBody:
    mock: Optional[PutMocksMockIDBodyMock]

    def __init__(self, mock: Optional[PutMocksMockIDBodyMock]) -> None:
        self.mock = mock

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDBody':
        assert isinstance(obj, dict)
        mock = from_union([PutMocksMockIDBodyMock.from_dict, from_none], obj.get("mock"))
        return PutMocksMockIDBody(mock)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.mock is not None:
            result["mock"] = from_union([lambda x: to_class(PutMocksMockIDBodyMock, x), from_none], self.mock)
        return result


class PutMocksMockIDResponseMockConfig:
    """Information about the mock server's configuration."""
    """A list of the mock server's headers."""
    headers: Optional[List[Any]]
    """If true, match the request body."""
    match_body: Optional[bool]
    """If true, match query parameters."""
    match_query_params: Optional[bool]
    """If true, use wildcard variable matching."""
    match_wildcards: Optional[bool]

    def __init__(self, headers: Optional[List[Any]], match_body: Optional[bool], match_query_params: Optional[bool], match_wildcards: Optional[bool]) -> None:
        self.headers = headers
        self.match_body = match_body
        self.match_query_params = match_query_params
        self.match_wildcards = match_wildcards

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDResponseMockConfig':
        assert isinstance(obj, dict)
        headers = from_union([lambda x: from_list(lambda x: x, x), from_none], obj.get("headers"))
        match_body = from_union([from_bool, from_none], obj.get("matchBody"))
        match_query_params = from_union([from_bool, from_none], obj.get("matchQueryParams"))
        match_wildcards = from_union([from_bool, from_none], obj.get("matchWildcards"))
        return PutMocksMockIDResponseMockConfig(headers, match_body, match_query_params, match_wildcards)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.headers is not None:
            result["headers"] = from_union([lambda x: from_list(lambda x: x, x), from_none], self.headers)
        if self.match_body is not None:
            result["matchBody"] = from_union([from_bool, from_none], self.match_body)
        if self.match_query_params is not None:
            result["matchQueryParams"] = from_union([from_bool, from_none], self.match_query_params)
        if self.match_wildcards is not None:
            result["matchWildcards"] = from_union([from_bool, from_none], self.match_wildcards)
        return result


class PutMocksMockIDResponseMock:
    """The mock's associated collection unique ID."""
    collection: Optional[str]
    """Information about the mock server's configuration."""
    config: Optional[PutMocksMockIDResponseMockConfig]
    """The date and time at which the mock server was created."""
    created_at: Optional[str]
    """The mock server's associated environment ID."""
    environment: Optional[str]
    """The mock server's ID."""
    id: Optional[str]
    """The mock server URL."""
    mock_url: Optional[str]
    """The mock server's name."""
    name: Optional[str]
    """The ID of mock server's owner."""
    owner: Optional[str]
    """The mock server's unique ID."""
    uid: Optional[str]
    """The date and time at which the mock server was last updated."""
    updated_at: Optional[str]

    def __init__(self, collection: Optional[str], config: Optional[PutMocksMockIDResponseMockConfig], created_at: Optional[str], environment: Optional[str], id: Optional[str], mock_url: Optional[str], name: Optional[str], owner: Optional[str], uid: Optional[str], updated_at: Optional[str]) -> None:
        self.collection = collection
        self.config = config
        self.created_at = created_at
        self.environment = environment
        self.id = id
        self.mock_url = mock_url
        self.name = name
        self.owner = owner
        self.uid = uid
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDResponseMock':
        assert isinstance(obj, dict)
        collection = from_union([from_str, from_none], obj.get("collection"))
        config = from_union([PutMocksMockIDResponseMockConfig.from_dict, from_none], obj.get("config"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        environment = from_union([from_str, from_none], obj.get("environment"))
        id = from_union([from_str, from_none], obj.get("id"))
        mock_url = from_union([from_str, from_none], obj.get("mockUrl"))
        name = from_union([from_str, from_none], obj.get("name"))
        owner = from_union([from_str, from_none], obj.get("owner"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return PutMocksMockIDResponseMock(collection, config, created_at, environment, id, mock_url, name, owner, uid, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([from_str, from_none], self.collection)
        if self.config is not None:
            result["config"] = from_union([lambda x: to_class(PutMocksMockIDResponseMockConfig, x), from_none], self.config)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.environment is not None:
            result["environment"] = from_union([from_str, from_none], self.environment)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.mock_url is not None:
            result["mockUrl"] = from_union([from_str, from_none], self.mock_url)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.owner is not None:
            result["owner"] = from_union([from_str, from_none], self.owner)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class PutMocksMockIDResponse:
    mock: Optional[PutMocksMockIDResponseMock]

    def __init__(self, mock: Optional[PutMocksMockIDResponseMock]) -> None:
        self.mock = mock

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDResponse':
        assert isinstance(obj, dict)
        mock = from_union([PutMocksMockIDResponseMock.from_dict, from_none], obj.get("mock"))
        return PutMocksMockIDResponse(mock)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.mock is not None:
            result["mock"] = from_union([lambda x: to_class(PutMocksMockIDResponseMock, x), from_none], self.mock)
        return result


class PutMocksMockIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutMocksMockIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutMocksMockIDResponse401:
    error: Optional[PutMocksMockIDResponse401Error]

    def __init__(self, error: Optional[PutMocksMockIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([PutMocksMockIDResponse401Error.from_dict, from_none], obj.get("error"))
        return PutMocksMockIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutMocksMockIDResponse401Error, x), from_none], self.error)
        return result


class PutMocksMockIDResponse404Error:
    """Information about the error."""
    details: Optional[List[str]]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[List[str]], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDResponse404Error':
        assert isinstance(obj, dict)
        details = from_union([lambda x: from_list(from_str, x), from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutMocksMockIDResponse404Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: from_list(from_str, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutMocksMockIDResponse404:
    error: Optional[PutMocksMockIDResponse404Error]

    def __init__(self, error: Optional[PutMocksMockIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([PutMocksMockIDResponse404Error.from_dict, from_none], obj.get("error"))
        return PutMocksMockIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutMocksMockIDResponse404Error, x), from_none], self.error)
        return result


class PutMocksMockIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PutMocksMockIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PutMocksMockIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutMocksMockIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutMocksMockIDResponse500:
    error: Optional[PutMocksMockIDResponse500Error]

    def __init__(self, error: Optional[PutMocksMockIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([PutMocksMockIDResponse500Error.from_dict, from_none], obj.get("error"))
        return PutMocksMockIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutMocksMockIDResponse500Error, x), from_none], self.error)
        return result


class PutMocksMockIDServerResponsesServerResponseIDBodyServerResponseHeadersItem:
    """The request header's key value."""
    key: Optional[str]
    """The request header's value."""
    value: Optional[str]

    def __init__(self, key: Optional[str], value: Optional[str]) -> None:
        self.key = key
        self.value = value

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDServerResponsesServerResponseIDBodyServerResponseHeadersItem':
        assert isinstance(obj, dict)
        key = from_union([from_str, from_none], obj.get("key"))
        value = from_union([from_str, from_none], obj.get("value"))
        return PutMocksMockIDServerResponsesServerResponseIDBodyServerResponseHeadersItem(key, value)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.key is not None:
            result["key"] = from_union([from_str, from_none], self.key)
        if self.value is not None:
            result["value"] = from_union([from_str, from_none], self.value)
        return result


class PutMocksMockIDServerResponsesServerResponseIDBodyServerResponse:
    """The server response's body that returns when calling the mock server."""
    body: Optional[str]
    """The server response's request headers, such as Content-Type, Accept, encoding, and other
    information.
    """
    headers: Optional[List[PutMocksMockIDServerResponsesServerResponseIDBodyServerResponseHeadersItem]]
    """The server response's body language type."""
    language: Optional[DeleteMocksMockIDServerResponsesServerResponseIDResponseLanguage]
    """The server response's name."""
    name: Optional[str]
    """The server response's 5xx HTTP response code. This property **only** accepts 5xx values."""
    status_code: Optional[int]

    def __init__(self, body: Optional[str], headers: Optional[List[PutMocksMockIDServerResponsesServerResponseIDBodyServerResponseHeadersItem]], language: Optional[DeleteMocksMockIDServerResponsesServerResponseIDResponseLanguage], name: Optional[str], status_code: Optional[int]) -> None:
        self.body = body
        self.headers = headers
        self.language = language
        self.name = name
        self.status_code = status_code

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDServerResponsesServerResponseIDBodyServerResponse':
        assert isinstance(obj, dict)
        body = from_union([from_str, from_none], obj.get("body"))
        headers = from_union([lambda x: from_list(PutMocksMockIDServerResponsesServerResponseIDBodyServerResponseHeadersItem.from_dict, x), from_none], obj.get("headers"))
        language = from_union([DeleteMocksMockIDServerResponsesServerResponseIDResponseLanguage, from_none], obj.get("language"))
        name = from_union([from_str, from_none], obj.get("name"))
        status_code = from_union([from_int, from_none], obj.get("statusCode"))
        return PutMocksMockIDServerResponsesServerResponseIDBodyServerResponse(body, headers, language, name, status_code)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.body is not None:
            result["body"] = from_union([from_str, from_none], self.body)
        if self.headers is not None:
            result["headers"] = from_union([lambda x: from_list(lambda x: to_class(PutMocksMockIDServerResponsesServerResponseIDBodyServerResponseHeadersItem, x), x), from_none], self.headers)
        if self.language is not None:
            result["language"] = from_union([lambda x: to_enum(DeleteMocksMockIDServerResponsesServerResponseIDResponseLanguage, x), from_none], self.language)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.status_code is not None:
            result["statusCode"] = from_union([from_int, from_none], self.status_code)
        return result


class PutMocksMockIDServerResponsesServerResponseIDBody:
    server_response: Optional[PutMocksMockIDServerResponsesServerResponseIDBodyServerResponse]

    def __init__(self, server_response: Optional[PutMocksMockIDServerResponsesServerResponseIDBodyServerResponse]) -> None:
        self.server_response = server_response

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDServerResponsesServerResponseIDBody':
        assert isinstance(obj, dict)
        server_response = from_union([PutMocksMockIDServerResponsesServerResponseIDBodyServerResponse.from_dict, from_none], obj.get("serverResponse"))
        return PutMocksMockIDServerResponsesServerResponseIDBody(server_response)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.server_response is not None:
            result["serverResponse"] = from_union([lambda x: to_class(PutMocksMockIDServerResponsesServerResponseIDBodyServerResponse, x), from_none], self.server_response)
        return result


class PutMocksMockIDServerResponsesServerResponseIDResponse400ErrorDetails:
    """Information about the error."""
    """Information about the missing parameter."""
    param: Optional[List[str]]

    def __init__(self, param: Optional[List[str]]) -> None:
        self.param = param

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDServerResponsesServerResponseIDResponse400ErrorDetails':
        assert isinstance(obj, dict)
        param = from_union([lambda x: from_list(from_str, x), from_none], obj.get("param"))
        return PutMocksMockIDServerResponsesServerResponseIDResponse400ErrorDetails(param)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.param is not None:
            result["param"] = from_union([lambda x: from_list(from_str, x), from_none], self.param)
        return result


class PutMocksMockIDServerResponsesServerResponseIDResponse400Error:
    """Information about the error."""
    details: Optional[PutMocksMockIDServerResponsesServerResponseIDResponse400ErrorDetails]
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, details: Optional[PutMocksMockIDServerResponsesServerResponseIDResponse400ErrorDetails], message: Optional[str], name: Optional[str]) -> None:
        self.details = details
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDServerResponsesServerResponseIDResponse400Error':
        assert isinstance(obj, dict)
        details = from_union([PutMocksMockIDServerResponsesServerResponseIDResponse400ErrorDetails.from_dict, from_none], obj.get("details"))
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutMocksMockIDServerResponsesServerResponseIDResponse400Error(details, message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.details is not None:
            result["details"] = from_union([lambda x: to_class(PutMocksMockIDServerResponsesServerResponseIDResponse400ErrorDetails, x), from_none], self.details)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutMocksMockIDServerResponsesServerResponseIDResponse400:
    error: Optional[PutMocksMockIDServerResponsesServerResponseIDResponse400Error]

    def __init__(self, error: Optional[PutMocksMockIDServerResponsesServerResponseIDResponse400Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDServerResponsesServerResponseIDResponse400':
        assert isinstance(obj, dict)
        error = from_union([PutMocksMockIDServerResponsesServerResponseIDResponse400Error.from_dict, from_none], obj.get("error"))
        return PutMocksMockIDServerResponsesServerResponseIDResponse400(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutMocksMockIDServerResponsesServerResponseIDResponse400Error, x), from_none], self.error)
        return result


class PutMocksMockIDServerResponsesServerResponseIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDServerResponsesServerResponseIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutMocksMockIDServerResponsesServerResponseIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutMocksMockIDServerResponsesServerResponseIDResponse401:
    error: Optional[PutMocksMockIDServerResponsesServerResponseIDResponse401Error]

    def __init__(self, error: Optional[PutMocksMockIDServerResponsesServerResponseIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDServerResponsesServerResponseIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([PutMocksMockIDServerResponsesServerResponseIDResponse401Error.from_dict, from_none], obj.get("error"))
        return PutMocksMockIDServerResponsesServerResponseIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutMocksMockIDServerResponsesServerResponseIDResponse401Error, x), from_none], self.error)
        return result


class PutMocksMockIDServerResponsesServerResponseIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDServerResponsesServerResponseIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PutMocksMockIDServerResponsesServerResponseIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PutMocksMockIDServerResponsesServerResponseIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDServerResponsesServerResponseIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutMocksMockIDServerResponsesServerResponseIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutMocksMockIDServerResponsesServerResponseIDResponse500:
    error: Optional[PutMocksMockIDServerResponsesServerResponseIDResponse500Error]

    def __init__(self, error: Optional[PutMocksMockIDServerResponsesServerResponseIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDServerResponsesServerResponseIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([PutMocksMockIDServerResponsesServerResponseIDResponse500Error.from_dict, from_none], obj.get("error"))
        return PutMocksMockIDServerResponsesServerResponseIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutMocksMockIDServerResponsesServerResponseIDResponse500Error, x), from_none], self.error)
        return result


class PutMocksMockIDServerResponsesServerResponseIDResponseItem:
    """Information about the server response."""
    """The date and time at which the server response was created."""
    created_at: Optional[str]
    """The user ID of the user who created the server response."""
    created_by: Optional[str]
    """The server response's ID."""
    id: Optional[str]
    """The server response's name."""
    name: Optional[str]
    """The server response's 5xx HTTP response code."""
    status_code: Optional[float]
    """The date and time at which the server response was last updated."""
    updated_at: Optional[str]
    """The user ID of the user who last updated the server response."""
    updated_by: Optional[str]

    def __init__(self, created_at: Optional[str], created_by: Optional[str], id: Optional[str], name: Optional[str], status_code: Optional[float], updated_at: Optional[str], updated_by: Optional[str]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.id = id
        self.name = name
        self.status_code = status_code
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'PutMocksMockIDServerResponsesServerResponseIDResponseItem':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_str, from_none], obj.get("createdBy"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        status_code = from_union([from_float, from_none], obj.get("statusCode"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_str, from_none], obj.get("updatedBy"))
        return PutMocksMockIDServerResponsesServerResponseIDResponseItem(created_at, created_by, id, name, status_code, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_str, from_none], self.created_by)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.status_code is not None:
            result["statusCode"] = from_union([to_float, from_none], self.status_code)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_str, from_none], self.updated_by)
        return result


class PutMonitorsMonitorIDBodyMonitorSchedule:
    """Information about the monitor's schedule."""
    cron: Any
    """The monitor's [timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)."""
    timezone: Optional[str]

    def __init__(self, cron: Any, timezone: Optional[str]) -> None:
        self.cron = cron
        self.timezone = timezone

    @staticmethod
    def from_dict(obj: Any) -> 'PutMonitorsMonitorIDBodyMonitorSchedule':
        assert isinstance(obj, dict)
        cron = obj.get("cron")
        timezone = from_union([from_str, from_none], obj.get("timezone"))
        return PutMonitorsMonitorIDBodyMonitorSchedule(cron, timezone)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.cron is not None:
            result["cron"] = self.cron
        if self.timezone is not None:
            result["timezone"] = from_union([from_str, from_none], self.timezone)
        return result


class PutMonitorsMonitorIDBodyMonitor:
    """The monitor's name."""
    name: Optional[str]
    """Information about the monitor's schedule."""
    schedule: Optional[PutMonitorsMonitorIDBodyMonitorSchedule]

    def __init__(self, name: Optional[str], schedule: Optional[PutMonitorsMonitorIDBodyMonitorSchedule]) -> None:
        self.name = name
        self.schedule = schedule

    @staticmethod
    def from_dict(obj: Any) -> 'PutMonitorsMonitorIDBodyMonitor':
        assert isinstance(obj, dict)
        name = from_union([from_str, from_none], obj.get("name"))
        schedule = from_union([PutMonitorsMonitorIDBodyMonitorSchedule.from_dict, from_none], obj.get("schedule"))
        return PutMonitorsMonitorIDBodyMonitor(name, schedule)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.schedule is not None:
            result["schedule"] = from_union([lambda x: to_class(PutMonitorsMonitorIDBodyMonitorSchedule, x), from_none], self.schedule)
        return result


class PutMonitorsMonitorIDBody:
    monitor: Optional[PutMonitorsMonitorIDBodyMonitor]

    def __init__(self, monitor: Optional[PutMonitorsMonitorIDBodyMonitor]) -> None:
        self.monitor = monitor

    @staticmethod
    def from_dict(obj: Any) -> 'PutMonitorsMonitorIDBody':
        assert isinstance(obj, dict)
        monitor = from_union([PutMonitorsMonitorIDBodyMonitor.from_dict, from_none], obj.get("monitor"))
        return PutMonitorsMonitorIDBody(monitor)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.monitor is not None:
            result["monitor"] = from_union([lambda x: to_class(PutMonitorsMonitorIDBodyMonitor, x), from_none], self.monitor)
        return result


class PutMonitorsMonitorIDResponseMonitor:
    """The monitor's ID."""
    id: Optional[str]
    """The monitor's name."""
    name: Optional[str]
    """The monitor's unique ID."""
    uid: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str], uid: Optional[str]) -> None:
        self.id = id
        self.name = name
        self.uid = uid

    @staticmethod
    def from_dict(obj: Any) -> 'PutMonitorsMonitorIDResponseMonitor':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        uid = from_union([from_str, from_none], obj.get("uid"))
        return PutMonitorsMonitorIDResponseMonitor(id, name, uid)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.uid is not None:
            result["uid"] = from_union([from_str, from_none], self.uid)
        return result


class PutMonitorsMonitorIDResponse:
    monitor: Optional[PutMonitorsMonitorIDResponseMonitor]

    def __init__(self, monitor: Optional[PutMonitorsMonitorIDResponseMonitor]) -> None:
        self.monitor = monitor

    @staticmethod
    def from_dict(obj: Any) -> 'PutMonitorsMonitorIDResponse':
        assert isinstance(obj, dict)
        monitor = from_union([PutMonitorsMonitorIDResponseMonitor.from_dict, from_none], obj.get("monitor"))
        return PutMonitorsMonitorIDResponse(monitor)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.monitor is not None:
            result["monitor"] = from_union([lambda x: to_class(PutMonitorsMonitorIDResponseMonitor, x), from_none], self.monitor)
        return result


class PutMonitorsMonitorIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutMonitorsMonitorIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutMonitorsMonitorIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutMonitorsMonitorIDResponse401:
    error: Optional[PutMonitorsMonitorIDResponse401Error]

    def __init__(self, error: Optional[PutMonitorsMonitorIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutMonitorsMonitorIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([PutMonitorsMonitorIDResponse401Error.from_dict, from_none], obj.get("error"))
        return PutMonitorsMonitorIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutMonitorsMonitorIDResponse401Error, x), from_none], self.error)
        return result


class PutMonitorsMonitorIDResponse404Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutMonitorsMonitorIDResponse404Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutMonitorsMonitorIDResponse404Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutMonitorsMonitorIDResponse404:
    error: Optional[PutMonitorsMonitorIDResponse404Error]

    def __init__(self, error: Optional[PutMonitorsMonitorIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutMonitorsMonitorIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([PutMonitorsMonitorIDResponse404Error.from_dict, from_none], obj.get("error"))
        return PutMonitorsMonitorIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutMonitorsMonitorIDResponse404Error, x), from_none], self.error)
        return result


class PutMonitorsMonitorIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PutMonitorsMonitorIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PutMonitorsMonitorIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PutMonitorsMonitorIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutMonitorsMonitorIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutMonitorsMonitorIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutMonitorsMonitorIDResponse500:
    error: Optional[PutMonitorsMonitorIDResponse500Error]

    def __init__(self, error: Optional[PutMonitorsMonitorIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutMonitorsMonitorIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([PutMonitorsMonitorIDResponse500Error.from_dict, from_none], obj.get("error"))
        return PutMonitorsMonitorIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutMonitorsMonitorIDResponse500Error, x), from_none], self.error)
        return result


class PutNetworkPrivateElementTypeElementIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateElementTypeElementIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutNetworkPrivateElementTypeElementIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutNetworkPrivateElementTypeElementIDResponse401:
    error: Optional[PutNetworkPrivateElementTypeElementIDResponse401Error]

    def __init__(self, error: Optional[PutNetworkPrivateElementTypeElementIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateElementTypeElementIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([PutNetworkPrivateElementTypeElementIDResponse401Error.from_dict, from_none], obj.get("error"))
        return PutNetworkPrivateElementTypeElementIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutNetworkPrivateElementTypeElementIDResponse401Error, x), from_none], self.error)
        return result


class PutNetworkPrivateElementTypeElementIDResponse403Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateElementTypeElementIDResponse403Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutNetworkPrivateElementTypeElementIDResponse403Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutNetworkPrivateElementTypeElementIDResponse403:
    error: Optional[PutNetworkPrivateElementTypeElementIDResponse403Error]

    def __init__(self, error: Optional[PutNetworkPrivateElementTypeElementIDResponse403Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateElementTypeElementIDResponse403':
        assert isinstance(obj, dict)
        error = from_union([PutNetworkPrivateElementTypeElementIDResponse403Error.from_dict, from_none], obj.get("error"))
        return PutNetworkPrivateElementTypeElementIDResponse403(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutNetworkPrivateElementTypeElementIDResponse403Error, x), from_none], self.error)
        return result


class PutNetworkPrivateElementTypeElementIDResponse404Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateElementTypeElementIDResponse404Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutNetworkPrivateElementTypeElementIDResponse404Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutNetworkPrivateElementTypeElementIDResponse404:
    error: Optional[PutNetworkPrivateElementTypeElementIDResponse404Error]

    def __init__(self, error: Optional[PutNetworkPrivateElementTypeElementIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateElementTypeElementIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([PutNetworkPrivateElementTypeElementIDResponse404Error.from_dict, from_none], obj.get("error"))
        return PutNetworkPrivateElementTypeElementIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutNetworkPrivateElementTypeElementIDResponse404Error, x), from_none], self.error)
        return result


class PutNetworkPrivateElementTypeElementIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateElementTypeElementIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PutNetworkPrivateElementTypeElementIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PutNetworkPrivateElementTypeElementIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateElementTypeElementIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutNetworkPrivateElementTypeElementIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutNetworkPrivateElementTypeElementIDResponse500:
    error: Optional[PutNetworkPrivateElementTypeElementIDResponse500Error]

    def __init__(self, error: Optional[PutNetworkPrivateElementTypeElementIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateElementTypeElementIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([PutNetworkPrivateElementTypeElementIDResponse500Error.from_dict, from_none], obj.get("error"))
        return PutNetworkPrivateElementTypeElementIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutNetworkPrivateElementTypeElementIDResponse500Error, x), from_none], self.error)
        return result


class PutNetworkPrivateNetworkEntityRequestRequestIDBodyResponse:
    """The response to the user's request."""
    """A message that details why the user's request was denied."""
    message: Optional[str]

    def __init__(self, message: Optional[str]) -> None:
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateNetworkEntityRequestRequestIDBodyResponse':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        return PutNetworkPrivateNetworkEntityRequestRequestIDBodyResponse(message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PutNetworkPrivateNetworkEntityRequestRequestIDBodyStatus(Enum):
    """The request's status."""
    APPROVED = "approved"
    DENIED = "denied"


class PutNetworkPrivateNetworkEntityRequestRequestIDBody:
    """The response to the user's request."""
    response: Optional[PutNetworkPrivateNetworkEntityRequestRequestIDBodyResponse]
    """The request's status."""
    status: PutNetworkPrivateNetworkEntityRequestRequestIDBodyStatus

    def __init__(self, response: Optional[PutNetworkPrivateNetworkEntityRequestRequestIDBodyResponse], status: PutNetworkPrivateNetworkEntityRequestRequestIDBodyStatus) -> None:
        self.response = response
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateNetworkEntityRequestRequestIDBody':
        assert isinstance(obj, dict)
        response = from_union([PutNetworkPrivateNetworkEntityRequestRequestIDBodyResponse.from_dict, from_none], obj.get("response"))
        status = PutNetworkPrivateNetworkEntityRequestRequestIDBodyStatus(obj.get("status"))
        return PutNetworkPrivateNetworkEntityRequestRequestIDBody(response, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.response is not None:
            result["response"] = from_union([lambda x: to_class(PutNetworkPrivateNetworkEntityRequestRequestIDBodyResponse, x), from_none], self.response)
        result["status"] = to_enum(PutNetworkPrivateNetworkEntityRequestRequestIDBodyStatus, self.status)
        return result


class PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemElement:
    """Information about the requested element."""
    """The date and time at which the element was approved and added to the Private API Network."""
    created_at: Optional[str]
    """The user ID of the user who requested to add the element to the Private API Network."""
    created_by: Optional[int]
    """The element's ID."""
    id: Optional[str]
    """The element's name."""
    name: Optional[str]
    """The element's short summary."""
    summary: Optional[str]
    """The element type."""
    type: Optional[EntityTypeEnum]

    def __init__(self, created_at: Optional[str], created_by: Optional[int], id: Optional[str], name: Optional[str], summary: Optional[str], type: Optional[EntityTypeEnum]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.id = id
        self.name = name
        self.summary = summary
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemElement':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_int, from_none], obj.get("createdBy"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        summary = from_union([from_str, from_none], obj.get("summary"))
        type = from_union([EntityTypeEnum, from_none], obj.get("type"))
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemElement(created_at, created_by, id, name, summary, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_int, from_none], self.created_by)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.summary is not None:
            result["summary"] = from_union([from_str, from_none], self.summary)
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(EntityTypeEnum, x), from_none], self.type)
        return result


class PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemResponse:
    """Information about the response to the element's request. This object only returns when
    the network manager denied a request with a message.
    """
    """The date and time at which the network manager denied the request."""
    created_at: Optional[str]
    """The network manager's user ID."""
    created_by: Optional[int]
    """The network manager's request response message."""
    message: Optional[str]

    def __init__(self, created_at: Optional[str], created_by: Optional[int], message: Optional[str]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemResponse':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_int, from_none], obj.get("createdBy"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemResponse(created_at, created_by, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_int, from_none], self.created_by)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItem:
    """The date and time at which the request was created."""
    created_at: Optional[str]
    """The ID of the user who created the request."""
    created_by: Optional[int]
    """Information about the requested element."""
    element: Optional[PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemElement]
    """The request's ID."""
    id: Optional[int]
    """The user's optional message included in the request."""
    message: Optional[str]
    """Information about the response to the element's request. This object only returns when
    the network manager denied a request with a message.
    """
    response: Optional[PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemResponse]
    """The request's status."""
    status: Optional[PutNetworkPrivateNetworkEntityRequestRequestIDBodyStatus]

    def __init__(self, created_at: Optional[str], created_by: Optional[int], element: Optional[PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemElement], id: Optional[int], message: Optional[str], response: Optional[PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemResponse], status: Optional[PutNetworkPrivateNetworkEntityRequestRequestIDBodyStatus]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.element = element
        self.id = id
        self.message = message
        self.response = response
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItem':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_int, from_none], obj.get("createdBy"))
        element = from_union([PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemElement.from_dict, from_none], obj.get("element"))
        id = from_union([from_int, from_none], obj.get("id"))
        message = from_union([from_str, from_none], obj.get("message"))
        response = from_union([PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemResponse.from_dict, from_none], obj.get("response"))
        status = from_union([PutNetworkPrivateNetworkEntityRequestRequestIDBodyStatus, from_none], obj.get("status"))
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItem(created_at, created_by, element, id, message, response, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_int, from_none], self.created_by)
        if self.element is not None:
            result["element"] = from_union([lambda x: to_class(PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemElement, x), from_none], self.element)
        if self.id is not None:
            result["id"] = from_union([from_int, from_none], self.id)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.response is not None:
            result["response"] = from_union([lambda x: to_class(PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItemResponse, x), from_none], self.response)
        if self.status is not None:
            result["status"] = from_union([lambda x: to_enum(PutNetworkPrivateNetworkEntityRequestRequestIDBodyStatus, x), from_none], self.status)
        return result


class PutNetworkPrivateNetworkEntityRequestRequestIDResponse:
    """Information about the Private API Network request."""
    request: Optional[List[PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItem]]

    def __init__(self, request: Optional[List[PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItem]]) -> None:
        self.request = request

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateNetworkEntityRequestRequestIDResponse':
        assert isinstance(obj, dict)
        request = from_union([lambda x: from_list(PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItem.from_dict, x), from_none], obj.get("request"))
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse(request)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.request is not None:
            result["request"] = from_union([lambda x: from_list(lambda x: to_class(PutNetworkPrivateNetworkEntityRequestRequestIDResponseRequestItem, x), x), from_none], self.request)
        return result


class Name(Enum):
    """The error name."""
    INVALID_PARAMS_ERROR = "invalidParamsError"
    REQUEST_ALREADY_RESPONDED = "requestAlreadyResponded"
    REQUEST_ENTITY_ALREADY_PUBLISHED = "requestEntityAlreadyPublished"
    REQUEST_NOT_FOUND = "RequestNotFound"


class PutNetworkPrivateNetworkEntityRequestRequestIDResponse400:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[Name]

    def __init__(self, message: Optional[str], name: Optional[Name]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateNetworkEntityRequestRequestIDResponse400':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([Name, from_none], obj.get("name"))
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse400(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([lambda x: to_enum(Name, x), from_none], self.name)
        return result


class PutNetworkPrivateNetworkEntityRequestRequestIDResponse401Error:
    """The error message."""
    message: Optional[str]
    """The error message."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateNetworkEntityRequestRequestIDResponse401Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse401Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutNetworkPrivateNetworkEntityRequestRequestIDResponse401:
    error: Optional[PutNetworkPrivateNetworkEntityRequestRequestIDResponse401Error]

    def __init__(self, error: Optional[PutNetworkPrivateNetworkEntityRequestRequestIDResponse401Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateNetworkEntityRequestRequestIDResponse401':
        assert isinstance(obj, dict)
        error = from_union([PutNetworkPrivateNetworkEntityRequestRequestIDResponse401Error.from_dict, from_none], obj.get("error"))
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse401(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutNetworkPrivateNetworkEntityRequestRequestIDResponse401Error, x), from_none], self.error)
        return result


class PutNetworkPrivateNetworkEntityRequestRequestIDResponse403Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateNetworkEntityRequestRequestIDResponse403Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse403Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutNetworkPrivateNetworkEntityRequestRequestIDResponse403:
    error: Optional[PutNetworkPrivateNetworkEntityRequestRequestIDResponse403Error]

    def __init__(self, error: Optional[PutNetworkPrivateNetworkEntityRequestRequestIDResponse403Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateNetworkEntityRequestRequestIDResponse403':
        assert isinstance(obj, dict)
        error = from_union([PutNetworkPrivateNetworkEntityRequestRequestIDResponse403Error.from_dict, from_none], obj.get("error"))
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse403(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutNetworkPrivateNetworkEntityRequestRequestIDResponse403Error, x), from_none], self.error)
        return result


class PutNetworkPrivateNetworkEntityRequestRequestIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateNetworkEntityRequestRequestIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PutNetworkPrivateNetworkEntityRequestRequestIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateNetworkEntityRequestRequestIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutNetworkPrivateNetworkEntityRequestRequestIDResponse500:
    error: Optional[PutNetworkPrivateNetworkEntityRequestRequestIDResponse500Error]

    def __init__(self, error: Optional[PutNetworkPrivateNetworkEntityRequestRequestIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutNetworkPrivateNetworkEntityRequestRequestIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([PutNetworkPrivateNetworkEntityRequestRequestIDResponse500Error.from_dict, from_none], obj.get("error"))
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutNetworkPrivateNetworkEntityRequestRequestIDResponse500Error, x), from_none], self.error)
        return result


class PutScimV2UsersUserIDBodyName:
    """Information about the user's name."""
    """The user's last name."""
    family_name: Optional[str]
    """The user's first name."""
    given_name: Optional[str]

    def __init__(self, family_name: Optional[str], given_name: Optional[str]) -> None:
        self.family_name = family_name
        self.given_name = given_name

    @staticmethod
    def from_dict(obj: Any) -> 'PutScimV2UsersUserIDBodyName':
        assert isinstance(obj, dict)
        family_name = from_union([from_str, from_none], obj.get("familyName"))
        given_name = from_union([from_str, from_none], obj.get("givenName"))
        return PutScimV2UsersUserIDBodyName(family_name, given_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.family_name is not None:
            result["familyName"] = from_union([from_str, from_none], self.family_name)
        if self.given_name is not None:
            result["givenName"] = from_union([from_str, from_none], self.given_name)
        return result


class PutScimV2UsersUserIDBody:
    """Information about the user's name."""
    name: Optional[PutScimV2UsersUserIDBodyName]
    """The SCIM schema resource URI."""
    schemas: Optional[List[str]]

    def __init__(self, name: Optional[PutScimV2UsersUserIDBodyName], schemas: Optional[List[str]]) -> None:
        self.name = name
        self.schemas = schemas

    @staticmethod
    def from_dict(obj: Any) -> 'PutScimV2UsersUserIDBody':
        assert isinstance(obj, dict)
        name = from_union([PutScimV2UsersUserIDBodyName.from_dict, from_none], obj.get("name"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        return PutScimV2UsersUserIDBody(name, schemas)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.name is not None:
            result["name"] = from_union([lambda x: to_class(PutScimV2UsersUserIDBodyName, x), from_none], self.name)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        return result


class PutScimV2UsersUserIDResponseMeta:
    """The response's non-standard meta information."""
    """The date and time at which the team member was created."""
    created: Optional[str]
    """The date and time at which the team member was last modified."""
    last_modified: Optional[str]
    """The resource type."""
    resource_type: Optional[str]

    def __init__(self, created: Optional[str], last_modified: Optional[str], resource_type: Optional[str]) -> None:
        self.created = created
        self.last_modified = last_modified
        self.resource_type = resource_type

    @staticmethod
    def from_dict(obj: Any) -> 'PutScimV2UsersUserIDResponseMeta':
        assert isinstance(obj, dict)
        created = from_union([from_str, from_none], obj.get("created"))
        last_modified = from_union([from_str, from_none], obj.get("lastModified"))
        resource_type = from_union([from_str, from_none], obj.get("resourceType"))
        return PutScimV2UsersUserIDResponseMeta(created, last_modified, resource_type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created is not None:
            result["created"] = from_union([from_str, from_none], self.created)
        if self.last_modified is not None:
            result["lastModified"] = from_union([from_str, from_none], self.last_modified)
        if self.resource_type is not None:
            result["resourceType"] = from_union([from_str, from_none], self.resource_type)
        return result


class PutScimV2UsersUserIDResponseName:
    """Information about the Postman team member."""
    """The team member's last name."""
    family_name: Optional[str]
    """The team member's first name."""
    given_name: Optional[str]

    def __init__(self, family_name: Optional[str], given_name: Optional[str]) -> None:
        self.family_name = family_name
        self.given_name = given_name

    @staticmethod
    def from_dict(obj: Any) -> 'PutScimV2UsersUserIDResponseName':
        assert isinstance(obj, dict)
        family_name = from_union([from_str, from_none], obj.get("familyName"))
        given_name = from_union([from_str, from_none], obj.get("givenName"))
        return PutScimV2UsersUserIDResponseName(family_name, given_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.family_name is not None:
            result["familyName"] = from_union([from_str, from_none], self.family_name)
        if self.given_name is not None:
            result["givenName"] = from_union([from_str, from_none], self.given_name)
        return result


class PutScimV2UsersUserIDResponse:
    """If true, the team member is active."""
    active: Optional[bool]
    """The team member's external ID."""
    external_id: Optional[str]
    """The team member's SCIM ID."""
    id: Optional[str]
    """The response's non-standard meta information."""
    meta: Optional[PutScimV2UsersUserIDResponseMeta]
    """Information about the Postman team member."""
    name: Optional[PutScimV2UsersUserIDResponseName]
    """A list of schema resource URIs."""
    schemas: Optional[List[str]]
    """The team member's SCIM username."""
    user_name: Optional[str]

    def __init__(self, active: Optional[bool], external_id: Optional[str], id: Optional[str], meta: Optional[PutScimV2UsersUserIDResponseMeta], name: Optional[PutScimV2UsersUserIDResponseName], schemas: Optional[List[str]], user_name: Optional[str]) -> None:
        self.active = active
        self.external_id = external_id
        self.id = id
        self.meta = meta
        self.name = name
        self.schemas = schemas
        self.user_name = user_name

    @staticmethod
    def from_dict(obj: Any) -> 'PutScimV2UsersUserIDResponse':
        assert isinstance(obj, dict)
        active = from_union([from_bool, from_none], obj.get("active"))
        external_id = from_union([from_str, from_none], obj.get("externalId"))
        id = from_union([from_str, from_none], obj.get("id"))
        meta = from_union([PutScimV2UsersUserIDResponseMeta.from_dict, from_none], obj.get("meta"))
        name = from_union([PutScimV2UsersUserIDResponseName.from_dict, from_none], obj.get("name"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        user_name = from_union([from_str, from_none], obj.get("userName"))
        return PutScimV2UsersUserIDResponse(active, external_id, id, meta, name, schemas, user_name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.active is not None:
            result["active"] = from_union([from_bool, from_none], self.active)
        if self.external_id is not None:
            result["externalId"] = from_union([from_str, from_none], self.external_id)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.meta is not None:
            result["meta"] = from_union([lambda x: to_class(PutScimV2UsersUserIDResponseMeta, x), from_none], self.meta)
        if self.name is not None:
            result["name"] = from_union([lambda x: to_class(PutScimV2UsersUserIDResponseName, x), from_none], self.name)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.user_name is not None:
            result["userName"] = from_union([from_str, from_none], self.user_name)
        return result


class PutScimV2UsersUserIDResponse400:
    """Information about the error."""
    detail: Optional[str]
    """A list of SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The SCIM type."""
    scim_type: Optional[str]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], scim_type: Optional[str], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.scim_type = scim_type
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PutScimV2UsersUserIDResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        scim_type = from_union([from_str, from_none], obj.get("scimType"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PutScimV2UsersUserIDResponse400(detail, schemas, scim_type, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.scim_type is not None:
            result["scimType"] = from_union([from_str, from_none], self.scim_type)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PutScimV2UsersUserIDResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PutScimV2UsersUserIDResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PutScimV2UsersUserIDResponse401(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PutScimV2UsersUserIDResponse403:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PutScimV2UsersUserIDResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PutScimV2UsersUserIDResponse403(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PutScimV2UsersUserIDResponse404:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PutScimV2UsersUserIDResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PutScimV2UsersUserIDResponse404(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PutScimV2UsersUserIDResponse429:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[float]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[float]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PutScimV2UsersUserIDResponse429':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_float, from_none], obj.get("status"))
        return PutScimV2UsersUserIDResponse429(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([to_float, from_none], self.status)
        return result


class PutScimV2UsersUserIDResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The SCIM schema resource URIs."""
    schemas: Optional[List[str]]
    """The HTTP status code."""
    status: Optional[str]

    def __init__(self, detail: Optional[str], schemas: Optional[List[str]], status: Optional[str]) -> None:
        self.detail = detail
        self.schemas = schemas
        self.status = status

    @staticmethod
    def from_dict(obj: Any) -> 'PutScimV2UsersUserIDResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        schemas = from_union([lambda x: from_list(from_str, x), from_none], obj.get("schemas"))
        status = from_union([from_str, from_none], obj.get("status"))
        return PutScimV2UsersUserIDResponse500(detail, schemas, status)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(from_str, x), from_none], self.schemas)
        if self.status is not None:
            result["status"] = from_union([from_str, from_none], self.status)
        return result


class PutWorkspacesWorkspaceIDBodyWorkspace:
    """The new workspace description."""
    description: Optional[str]
    """The workspace's new name."""
    name: Optional[str]
    """The new workspace visibility
    [type](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/managing-workspaces/#changing-workspace-visibility).
    This property does **not** support the following workspace visibility changes:
    - `private` to `public`
    - `public` to `private`
    - `private` to `personal`
    - `team` to `personal`
    - `public` to `personal` for a team user
    """
    type: Optional[WorkspaceVisibility]

    def __init__(self, description: Optional[str], name: Optional[str], type: Optional[WorkspaceVisibility]) -> None:
        self.description = description
        self.name = name
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDBodyWorkspace':
        assert isinstance(obj, dict)
        description = from_union([from_str, from_none], obj.get("description"))
        name = from_union([from_str, from_none], obj.get("name"))
        type = from_union([WorkspaceVisibility, from_none], obj.get("type"))
        return PutWorkspacesWorkspaceIDBodyWorkspace(description, name, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(WorkspaceVisibility, x), from_none], self.type)
        return result


class PutWorkspacesWorkspaceIDBody:
    workspace: Optional[PutWorkspacesWorkspaceIDBodyWorkspace]

    def __init__(self, workspace: Optional[PutWorkspacesWorkspaceIDBodyWorkspace]) -> None:
        self.workspace = workspace

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDBody':
        assert isinstance(obj, dict)
        workspace = from_union([PutWorkspacesWorkspaceIDBodyWorkspace.from_dict, from_none], obj.get("workspace"))
        return PutWorkspacesWorkspaceIDBody(workspace)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.workspace is not None:
            result["workspace"] = from_union([lambda x: to_class(PutWorkspacesWorkspaceIDBodyWorkspace, x), from_none], self.workspace)
        return result


class PutWorkspacesWorkspaceIDGlobalVariablesBody:
    """A list of the workspace's global variables."""
    values: Optional[List[GlobalVariable]]

    def __init__(self, values: Optional[List[GlobalVariable]]) -> None:
        self.values = values

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDGlobalVariablesBody':
        assert isinstance(obj, dict)
        values = from_union([lambda x: from_list(GlobalVariable.from_dict, x), from_none], obj.get("values"))
        return PutWorkspacesWorkspaceIDGlobalVariablesBody(values)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.values is not None:
            result["values"] = from_union([lambda x: from_list(lambda x: to_class(GlobalVariable, x), x), from_none], self.values)
        return result


class PutWorkspacesWorkspaceIDGlobalVariablesResponse:
    """Information about the workspace's updated global variables."""
    """A list of the workspace's global variables."""
    values: Optional[List[List[GlobalVariable]]]

    def __init__(self, values: Optional[List[List[GlobalVariable]]]) -> None:
        self.values = values

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDGlobalVariablesResponse':
        assert isinstance(obj, dict)
        values = from_union([lambda x: from_list(lambda x: from_list(GlobalVariable.from_dict, x), x), from_none], obj.get("values"))
        return PutWorkspacesWorkspaceIDGlobalVariablesResponse(values)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.values is not None:
            result["values"] = from_union([lambda x: from_list(lambda x: from_list(lambda x: to_class(GlobalVariable, x), x), x), from_none], self.values)
        return result


class PutWorkspacesWorkspaceIDGlobalVariablesResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The type of error."""
    title: Optional[str]
    """The generic description for the error's class."""
    type: Optional[str]

    def __init__(self, detail: Optional[str], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDGlobalVariablesResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutWorkspacesWorkspaceIDGlobalVariablesResponse500(detail, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutWorkspacesWorkspaceIDResponseWorkspace:
    """Information about the updated workspace."""
    """The workspace's ID."""
    id: Optional[str]
    """The workspace's name."""
    name: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str]) -> None:
        self.id = id
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDResponseWorkspace':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutWorkspacesWorkspaceIDResponseWorkspace(id, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutWorkspacesWorkspaceIDResponse:
    """Information about the updated workspace."""
    workspace: Optional[PutWorkspacesWorkspaceIDResponseWorkspace]

    def __init__(self, workspace: Optional[PutWorkspacesWorkspaceIDResponseWorkspace]) -> None:
        self.workspace = workspace

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDResponse':
        assert isinstance(obj, dict)
        workspace = from_union([PutWorkspacesWorkspaceIDResponseWorkspace.from_dict, from_none], obj.get("workspace"))
        return PutWorkspacesWorkspaceIDResponse(workspace)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.workspace is not None:
            result["workspace"] = from_union([lambda x: to_class(PutWorkspacesWorkspaceIDResponseWorkspace, x), from_none], self.workspace)
        return result


class PutWorkspacesWorkspaceIDResponse400:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDResponse400':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutWorkspacesWorkspaceIDResponse400(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutWorkspacesWorkspaceIDResponse403Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDResponse403Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutWorkspacesWorkspaceIDResponse403Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutWorkspacesWorkspaceIDResponse403:
    error: Optional[PutWorkspacesWorkspaceIDResponse403Error]

    def __init__(self, error: Optional[PutWorkspacesWorkspaceIDResponse403Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDResponse403':
        assert isinstance(obj, dict)
        error = from_union([PutWorkspacesWorkspaceIDResponse403Error.from_dict, from_none], obj.get("error"))
        return PutWorkspacesWorkspaceIDResponse403(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutWorkspacesWorkspaceIDResponse403Error, x), from_none], self.error)
        return result


class PutWorkspacesWorkspaceIDResponse404Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDResponse404Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutWorkspacesWorkspaceIDResponse404Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutWorkspacesWorkspaceIDResponse404:
    error: Optional[PutWorkspacesWorkspaceIDResponse404Error]

    def __init__(self, error: Optional[PutWorkspacesWorkspaceIDResponse404Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDResponse404':
        assert isinstance(obj, dict)
        error = from_union([PutWorkspacesWorkspaceIDResponse404Error.from_dict, from_none], obj.get("error"))
        return PutWorkspacesWorkspaceIDResponse404(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutWorkspacesWorkspaceIDResponse404Error, x), from_none], self.error)
        return result


class PutWorkspacesWorkspaceIDResponse429:
    """The error name."""
    error: Optional[str]
    """The error message."""
    message: Optional[str]

    def __init__(self, error: Optional[str], message: Optional[str]) -> None:
        self.error = error
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDResponse429':
        assert isinstance(obj, dict)
        error = from_union([from_str, from_none], obj.get("error"))
        message = from_union([from_str, from_none], obj.get("message"))
        return PutWorkspacesWorkspaceIDResponse429(error, message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([from_str, from_none], self.error)
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class PutWorkspacesWorkspaceIDResponse500Error:
    """The error message."""
    message: Optional[str]
    """The error name."""
    name: Optional[str]

    def __init__(self, message: Optional[str], name: Optional[str]) -> None:
        self.message = message
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDResponse500Error':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        name = from_union([from_str, from_none], obj.get("name"))
        return PutWorkspacesWorkspaceIDResponse500Error(message, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class PutWorkspacesWorkspaceIDResponse500:
    error: Optional[PutWorkspacesWorkspaceIDResponse500Error]

    def __init__(self, error: Optional[PutWorkspacesWorkspaceIDResponse500Error]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDResponse500':
        assert isinstance(obj, dict)
        error = from_union([PutWorkspacesWorkspaceIDResponse500Error.from_dict, from_none], obj.get("error"))
        return PutWorkspacesWorkspaceIDResponse500(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(PutWorkspacesWorkspaceIDResponse500Error, x), from_none], self.error)
        return result


class PutWorkspacesWorkspaceIDTagsBodyTagsItem:
    """Information about the tag."""
    """The tag's ID within a team or individual (non-team) user scope."""
    slug: str

    def __init__(self, slug: str) -> None:
        self.slug = slug

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDTagsBodyTagsItem':
        assert isinstance(obj, dict)
        slug = from_str(obj.get("slug"))
        return PutWorkspacesWorkspaceIDTagsBodyTagsItem(slug)

    def to_dict(self) -> dict:
        result: dict = {}
        result["slug"] = from_str(self.slug)
        return result


class PutWorkspacesWorkspaceIDTagsBody:
    """A list of the associated tags as slugs."""
    tags: List[PutWorkspacesWorkspaceIDTagsBodyTagsItem]

    def __init__(self, tags: List[PutWorkspacesWorkspaceIDTagsBodyTagsItem]) -> None:
        self.tags = tags

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDTagsBody':
        assert isinstance(obj, dict)
        tags = from_list(PutWorkspacesWorkspaceIDTagsBodyTagsItem.from_dict, obj.get("tags"))
        return PutWorkspacesWorkspaceIDTagsBody(tags)

    def to_dict(self) -> dict:
        result: dict = {}
        result["tags"] = from_list(lambda x: to_class(PutWorkspacesWorkspaceIDTagsBodyTagsItem, x), self.tags)
        return result


class PutWorkspacesWorkspaceIDTagsResponseTagsItem:
    """Information about the tag."""
    """The tag's ID within a team or individual (non-team) user scope."""
    slug: Optional[str]

    def __init__(self, slug: Optional[str]) -> None:
        self.slug = slug

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDTagsResponseTagsItem':
        assert isinstance(obj, dict)
        slug = from_union([from_str, from_none], obj.get("slug"))
        return PutWorkspacesWorkspaceIDTagsResponseTagsItem(slug)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.slug is not None:
            result["slug"] = from_union([from_str, from_none], self.slug)
        return result


class PutWorkspacesWorkspaceIDTagsResponse:
    """A list of associated tags."""
    tags: Optional[List[PutWorkspacesWorkspaceIDTagsResponseTagsItem]]

    def __init__(self, tags: Optional[List[PutWorkspacesWorkspaceIDTagsResponseTagsItem]]) -> None:
        self.tags = tags

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDTagsResponse':
        assert isinstance(obj, dict)
        tags = from_union([lambda x: from_list(PutWorkspacesWorkspaceIDTagsResponseTagsItem.from_dict, x), from_none], obj.get("tags"))
        return PutWorkspacesWorkspaceIDTagsResponse(tags)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.tags is not None:
            result["tags"] = from_union([lambda x: from_list(lambda x: to_class(PutWorkspacesWorkspaceIDTagsResponseTagsItem, x), x), from_none], self.tags)
        return result


class PutWorkspacesWorkspaceIDTagsResponse400:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDTagsResponse400':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutWorkspacesWorkspaceIDTagsResponse400(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutWorkspacesWorkspaceIDTagsResponse401:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDTagsResponse401':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutWorkspacesWorkspaceIDTagsResponse401(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutWorkspacesWorkspaceIDTagsResponse403:
    """Information about the error."""
    detail: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDTagsResponse403':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutWorkspacesWorkspaceIDTagsResponse403(detail, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutWorkspacesWorkspaceIDTagsResponse404:
    """Information about the error."""
    detail: Optional[str]
    """The URI reference that identifies the specific occurrence of the problem."""
    instance: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDTagsResponse404':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutWorkspacesWorkspaceIDTagsResponse404(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class PutWorkspacesWorkspaceIDTagsResponse500:
    """Information about the error."""
    detail: Optional[str]
    """The URI reference that identifies the specific occurrence of the problem."""
    instance: Optional[str]
    """The error's HTTP status code."""
    status: Optional[int]
    """A short summary of the problem."""
    title: Optional[str]
    """The URI reference ([RFC 3986](https://www.rfc-editor.org/rfc/rfc3986)) that identifies
    the type of problem.
    """
    type: Optional[str]

    def __init__(self, detail: Optional[str], instance: Optional[str], status: Optional[int], title: Optional[str], type: Optional[str]) -> None:
        self.detail = detail
        self.instance = instance
        self.status = status
        self.title = title
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'PutWorkspacesWorkspaceIDTagsResponse500':
        assert isinstance(obj, dict)
        detail = from_union([from_str, from_none], obj.get("detail"))
        instance = from_union([from_str, from_none], obj.get("instance"))
        status = from_union([from_int, from_none], obj.get("status"))
        title = from_union([from_str, from_none], obj.get("title"))
        type = from_union([from_str, from_none], obj.get("type"))
        return PutWorkspacesWorkspaceIDTagsResponse500(detail, instance, status, title, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.detail is not None:
            result["detail"] = from_union([from_str, from_none], self.detail)
        if self.instance is not None:
            result["instance"] = from_union([from_str, from_none], self.instance)
        if self.status is not None:
            result["status"] = from_union([from_int, from_none], self.status)
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.type is not None:
            result["type"] = from_union([from_str, from_none], self.type)
        return result


class APIBase:
    """The API's base data schema."""
    """The date and time at which the API was created."""
    created_at: Optional[str]
    """The Postman ID of the user that created the API."""
    created_by: Optional[float]
    """The API's description."""
    description: Optional[str]
    """The API's ID."""
    id: Optional[str]
    """The API's name."""
    name: Optional[str]
    """The API's short summary."""
    summary: Optional[str]
    """The date and time at which the API was updated."""
    updated_at: Optional[str]
    """The Postman ID of the user that updated the API."""
    updated_by: Optional[float]

    def __init__(self, created_at: Optional[str], created_by: Optional[float], description: Optional[str], id: Optional[str], name: Optional[str], summary: Optional[str], updated_at: Optional[str], updated_by: Optional[float]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.description = description
        self.id = id
        self.name = name
        self.summary = summary
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'APIBase':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_float, from_none], obj.get("createdBy"))
        description = from_union([from_str, from_none], obj.get("description"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        summary = from_union([from_str, from_none], obj.get("summary"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_float, from_none], obj.get("updatedBy"))
        return APIBase(created_at, created_by, description, id, name, summary, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([to_float, from_none], self.created_by)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.summary is not None:
            result["summary"] = from_union([from_str, from_none], self.summary)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([to_float, from_none], self.updated_by)
        return result


class APIDetailsCollectionsItem:
    """Information about the collection."""
    """The collection's ID."""
    id: Optional[str]

    def __init__(self, id: Optional[str]) -> None:
        self.id = id

    @staticmethod
    def from_dict(obj: Any) -> 'APIDetailsCollectionsItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        return APIDetailsCollectionsItem(id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        return result


class APIDetailsGitInfo:
    """Information about the API's Git repository integration."""
    """The API definition's collection repository folder location."""
    collection_folder: Optional[str]
    """The domain at which the Git repository is hosted."""
    domain: Optional[str]
    """The organization that owns the repository."""
    organization: Optional[str]
    """The repository's name."""
    repository: Optional[str]
    """The API definition's repository folder location. This returns an empty string if the
    connected repository uses a root file.
    """
    schema_folder: Optional[str]

    def __init__(self, collection_folder: Optional[str], domain: Optional[str], organization: Optional[str], repository: Optional[str], schema_folder: Optional[str]) -> None:
        self.collection_folder = collection_folder
        self.domain = domain
        self.organization = organization
        self.repository = repository
        self.schema_folder = schema_folder

    @staticmethod
    def from_dict(obj: Any) -> 'APIDetailsGitInfo':
        assert isinstance(obj, dict)
        collection_folder = from_union([from_str, from_none], obj.get("collectionFolder"))
        domain = from_union([from_none, from_str], obj.get("domain"))
        organization = from_union([from_str, from_none], obj.get("organization"))
        repository = from_union([from_str, from_none], obj.get("repository"))
        schema_folder = from_union([from_str, from_none], obj.get("schemaFolder"))
        return APIDetailsGitInfo(collection_folder, domain, organization, repository, schema_folder)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection_folder is not None:
            result["collectionFolder"] = from_union([from_str, from_none], self.collection_folder)
        if self.domain is not None:
            result["domain"] = from_union([from_none, from_str], self.domain)
        if self.organization is not None:
            result["organization"] = from_union([from_str, from_none], self.organization)
        if self.repository is not None:
            result["repository"] = from_union([from_str, from_none], self.repository)
        if self.schema_folder is not None:
            result["schemaFolder"] = from_union([from_str, from_none], self.schema_folder)
        return result


class APIDetailsSchemasItem:
    """Information about the schema."""
    """The schema's ID."""
    id: Optional[str]

    def __init__(self, id: Optional[str]) -> None:
        self.id = id

    @staticmethod
    def from_dict(obj: Any) -> 'APIDetailsSchemasItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        return APIDetailsSchemasItem(id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        return result


class APIDetailsVersionsItem:
    """Information about the version."""
    """The version's ID."""
    id: Optional[str]
    """The version's name."""
    name: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str]) -> None:
        self.id = id
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'APIDetailsVersionsItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        return APIDetailsVersionsItem(id, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class APIDetails:
    """Detailed information about the API."""
    """The API's collections."""
    collections: Optional[List[APIDetailsCollectionsItem]]
    """Information about the API's Git repository integration."""
    git_info: Optional[APIDetailsGitInfo]
    """The API's schemas."""
    schemas: Optional[List[APIDetailsSchemasItem]]
    """The API's versions."""
    versions: Optional[List[APIDetailsVersionsItem]]

    def __init__(self, collections: Optional[List[APIDetailsCollectionsItem]], git_info: Optional[APIDetailsGitInfo], schemas: Optional[List[APIDetailsSchemasItem]], versions: Optional[List[APIDetailsVersionsItem]]) -> None:
        self.collections = collections
        self.git_info = git_info
        self.schemas = schemas
        self.versions = versions

    @staticmethod
    def from_dict(obj: Any) -> 'APIDetails':
        assert isinstance(obj, dict)
        collections = from_union([lambda x: from_list(APIDetailsCollectionsItem.from_dict, x), from_none], obj.get("collections"))
        git_info = from_union([APIDetailsGitInfo.from_dict, from_none], obj.get("gitInfo"))
        schemas = from_union([lambda x: from_list(APIDetailsSchemasItem.from_dict, x), from_none], obj.get("schemas"))
        versions = from_union([lambda x: from_list(APIDetailsVersionsItem.from_dict, x), from_none], obj.get("versions"))
        return APIDetails(collections, git_info, schemas, versions)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collections is not None:
            result["collections"] = from_union([lambda x: from_list(lambda x: to_class(APIDetailsCollectionsItem, x), x), from_none], self.collections)
        if self.git_info is not None:
            result["gitInfo"] = from_union([lambda x: to_class(APIDetailsGitInfo, x), from_none], self.git_info)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(lambda x: to_class(APIDetailsSchemasItem, x), x), from_none], self.schemas)
        if self.versions is not None:
            result["versions"] = from_union([lambda x: from_list(lambda x: to_class(APIDetailsVersionsItem, x), x), from_none], self.versions)
        return result


class CreateAPIVersionGitLinkedCollectionsItem:
    """Information about the collection."""
    """Path to a collection in the Git repository."""
    file_path: Optional[str]

    def __init__(self, file_path: Optional[str]) -> None:
        self.file_path = file_path

    @staticmethod
    def from_dict(obj: Any) -> 'CreateAPIVersionGitLinkedCollectionsItem':
        assert isinstance(obj, dict)
        file_path = from_union([from_str, from_none], obj.get("filePath"))
        return CreateAPIVersionGitLinkedCollectionsItem(file_path)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.file_path is not None:
            result["filePath"] = from_union([from_str, from_none], self.file_path)
        return result


class CreateAPIVersionGitLinkedSchemasItem:
    """Information about the schema."""
    """The path to the root directory where schemas are stored in the Git repository."""
    directory_path: Optional[str]

    def __init__(self, directory_path: Optional[str]) -> None:
        self.directory_path = directory_path

    @staticmethod
    def from_dict(obj: Any) -> 'CreateAPIVersionGitLinkedSchemasItem':
        assert isinstance(obj, dict)
        directory_path = from_union([from_str, from_none], obj.get("directoryPath"))
        return CreateAPIVersionGitLinkedSchemasItem(directory_path)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.directory_path is not None:
            result["directoryPath"] = from_union([from_str, from_none], self.directory_path)
        return result


class CreateAPIVersionGitLinked:
    """Information about the API version."""
    """The branch ID."""
    branch: Optional[str]
    """A list of the version's collections."""
    collections: Optional[List[CreateAPIVersionGitLinkedCollectionsItem]]
    """The version's name."""
    name: Optional[str]
    """Information about the API version release. For example, changelog notes."""
    release_notes: Optional[str]
    """A list of the version's schemas."""
    schemas: Optional[List[CreateAPIVersionGitLinkedSchemasItem]]

    def __init__(self, branch: Optional[str], collections: Optional[List[CreateAPIVersionGitLinkedCollectionsItem]], name: Optional[str], release_notes: Optional[str], schemas: Optional[List[CreateAPIVersionGitLinkedSchemasItem]]) -> None:
        self.branch = branch
        self.collections = collections
        self.name = name
        self.release_notes = release_notes
        self.schemas = schemas

    @staticmethod
    def from_dict(obj: Any) -> 'CreateAPIVersionGitLinked':
        assert isinstance(obj, dict)
        branch = from_union([from_str, from_none], obj.get("branch"))
        collections = from_union([lambda x: from_list(CreateAPIVersionGitLinkedCollectionsItem.from_dict, x), from_none], obj.get("collections"))
        name = from_union([from_str, from_none], obj.get("name"))
        release_notes = from_union([from_str, from_none], obj.get("releaseNotes"))
        schemas = from_union([lambda x: from_list(CreateAPIVersionGitLinkedSchemasItem.from_dict, x), from_none], obj.get("schemas"))
        return CreateAPIVersionGitLinked(branch, collections, name, release_notes, schemas)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.branch is not None:
            result["branch"] = from_union([from_str, from_none], self.branch)
        if self.collections is not None:
            result["collections"] = from_union([lambda x: from_list(lambda x: to_class(CreateAPIVersionGitLinkedCollectionsItem, x), x), from_none], self.collections)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.release_notes is not None:
            result["releaseNotes"] = from_union([from_str, from_none], self.release_notes)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(lambda x: to_class(CreateAPIVersionGitLinkedSchemasItem, x), x), from_none], self.schemas)
        return result


class CreateAPIVersionNonGitLinkedCollectionsItem:
    """Information about the collection."""
    """The collection's ID."""
    id: Optional[str]

    def __init__(self, id: Optional[str]) -> None:
        self.id = id

    @staticmethod
    def from_dict(obj: Any) -> 'CreateAPIVersionNonGitLinkedCollectionsItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        return CreateAPIVersionNonGitLinkedCollectionsItem(id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        return result


class CreateAPIVersionNonGitLinkedSchemasItem:
    """Information about the schema."""
    """The schema's ID."""
    id: Optional[str]

    def __init__(self, id: Optional[str]) -> None:
        self.id = id

    @staticmethod
    def from_dict(obj: Any) -> 'CreateAPIVersionNonGitLinkedSchemasItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        return CreateAPIVersionNonGitLinkedSchemasItem(id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        return result


class CreateAPIVersionNonGitLinked:
    """Information about the API version."""
    """A list of the version's collections."""
    collections: Optional[List[CreateAPIVersionNonGitLinkedCollectionsItem]]
    """The version's name."""
    name: Optional[str]
    """Information about the API version release. For example, changelog notes."""
    release_notes: Optional[str]
    """A list of the version's schemas."""
    schemas: Optional[List[CreateAPIVersionNonGitLinkedSchemasItem]]

    def __init__(self, collections: Optional[List[CreateAPIVersionNonGitLinkedCollectionsItem]], name: Optional[str], release_notes: Optional[str], schemas: Optional[List[CreateAPIVersionNonGitLinkedSchemasItem]]) -> None:
        self.collections = collections
        self.name = name
        self.release_notes = release_notes
        self.schemas = schemas

    @staticmethod
    def from_dict(obj: Any) -> 'CreateAPIVersionNonGitLinked':
        assert isinstance(obj, dict)
        collections = from_union([lambda x: from_list(CreateAPIVersionNonGitLinkedCollectionsItem.from_dict, x), from_none], obj.get("collections"))
        name = from_union([from_str, from_none], obj.get("name"))
        release_notes = from_union([from_str, from_none], obj.get("releaseNotes"))
        schemas = from_union([lambda x: from_list(CreateAPIVersionNonGitLinkedSchemasItem.from_dict, x), from_none], obj.get("schemas"))
        return CreateAPIVersionNonGitLinked(collections, name, release_notes, schemas)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collections is not None:
            result["collections"] = from_union([lambda x: from_list(lambda x: to_class(CreateAPIVersionNonGitLinkedCollectionsItem, x), x), from_none], self.collections)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.release_notes is not None:
            result["releaseNotes"] = from_union([from_str, from_none], self.release_notes)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(lambda x: to_class(CreateAPIVersionNonGitLinkedSchemasItem, x), x), from_none], self.schemas)
        return result


class CreateAPISchemaFilesItemRoot:
    """Information about the schema's root file."""
    """If true, tag the file as the root file. The root tag is only allowed for protobuf
    specifications.
    """
    enabled: Optional[bool]

    def __init__(self, enabled: Optional[bool]) -> None:
        self.enabled = enabled

    @staticmethod
    def from_dict(obj: Any) -> 'CreateAPISchemaFilesItemRoot':
        assert isinstance(obj, dict)
        enabled = from_union([from_bool, from_none], obj.get("enabled"))
        return CreateAPISchemaFilesItemRoot(enabled)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.enabled is not None:
            result["enabled"] = from_union([from_bool, from_none], self.enabled)
        return result


class CreateAPISchemaFilesItem:
    """The serilalized content of the schema."""
    content: Optional[str]
    """The schema's file path."""
    path: Optional[str]
    """Information about the schema's root file."""
    root: Optional[CreateAPISchemaFilesItemRoot]

    def __init__(self, content: Optional[str], path: Optional[str], root: Optional[CreateAPISchemaFilesItemRoot]) -> None:
        self.content = content
        self.path = path
        self.root = root

    @staticmethod
    def from_dict(obj: Any) -> 'CreateAPISchemaFilesItem':
        assert isinstance(obj, dict)
        content = from_union([from_str, from_none], obj.get("content"))
        path = from_union([from_str, from_none], obj.get("path"))
        root = from_union([CreateAPISchemaFilesItemRoot.from_dict, from_none], obj.get("root"))
        return CreateAPISchemaFilesItem(content, path, root)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.content is not None:
            result["content"] = from_union([from_str, from_none], self.content)
        if self.path is not None:
            result["path"] = from_union([from_str, from_none], self.path)
        if self.root is not None:
            result["root"] = from_union([lambda x: to_class(CreateAPISchemaFilesItemRoot, x), from_none], self.root)
        return result


class CreateAPISchema:
    """Information about the API schema."""
    """The list of files that are part of the schema."""
    files: List[CreateAPISchemaFilesItem]
    """The schema's type."""
    type: PostApisAPIIDSchemasBodyType

    def __init__(self, files: List[CreateAPISchemaFilesItem], type: PostApisAPIIDSchemasBodyType) -> None:
        self.files = files
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'CreateAPISchema':
        assert isinstance(obj, dict)
        files = from_list(CreateAPISchemaFilesItem.from_dict, obj.get("files"))
        type = PostApisAPIIDSchemasBodyType(obj.get("type"))
        return CreateAPISchema(files, type)

    def to_dict(self) -> dict:
        result: dict = {}
        result["files"] = from_list(lambda x: to_class(CreateAPISchemaFilesItem, x), self.files)
        result["type"] = to_enum(PostApisAPIIDSchemasBodyType, self.type)
        return result


class CreatePanAPIAPI:
    """The API's ID."""
    id: str
    """The API's parent folder ID."""
    parent_folder_id: int

    def __init__(self, id: str, parent_folder_id: int) -> None:
        self.id = id
        self.parent_folder_id = parent_folder_id

    @staticmethod
    def from_dict(obj: Any) -> 'CreatePanAPIAPI':
        assert isinstance(obj, dict)
        id = from_str(obj.get("id"))
        parent_folder_id = from_int(obj.get("parentFolderId"))
        return CreatePanAPIAPI(id, parent_folder_id)

    def to_dict(self) -> dict:
        result: dict = {}
        result["id"] = from_str(self.id)
        result["parentFolderId"] = from_int(self.parent_folder_id)
        return result


class CreatePANAPI:
    api: Optional[CreatePanAPIAPI]

    def __init__(self, api: Optional[CreatePanAPIAPI]) -> None:
        self.api = api

    @staticmethod
    def from_dict(obj: Any) -> 'CreatePANAPI':
        assert isinstance(obj, dict)
        api = from_union([CreatePanAPIAPI.from_dict, from_none], obj.get("api"))
        return CreatePANAPI(api)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.api is not None:
            result["api"] = from_union([lambda x: to_class(CreatePanAPIAPI, x), from_none], self.api)
        return result


class CreatePanCollectionCollection:
    """A list of environments to add to the collection."""
    environments: Optional[List[str]]
    """The collection's ID."""
    id: str
    """The collection's parent folder ID."""
    parent_folder_id: int
    """The collection's summary."""
    summary: Optional[str]

    def __init__(self, environments: Optional[List[str]], id: str, parent_folder_id: int, summary: Optional[str]) -> None:
        self.environments = environments
        self.id = id
        self.parent_folder_id = parent_folder_id
        self.summary = summary

    @staticmethod
    def from_dict(obj: Any) -> 'CreatePanCollectionCollection':
        assert isinstance(obj, dict)
        environments = from_union([lambda x: from_list(from_str, x), from_none], obj.get("environments"))
        id = from_str(obj.get("id"))
        parent_folder_id = from_int(obj.get("parentFolderId"))
        summary = from_union([from_str, from_none], obj.get("summary"))
        return CreatePanCollectionCollection(environments, id, parent_folder_id, summary)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.environments is not None:
            result["environments"] = from_union([lambda x: from_list(from_str, x), from_none], self.environments)
        result["id"] = from_str(self.id)
        result["parentFolderId"] = from_int(self.parent_folder_id)
        if self.summary is not None:
            result["summary"] = from_union([from_str, from_none], self.summary)
        return result


class CreatePANCollection:
    collection: Optional[CreatePanCollectionCollection]

    def __init__(self, collection: Optional[CreatePanCollectionCollection]) -> None:
        self.collection = collection

    @staticmethod
    def from_dict(obj: Any) -> 'CreatePANCollection':
        assert isinstance(obj, dict)
        collection = from_union([CreatePanCollectionCollection.from_dict, from_none], obj.get("collection"))
        return CreatePANCollection(collection)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([lambda x: to_class(CreatePanCollectionCollection, x), from_none], self.collection)
        return result


class CreatePanFolderFolder:
    """The folder's description."""
    description: Optional[str]
    """The folder's name."""
    name: str
    """The folder's parent folder ID. This value defaults to `0`."""
    parent_folder_id: Optional[int]

    def __init__(self, description: Optional[str], name: str, parent_folder_id: Optional[int]) -> None:
        self.description = description
        self.name = name
        self.parent_folder_id = parent_folder_id

    @staticmethod
    def from_dict(obj: Any) -> 'CreatePanFolderFolder':
        assert isinstance(obj, dict)
        description = from_union([from_str, from_none], obj.get("description"))
        name = from_str(obj.get("name"))
        parent_folder_id = from_union([from_int, from_none], obj.get("parentFolderId"))
        return CreatePanFolderFolder(description, name, parent_folder_id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        result["name"] = from_str(self.name)
        if self.parent_folder_id is not None:
            result["parentFolderId"] = from_union([from_int, from_none], self.parent_folder_id)
        return result


class CreatePANFolder:
    folder: Optional[CreatePanFolderFolder]

    def __init__(self, folder: Optional[CreatePanFolderFolder]) -> None:
        self.folder = folder

    @staticmethod
    def from_dict(obj: Any) -> 'CreatePANFolder':
        assert isinstance(obj, dict)
        folder = from_union([CreatePanFolderFolder.from_dict, from_none], obj.get("folder"))
        return CreatePANFolder(folder)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.folder is not None:
            result["folder"] = from_union([lambda x: to_class(CreatePanFolderFolder, x), from_none], self.folder)
        return result


class CreatePanWorkspaceWorkspace:
    """The workspace's ID."""
    id: str
    """The workspace's parent folder ID."""
    parent_folder_id: int

    def __init__(self, id: str, parent_folder_id: int) -> None:
        self.id = id
        self.parent_folder_id = parent_folder_id

    @staticmethod
    def from_dict(obj: Any) -> 'CreatePanWorkspaceWorkspace':
        assert isinstance(obj, dict)
        id = from_str(obj.get("id"))
        parent_folder_id = from_int(obj.get("parentFolderId"))
        return CreatePanWorkspaceWorkspace(id, parent_folder_id)

    def to_dict(self) -> dict:
        result: dict = {}
        result["id"] = from_str(self.id)
        result["parentFolderId"] = from_int(self.parent_folder_id)
        return result


class CreatePANWorkspace:
    workspace: Optional[CreatePanWorkspaceWorkspace]

    def __init__(self, workspace: Optional[CreatePanWorkspaceWorkspace]) -> None:
        self.workspace = workspace

    @staticmethod
    def from_dict(obj: Any) -> 'CreatePANWorkspace':
        assert isinstance(obj, dict)
        workspace = from_union([CreatePanWorkspaceWorkspace.from_dict, from_none], obj.get("workspace"))
        return CreatePANWorkspace(workspace)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.workspace is not None:
            result["workspace"] = from_union([lambda x: to_class(CreatePanWorkspaceWorkspace, x), from_none], self.workspace)
        return result


class CreateUpdateAPI:
    """Information about the API."""
    """The API's description. This supports Markdown formatting."""
    description: Optional[str]
    """The API's name."""
    name: str
    """The API's short summary."""
    summary: Optional[str]

    def __init__(self, description: Optional[str], name: str, summary: Optional[str]) -> None:
        self.description = description
        self.name = name
        self.summary = summary

    @staticmethod
    def from_dict(obj: Any) -> 'CreateUpdateAPI':
        assert isinstance(obj, dict)
        description = from_union([from_str, from_none], obj.get("description"))
        name = from_str(obj.get("name"))
        summary = from_union([from_str, from_none], obj.get("summary"))
        return CreateUpdateAPI(description, name, summary)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        result["name"] = from_str(self.name)
        if self.summary is not None:
            result["summary"] = from_union([from_str, from_none], self.summary)
        return result


class GitInfo:
    """Information about the API's Git repository integration."""
    """The API definition's collection repository folder location."""
    collection_folder: Optional[str]
    """The domain at which the Git repository is hosted."""
    domain: Optional[str]
    """The organization that owns the repository."""
    organization: Optional[str]
    """The repository's name."""
    repository: Optional[str]
    """The API definition's repository folder location. This returns an empty string if the
    connected repository uses a root file.
    """
    schema_folder: Optional[str]

    def __init__(self, collection_folder: Optional[str], domain: Optional[str], organization: Optional[str], repository: Optional[str], schema_folder: Optional[str]) -> None:
        self.collection_folder = collection_folder
        self.domain = domain
        self.organization = organization
        self.repository = repository
        self.schema_folder = schema_folder

    @staticmethod
    def from_dict(obj: Any) -> 'GitInfo':
        assert isinstance(obj, dict)
        collection_folder = from_union([from_str, from_none], obj.get("collectionFolder"))
        domain = from_union([from_none, from_str], obj.get("domain"))
        organization = from_union([from_str, from_none], obj.get("organization"))
        repository = from_union([from_str, from_none], obj.get("repository"))
        schema_folder = from_union([from_str, from_none], obj.get("schemaFolder"))
        return GitInfo(collection_folder, domain, organization, repository, schema_folder)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection_folder is not None:
            result["collectionFolder"] = from_union([from_str, from_none], self.collection_folder)
        if self.domain is not None:
            result["domain"] = from_union([from_none, from_str], self.domain)
        if self.organization is not None:
            result["organization"] = from_union([from_str, from_none], self.organization)
        if self.repository is not None:
            result["repository"] = from_union([from_str, from_none], self.repository)
        if self.schema_folder is not None:
            result["schemaFolder"] = from_union([from_str, from_none], self.schema_folder)
        return result


class ImportExportFileType(Enum):
    """The `file` type value."""
    FILE = "file"


class ImportExportFile:
    """A file containing a valid user's export .zip file."""
    input: str
    """The `file` type value."""
    type: ImportExportFileType

    def __init__(self, input: str, type: ImportExportFileType) -> None:
        self.input = input
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'ImportExportFile':
        assert isinstance(obj, dict)
        input = from_str(obj.get("input"))
        type = ImportExportFileType(obj.get("type"))
        return ImportExportFile(input, type)

    def to_dict(self) -> dict:
        result: dict = {}
        result["input"] = from_str(self.input)
        result["type"] = to_enum(ImportExportFileType, self.type)
        return result


class JSONSchemaType(Enum):
    """The OpenAPI definition type."""
    JSON = "json"


class JSONSchema:
    input: Any
    options: Any
    """The OpenAPI definition type."""
    type: Optional[JSONSchemaType]

    def __init__(self, input: Any, options: Any, type: Optional[JSONSchemaType]) -> None:
        self.input = input
        self.options = options
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'JSONSchema':
        assert isinstance(obj, dict)
        input = obj.get("input")
        options = obj.get("options")
        type = from_union([JSONSchemaType, from_none], obj.get("type"))
        return JSONSchema(input, options, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.input is not None:
            result["input"] = self.input
        if self.options is not None:
            result["options"] = self.options
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(JSONSchemaType, x), from_none], self.type)
        return result


class JSONStringified:
    """The stringified OpenAPI definition."""
    input: Optional[str]
    options: Any
    """The OpenAPI definition type."""
    type: Optional[JSONSchemaType]

    def __init__(self, input: Optional[str], options: Any, type: Optional[JSONSchemaType]) -> None:
        self.input = input
        self.options = options
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'JSONStringified':
        assert isinstance(obj, dict)
        input = from_union([from_str, from_none], obj.get("input"))
        options = obj.get("options")
        type = from_union([JSONSchemaType, from_none], obj.get("type"))
        return JSONStringified(input, options, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.input is not None:
            result["input"] = from_union([from_str, from_none], self.input)
        if self.options is not None:
            result["options"] = self.options
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(JSONSchemaType, x), from_none], self.type)
        return result


class Meta:
    """The response's meta information for paginated results."""
    """The maximum number of records in the paginated response."""
    limit: Optional[float]
    """The Base64-encoded value that points to the next record in the results set."""
    next_cursor: Optional[str]
    """The number of records that match the defined criteria."""
    total: Optional[float]

    def __init__(self, limit: Optional[float], next_cursor: Optional[str], total: Optional[float]) -> None:
        self.limit = limit
        self.next_cursor = next_cursor
        self.total = total

    @staticmethod
    def from_dict(obj: Any) -> 'Meta':
        assert isinstance(obj, dict)
        limit = from_union([from_float, from_none], obj.get("limit"))
        next_cursor = from_union([from_str, from_none], obj.get("nextCursor"))
        total = from_union([from_float, from_none], obj.get("total"))
        return Meta(limit, next_cursor, total)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.limit is not None:
            result["limit"] = from_union([to_float, from_none], self.limit)
        if self.next_cursor is not None:
            result["nextCursor"] = from_union([from_str, from_none], self.next_cursor)
        if self.total is not None:
            result["total"] = from_union([to_float, from_none], self.total)
        return result


class SchemaFileBase:
    """Information about the schema file."""
    """The date and time at which the file was created."""
    created_at: Optional[str]
    """The user Id of the user that created the file."""
    created_by: Optional[str]
    """The schema file's ID."""
    id: Optional[str]
    """The schema file's name."""
    name: Optional[str]
    """The file system path to the schema file."""
    path: Optional[str]
    """The date and time at which the file was last updated."""
    updated_at: Optional[str]
    """The user ID of the user that last updated the file."""
    updated_by: Optional[str]

    def __init__(self, created_at: Optional[str], created_by: Optional[str], id: Optional[str], name: Optional[str], path: Optional[str], updated_at: Optional[str], updated_by: Optional[str]) -> None:
        self.created_at = created_at
        self.created_by = created_by
        self.id = id
        self.name = name
        self.path = path
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'SchemaFileBase':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_str, from_none], obj.get("createdBy"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        path = from_union([from_str, from_none], obj.get("path"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_str, from_none], obj.get("updatedBy"))
        return SchemaFileBase(created_at, created_by, id, name, path, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_str, from_none], self.created_by)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.path is not None:
            result["path"] = from_union([from_str, from_none], self.path)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_str, from_none], self.updated_by)
        return result


class SchemaFileContents:
    """Information about the schema file."""
    """The schema file's content."""
    content: Optional[str]
    """The date and time at which the file was created."""
    created_at: Optional[str]
    """The user Id of the user that created the file."""
    created_by: Optional[str]
    """The schema file's ID."""
    id: Optional[str]
    """The schema file's name."""
    name: Optional[str]
    """The file system path to the schema file."""
    path: Optional[str]
    """The date and time at which the file was last updated."""
    updated_at: Optional[str]
    """The user ID of the user that last updated the file."""
    updated_by: Optional[str]

    def __init__(self, content: Optional[str], created_at: Optional[str], created_by: Optional[str], id: Optional[str], name: Optional[str], path: Optional[str], updated_at: Optional[str], updated_by: Optional[str]) -> None:
        self.content = content
        self.created_at = created_at
        self.created_by = created_by
        self.id = id
        self.name = name
        self.path = path
        self.updated_at = updated_at
        self.updated_by = updated_by

    @staticmethod
    def from_dict(obj: Any) -> 'SchemaFileContents':
        assert isinstance(obj, dict)
        content = from_union([from_str, from_none], obj.get("content"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        created_by = from_union([from_str, from_none], obj.get("createdBy"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        path = from_union([from_str, from_none], obj.get("path"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        updated_by = from_union([from_str, from_none], obj.get("updatedBy"))
        return SchemaFileContents(content, created_at, created_by, id, name, path, updated_at, updated_by)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.content is not None:
            result["content"] = from_union([from_str, from_none], self.content)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.created_by is not None:
            result["createdBy"] = from_union([from_str, from_none], self.created_by)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.path is not None:
            result["path"] = from_union([from_str, from_none], self.path)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        if self.updated_by is not None:
            result["updatedBy"] = from_union([from_str, from_none], self.updated_by)
        return result


class TaskErrorError:
    """The task's error message."""
    message: Optional[str]

    def __init__(self, message: Optional[str]) -> None:
        self.message = message

    @staticmethod
    def from_dict(obj: Any) -> 'TaskErrorError':
        assert isinstance(obj, dict)
        message = from_union([from_str, from_none], obj.get("message"))
        return TaskErrorError(message)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class TaskError:
    """Information about the error that occurred during the task's processing."""
    error: Optional[TaskErrorError]

    def __init__(self, error: Optional[TaskErrorError]) -> None:
        self.error = error

    @staticmethod
    def from_dict(obj: Any) -> 'TaskError':
        assert isinstance(obj, dict)
        error = from_union([TaskErrorError.from_dict, from_none], obj.get("error"))
        return TaskError(error)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.error is not None:
            result["error"] = from_union([lambda x: to_class(TaskErrorError, x), from_none], self.error)
        return result


class TaskResourceResourcesItem:
    """The task's ID."""
    id: Optional[str]
    """The task's assigned resource URL."""
    url: Optional[str]

    def __init__(self, id: Optional[str], url: Optional[str]) -> None:
        self.id = id
        self.url = url

    @staticmethod
    def from_dict(obj: Any) -> 'TaskResourceResourcesItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        url = from_union([from_str, from_none], obj.get("url"))
        return TaskResourceResourcesItem(id, url)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.url is not None:
            result["url"] = from_union([from_str, from_none], self.url)
        return result


class TaskResource:
    """Information about the task's resources."""
    resources: Optional[List[TaskResourceResourcesItem]]

    def __init__(self, resources: Optional[List[TaskResourceResourcesItem]]) -> None:
        self.resources = resources

    @staticmethod
    def from_dict(obj: Any) -> 'TaskResource':
        assert isinstance(obj, dict)
        resources = from_union([lambda x: from_list(TaskResourceResourcesItem.from_dict, x), from_none], obj.get("resources"))
        return TaskResource(resources)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.resources is not None:
            result["resources"] = from_union([lambda x: from_list(lambda x: to_class(TaskResourceResourcesItem, x), x), from_none], self.resources)
        return result


class UpdatePanAPIAPI:
    """The API's new parent folder ID."""
    parent_folder_id: Optional[int]

    def __init__(self, parent_folder_id: Optional[int]) -> None:
        self.parent_folder_id = parent_folder_id

    @staticmethod
    def from_dict(obj: Any) -> 'UpdatePanAPIAPI':
        assert isinstance(obj, dict)
        parent_folder_id = from_union([from_int, from_none], obj.get("parentFolderId"))
        return UpdatePanAPIAPI(parent_folder_id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.parent_folder_id is not None:
            result["parentFolderId"] = from_union([from_int, from_none], self.parent_folder_id)
        return result


class UpdatePANAPI:
    api: Optional[UpdatePanAPIAPI]

    def __init__(self, api: Optional[UpdatePanAPIAPI]) -> None:
        self.api = api

    @staticmethod
    def from_dict(obj: Any) -> 'UpdatePANAPI':
        assert isinstance(obj, dict)
        api = from_union([UpdatePanAPIAPI.from_dict, from_none], obj.get("api"))
        return UpdatePANAPI(api)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.api is not None:
            result["api"] = from_union([lambda x: to_class(UpdatePanAPIAPI, x), from_none], self.api)
        return result


class UpdatePanCollectionCollectionEnvironments:
    """The collection's updated environments."""
    add: Optional[List[str]]
    remove: Optional[List[str]]

    def __init__(self, add: Optional[List[str]], remove: Optional[List[str]]) -> None:
        self.add = add
        self.remove = remove

    @staticmethod
    def from_dict(obj: Any) -> 'UpdatePanCollectionCollectionEnvironments':
        assert isinstance(obj, dict)
        add = from_union([lambda x: from_list(from_str, x), from_none], obj.get("$add"))
        remove = from_union([lambda x: from_list(from_str, x), from_none], obj.get("$remove"))
        return UpdatePanCollectionCollectionEnvironments(add, remove)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.add is not None:
            result["$add"] = from_union([lambda x: from_list(from_str, x), from_none], self.add)
        if self.remove is not None:
            result["$remove"] = from_union([lambda x: from_list(from_str, x), from_none], self.remove)
        return result


class UpdatePanCollectionCollection:
    """The collection's updated environments."""
    environments: Optional[UpdatePanCollectionCollectionEnvironments]
    """The collection's new parent folder ID."""
    parent_folder_id: Optional[int]
    """The collection's updated summary."""
    summary: Optional[str]

    def __init__(self, environments: Optional[UpdatePanCollectionCollectionEnvironments], parent_folder_id: Optional[int], summary: Optional[str]) -> None:
        self.environments = environments
        self.parent_folder_id = parent_folder_id
        self.summary = summary

    @staticmethod
    def from_dict(obj: Any) -> 'UpdatePanCollectionCollection':
        assert isinstance(obj, dict)
        environments = from_union([UpdatePanCollectionCollectionEnvironments.from_dict, from_none], obj.get("environments"))
        parent_folder_id = from_union([from_int, from_none], obj.get("parentFolderId"))
        summary = from_union([from_str, from_none], obj.get("summary"))
        return UpdatePanCollectionCollection(environments, parent_folder_id, summary)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.environments is not None:
            result["environments"] = from_union([lambda x: to_class(UpdatePanCollectionCollectionEnvironments, x), from_none], self.environments)
        if self.parent_folder_id is not None:
            result["parentFolderId"] = from_union([from_int, from_none], self.parent_folder_id)
        if self.summary is not None:
            result["summary"] = from_union([from_str, from_none], self.summary)
        return result


class UpdatePANCollection:
    collection: Optional[UpdatePanCollectionCollection]

    def __init__(self, collection: Optional[UpdatePanCollectionCollection]) -> None:
        self.collection = collection

    @staticmethod
    def from_dict(obj: Any) -> 'UpdatePANCollection':
        assert isinstance(obj, dict)
        collection = from_union([UpdatePanCollectionCollection.from_dict, from_none], obj.get("collection"))
        return UpdatePANCollection(collection)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collection is not None:
            result["collection"] = from_union([lambda x: to_class(UpdatePanCollectionCollection, x), from_none], self.collection)
        return result


class UpdatePanFolderFolder:
    """The folder's updated description."""
    description: Optional[str]
    """The folder's new name."""
    name: Optional[str]
    """The folder's new parent folder ID."""
    parent_folder_id: Optional[int]

    def __init__(self, description: Optional[str], name: Optional[str], parent_folder_id: Optional[int]) -> None:
        self.description = description
        self.name = name
        self.parent_folder_id = parent_folder_id

    @staticmethod
    def from_dict(obj: Any) -> 'UpdatePanFolderFolder':
        assert isinstance(obj, dict)
        description = from_union([from_str, from_none], obj.get("description"))
        name = from_union([from_str, from_none], obj.get("name"))
        parent_folder_id = from_union([from_int, from_none], obj.get("parentFolderId"))
        return UpdatePanFolderFolder(description, name, parent_folder_id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.parent_folder_id is not None:
            result["parentFolderId"] = from_union([from_int, from_none], self.parent_folder_id)
        return result


class UpdatePANFolder:
    folder: Optional[UpdatePanFolderFolder]

    def __init__(self, folder: Optional[UpdatePanFolderFolder]) -> None:
        self.folder = folder

    @staticmethod
    def from_dict(obj: Any) -> 'UpdatePANFolder':
        assert isinstance(obj, dict)
        folder = from_union([UpdatePanFolderFolder.from_dict, from_none], obj.get("folder"))
        return UpdatePANFolder(folder)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.folder is not None:
            result["folder"] = from_union([lambda x: to_class(UpdatePanFolderFolder, x), from_none], self.folder)
        return result


class UpdatePanWorkspaceWorkspace:
    """The workspace's new parent folder ID."""
    parent_folder_id: Optional[int]

    def __init__(self, parent_folder_id: Optional[int]) -> None:
        self.parent_folder_id = parent_folder_id

    @staticmethod
    def from_dict(obj: Any) -> 'UpdatePanWorkspaceWorkspace':
        assert isinstance(obj, dict)
        parent_folder_id = from_union([from_int, from_none], obj.get("parentFolderId"))
        return UpdatePanWorkspaceWorkspace(parent_folder_id)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.parent_folder_id is not None:
            result["parentFolderId"] = from_union([from_int, from_none], self.parent_folder_id)
        return result


class UpdatePANWorkspace:
    workspace: Optional[UpdatePanWorkspaceWorkspace]

    def __init__(self, workspace: Optional[UpdatePanWorkspaceWorkspace]) -> None:
        self.workspace = workspace

    @staticmethod
    def from_dict(obj: Any) -> 'UpdatePANWorkspace':
        assert isinstance(obj, dict)
        workspace = from_union([UpdatePanWorkspaceWorkspace.from_dict, from_none], obj.get("workspace"))
        return UpdatePANWorkspace(workspace)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.workspace is not None:
            result["workspace"] = from_union([lambda x: to_class(UpdatePanWorkspaceWorkspace, x), from_none], self.workspace)
        return result


class VersionBase:
    """Information about the API version."""
    """The date and time at which the version was created."""
    created_at: Optional[str]
    """The version's ID."""
    id: Optional[str]
    """The version's name."""
    name: Optional[str]
    """The version's release notes."""
    release_notes: Optional[str]
    """The date and time at which the version was last updated."""
    updated_at: Optional[str]

    def __init__(self, created_at: Optional[str], id: Optional[str], name: Optional[str], release_notes: Optional[str], updated_at: Optional[str]) -> None:
        self.created_at = created_at
        self.id = id
        self.name = name
        self.release_notes = release_notes
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'VersionBase':
        assert isinstance(obj, dict)
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        release_notes = from_union([from_str, from_none], obj.get("releaseNotes"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return VersionBase(created_at, id, name, release_notes, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.release_notes is not None:
            result["releaseNotes"] = from_union([from_str, from_none], self.release_notes)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


class VersionExtendedCollectionsItem:
    """Information about the collection."""
    """The collection's unique ID."""
    id: Optional[str]
    """The collection's name."""
    name: Optional[str]

    def __init__(self, id: Optional[str], name: Optional[str]) -> None:
        self.id = id
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'VersionExtendedCollectionsItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        return VersionExtendedCollectionsItem(id, name)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        return result


class VersionExtendedSchemasItem:
    """Information about the schema."""
    """The schema's unique ID."""
    id: Optional[str]
    """The type of schema."""
    type: Optional[PostApisAPIIDSchemasBodyType]

    def __init__(self, id: Optional[str], type: Optional[PostApisAPIIDSchemasBodyType]) -> None:
        self.id = id
        self.type = type

    @staticmethod
    def from_dict(obj: Any) -> 'VersionExtendedSchemasItem':
        assert isinstance(obj, dict)
        id = from_union([from_str, from_none], obj.get("id"))
        type = from_union([PostApisAPIIDSchemasBodyType, from_none], obj.get("type"))
        return VersionExtendedSchemasItem(id, type)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.type is not None:
            result["type"] = from_union([lambda x: to_enum(PostApisAPIIDSchemasBodyType, x), from_none], self.type)
        return result


class VersionExtended:
    """Detailed information about the API version."""
    """A list of the version's collections."""
    collections: Optional[List[VersionExtendedCollectionsItem]]
    """The date and time at which the version was created."""
    created_at: Optional[str]
    """The version's ID."""
    id: Optional[str]
    """The version's name."""
    name: Optional[str]
    """The version's release notes."""
    release_notes: Optional[str]
    """A list of the version's API schemas."""
    schemas: Optional[List[VersionExtendedSchemasItem]]
    """The date and time at which the version was last updated."""
    updated_at: Optional[str]

    def __init__(self, collections: Optional[List[VersionExtendedCollectionsItem]], created_at: Optional[str], id: Optional[str], name: Optional[str], release_notes: Optional[str], schemas: Optional[List[VersionExtendedSchemasItem]], updated_at: Optional[str]) -> None:
        self.collections = collections
        self.created_at = created_at
        self.id = id
        self.name = name
        self.release_notes = release_notes
        self.schemas = schemas
        self.updated_at = updated_at

    @staticmethod
    def from_dict(obj: Any) -> 'VersionExtended':
        assert isinstance(obj, dict)
        collections = from_union([lambda x: from_list(VersionExtendedCollectionsItem.from_dict, x), from_none], obj.get("collections"))
        created_at = from_union([from_str, from_none], obj.get("createdAt"))
        id = from_union([from_str, from_none], obj.get("id"))
        name = from_union([from_str, from_none], obj.get("name"))
        release_notes = from_union([from_str, from_none], obj.get("releaseNotes"))
        schemas = from_union([lambda x: from_list(VersionExtendedSchemasItem.from_dict, x), from_none], obj.get("schemas"))
        updated_at = from_union([from_str, from_none], obj.get("updatedAt"))
        return VersionExtended(collections, created_at, id, name, release_notes, schemas, updated_at)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.collections is not None:
            result["collections"] = from_union([lambda x: from_list(lambda x: to_class(VersionExtendedCollectionsItem, x), x), from_none], self.collections)
        if self.created_at is not None:
            result["createdAt"] = from_union([from_str, from_none], self.created_at)
        if self.id is not None:
            result["id"] = from_union([from_str, from_none], self.id)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.release_notes is not None:
            result["releaseNotes"] = from_union([from_str, from_none], self.release_notes)
        if self.schemas is not None:
            result["schemas"] = from_union([lambda x: from_list(lambda x: to_class(VersionExtendedSchemasItem, x), x), from_none], self.schemas)
        if self.updated_at is not None:
            result["updatedAt"] = from_union([from_str, from_none], self.updated_at)
        return result


def delete_apis_apiid_response401_from_dict(s: Any) -> DeleteApisAPIIDResponse401:
    return DeleteApisAPIIDResponse401.from_dict(s)


def delete_apis_apiid_response401_to_dict(x: DeleteApisAPIIDResponse401) -> Any:
    return to_class(DeleteApisAPIIDResponse401, x)


def delete_apis_apiid_response403_from_dict(s: Any) -> DeleteApisAPIIDResponse403:
    return DeleteApisAPIIDResponse403.from_dict(s)


def delete_apis_apiid_response403_to_dict(x: DeleteApisAPIIDResponse403) -> Any:
    return to_class(DeleteApisAPIIDResponse403, x)


def delete_apis_apiid_response404_from_dict(s: Any) -> DeleteApisAPIIDResponse404:
    return DeleteApisAPIIDResponse404.from_dict(s)


def delete_apis_apiid_response404_to_dict(x: DeleteApisAPIIDResponse404) -> Any:
    return to_class(DeleteApisAPIIDResponse404, x)


def delete_apis_apiid_response422_from_dict(s: Any) -> DeleteApisAPIIDResponse422:
    return DeleteApisAPIIDResponse422.from_dict(s)


def delete_apis_apiid_response422_to_dict(x: DeleteApisAPIIDResponse422) -> Any:
    return to_class(DeleteApisAPIIDResponse422, x)


def delete_apis_apiid_response500_from_dict(s: Any) -> DeleteApisAPIIDResponse500:
    return DeleteApisAPIIDResponse500.from_dict(s)


def delete_apis_apiid_response500_to_dict(x: DeleteApisAPIIDResponse500) -> Any:
    return to_class(DeleteApisAPIIDResponse500, x)


def delete_apis_apiid_schemas_schema_id_files_file_path_response400_from_dict(s: Any) -> DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse400:
    return DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse400.from_dict(s)


def delete_apis_apiid_schemas_schema_id_files_file_path_response400_to_dict(x: DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse400) -> Any:
    return to_class(DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse400, x)


def delete_apis_apiid_schemas_schema_id_files_file_path_response401_from_dict(s: Any) -> DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse401:
    return DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse401.from_dict(s)


def delete_apis_apiid_schemas_schema_id_files_file_path_response401_to_dict(x: DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse401) -> Any:
    return to_class(DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse401, x)


def delete_apis_apiid_schemas_schema_id_files_file_path_response403_from_dict(s: Any) -> DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse403:
    return DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse403.from_dict(s)


def delete_apis_apiid_schemas_schema_id_files_file_path_response403_to_dict(x: DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse403) -> Any:
    return to_class(DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse403, x)


def delete_apis_apiid_schemas_schema_id_files_file_path_response404_from_dict(s: Any) -> DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse404:
    return DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse404.from_dict(s)


def delete_apis_apiid_schemas_schema_id_files_file_path_response404_to_dict(x: DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse404) -> Any:
    return to_class(DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse404, x)


def delete_apis_apiid_schemas_schema_id_files_file_path_response422_from_dict(s: Any) -> DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse422:
    return DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse422.from_dict(s)


def delete_apis_apiid_schemas_schema_id_files_file_path_response422_to_dict(x: DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse422) -> Any:
    return to_class(DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse422, x)


def delete_apis_apiid_schemas_schema_id_files_file_path_response500_from_dict(s: Any) -> DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse500:
    return DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse500.from_dict(s)


def delete_apis_apiid_schemas_schema_id_files_file_path_response500_to_dict(x: DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse500) -> Any:
    return to_class(DeleteApisAPIIDSchemasSchemaIDFilesFilePathResponse500, x)


def delete_apis_apiid_versions_version_id_response400_from_dict(s: Any) -> DeleteApisAPIIDVersionsVersionIDResponse400:
    return DeleteApisAPIIDVersionsVersionIDResponse400.from_dict(s)


def delete_apis_apiid_versions_version_id_response400_to_dict(x: DeleteApisAPIIDVersionsVersionIDResponse400) -> Any:
    return to_class(DeleteApisAPIIDVersionsVersionIDResponse400, x)


def delete_apis_apiid_versions_version_id_response401_from_dict(s: Any) -> DeleteApisAPIIDVersionsVersionIDResponse401:
    return DeleteApisAPIIDVersionsVersionIDResponse401.from_dict(s)


def delete_apis_apiid_versions_version_id_response401_to_dict(x: DeleteApisAPIIDVersionsVersionIDResponse401) -> Any:
    return to_class(DeleteApisAPIIDVersionsVersionIDResponse401, x)


def delete_apis_apiid_versions_version_id_response403_from_dict(s: Any) -> DeleteApisAPIIDVersionsVersionIDResponse403:
    return DeleteApisAPIIDVersionsVersionIDResponse403.from_dict(s)


def delete_apis_apiid_versions_version_id_response403_to_dict(x: DeleteApisAPIIDVersionsVersionIDResponse403) -> Any:
    return to_class(DeleteApisAPIIDVersionsVersionIDResponse403, x)


def delete_apis_apiid_versions_version_id_response404_from_dict(s: Any) -> DeleteApisAPIIDVersionsVersionIDResponse404:
    return DeleteApisAPIIDVersionsVersionIDResponse404.from_dict(s)


def delete_apis_apiid_versions_version_id_response404_to_dict(x: DeleteApisAPIIDVersionsVersionIDResponse404) -> Any:
    return to_class(DeleteApisAPIIDVersionsVersionIDResponse404, x)


def delete_apis_apiid_versions_version_id_response500_from_dict(s: Any) -> DeleteApisAPIIDVersionsVersionIDResponse500:
    return DeleteApisAPIIDVersionsVersionIDResponse500.from_dict(s)


def delete_apis_apiid_versions_version_id_response500_to_dict(x: DeleteApisAPIIDVersionsVersionIDResponse500) -> Any:
    return to_class(DeleteApisAPIIDVersionsVersionIDResponse500, x)


def delete_collections_collection_id_folders_folder_id_response_from_dict(s: Any) -> DeleteCollectionsCollectionIDFoldersFolderIDResponse:
    return DeleteCollectionsCollectionIDFoldersFolderIDResponse.from_dict(s)


def delete_collections_collection_id_folders_folder_id_response_to_dict(x: DeleteCollectionsCollectionIDFoldersFolderIDResponse) -> Any:
    return to_class(DeleteCollectionsCollectionIDFoldersFolderIDResponse, x)


def delete_collections_collection_id_folders_folder_id_response401_from_dict(s: Any) -> DeleteCollectionsCollectionIDFoldersFolderIDResponse401:
    return DeleteCollectionsCollectionIDFoldersFolderIDResponse401.from_dict(s)


def delete_collections_collection_id_folders_folder_id_response401_to_dict(x: DeleteCollectionsCollectionIDFoldersFolderIDResponse401) -> Any:
    return to_class(DeleteCollectionsCollectionIDFoldersFolderIDResponse401, x)


def delete_collections_collection_id_folders_folder_id_response404_from_dict(s: Any) -> DeleteCollectionsCollectionIDFoldersFolderIDResponse404:
    return DeleteCollectionsCollectionIDFoldersFolderIDResponse404.from_dict(s)


def delete_collections_collection_id_folders_folder_id_response404_to_dict(x: DeleteCollectionsCollectionIDFoldersFolderIDResponse404) -> Any:
    return to_class(DeleteCollectionsCollectionIDFoldersFolderIDResponse404, x)


def delete_collections_collection_id_folders_folder_id_response500_from_dict(s: Any) -> DeleteCollectionsCollectionIDFoldersFolderIDResponse500:
    return DeleteCollectionsCollectionIDFoldersFolderIDResponse500.from_dict(s)


def delete_collections_collection_id_folders_folder_id_response500_to_dict(x: DeleteCollectionsCollectionIDFoldersFolderIDResponse500) -> Any:
    return to_class(DeleteCollectionsCollectionIDFoldersFolderIDResponse500, x)


def delete_collections_collection_id_requests_request_id_response_from_dict(s: Any) -> DeleteCollectionsCollectionIDRequestsRequestIDResponse:
    return DeleteCollectionsCollectionIDRequestsRequestIDResponse.from_dict(s)


def delete_collections_collection_id_requests_request_id_response_to_dict(x: DeleteCollectionsCollectionIDRequestsRequestIDResponse) -> Any:
    return to_class(DeleteCollectionsCollectionIDRequestsRequestIDResponse, x)


def delete_collections_collection_id_requests_request_id_response401_from_dict(s: Any) -> DeleteCollectionsCollectionIDRequestsRequestIDResponse401:
    return DeleteCollectionsCollectionIDRequestsRequestIDResponse401.from_dict(s)


def delete_collections_collection_id_requests_request_id_response401_to_dict(x: DeleteCollectionsCollectionIDRequestsRequestIDResponse401) -> Any:
    return to_class(DeleteCollectionsCollectionIDRequestsRequestIDResponse401, x)


def delete_collections_collection_id_requests_request_id_response404_from_dict(s: Any) -> DeleteCollectionsCollectionIDRequestsRequestIDResponse404:
    return DeleteCollectionsCollectionIDRequestsRequestIDResponse404.from_dict(s)


def delete_collections_collection_id_requests_request_id_response404_to_dict(x: DeleteCollectionsCollectionIDRequestsRequestIDResponse404) -> Any:
    return to_class(DeleteCollectionsCollectionIDRequestsRequestIDResponse404, x)


def delete_collections_collection_id_requests_request_id_response500_from_dict(s: Any) -> DeleteCollectionsCollectionIDRequestsRequestIDResponse500:
    return DeleteCollectionsCollectionIDRequestsRequestIDResponse500.from_dict(s)


def delete_collections_collection_id_requests_request_id_response500_to_dict(x: DeleteCollectionsCollectionIDRequestsRequestIDResponse500) -> Any:
    return to_class(DeleteCollectionsCollectionIDRequestsRequestIDResponse500, x)


def delete_collections_collection_id_response_from_dict(s: Any) -> DeleteCollectionsCollectionIDResponse:
    return DeleteCollectionsCollectionIDResponse.from_dict(s)


def delete_collections_collection_id_response_to_dict(x: DeleteCollectionsCollectionIDResponse) -> Any:
    return to_class(DeleteCollectionsCollectionIDResponse, x)


def delete_collections_collection_id_response401_from_dict(s: Any) -> DeleteCollectionsCollectionIDResponse401:
    return DeleteCollectionsCollectionIDResponse401.from_dict(s)


def delete_collections_collection_id_response401_to_dict(x: DeleteCollectionsCollectionIDResponse401) -> Any:
    return to_class(DeleteCollectionsCollectionIDResponse401, x)


def delete_collections_collection_id_response404_from_dict(s: Any) -> DeleteCollectionsCollectionIDResponse404:
    return DeleteCollectionsCollectionIDResponse404.from_dict(s)


def delete_collections_collection_id_response404_to_dict(x: DeleteCollectionsCollectionIDResponse404) -> Any:
    return to_class(DeleteCollectionsCollectionIDResponse404, x)


def delete_collections_collection_id_response429_from_dict(s: Any) -> DeleteCollectionsCollectionIDResponse429:
    return DeleteCollectionsCollectionIDResponse429.from_dict(s)


def delete_collections_collection_id_response429_to_dict(x: DeleteCollectionsCollectionIDResponse429) -> Any:
    return to_class(DeleteCollectionsCollectionIDResponse429, x)


def delete_collections_collection_id_response500_from_dict(s: Any) -> DeleteCollectionsCollectionIDResponse500:
    return DeleteCollectionsCollectionIDResponse500.from_dict(s)


def delete_collections_collection_id_response500_to_dict(x: DeleteCollectionsCollectionIDResponse500) -> Any:
    return to_class(DeleteCollectionsCollectionIDResponse500, x)


def delete_collections_collection_id_responses_response_id_response_from_dict(s: Any) -> DeleteCollectionsCollectionIDResponsesResponseIDResponse:
    return DeleteCollectionsCollectionIDResponsesResponseIDResponse.from_dict(s)


def delete_collections_collection_id_responses_response_id_response_to_dict(x: DeleteCollectionsCollectionIDResponsesResponseIDResponse) -> Any:
    return to_class(DeleteCollectionsCollectionIDResponsesResponseIDResponse, x)


def delete_collections_collection_id_responses_response_id_response401_from_dict(s: Any) -> DeleteCollectionsCollectionIDResponsesResponseIDResponse401:
    return DeleteCollectionsCollectionIDResponsesResponseIDResponse401.from_dict(s)


def delete_collections_collection_id_responses_response_id_response401_to_dict(x: DeleteCollectionsCollectionIDResponsesResponseIDResponse401) -> Any:
    return to_class(DeleteCollectionsCollectionIDResponsesResponseIDResponse401, x)


def delete_collections_collection_id_responses_response_id_response404_from_dict(s: Any) -> DeleteCollectionsCollectionIDResponsesResponseIDResponse404:
    return DeleteCollectionsCollectionIDResponsesResponseIDResponse404.from_dict(s)


def delete_collections_collection_id_responses_response_id_response404_to_dict(x: DeleteCollectionsCollectionIDResponsesResponseIDResponse404) -> Any:
    return to_class(DeleteCollectionsCollectionIDResponsesResponseIDResponse404, x)


def delete_collections_collection_id_responses_response_id_response500_from_dict(s: Any) -> DeleteCollectionsCollectionIDResponsesResponseIDResponse500:
    return DeleteCollectionsCollectionIDResponsesResponseIDResponse500.from_dict(s)


def delete_collections_collection_id_responses_response_id_response500_to_dict(x: DeleteCollectionsCollectionIDResponsesResponseIDResponse500) -> Any:
    return to_class(DeleteCollectionsCollectionIDResponsesResponseIDResponse500, x)


def delete_environments_environment_id_response_from_dict(s: Any) -> DeleteEnvironmentsEnvironmentIDResponse:
    return DeleteEnvironmentsEnvironmentIDResponse.from_dict(s)


def delete_environments_environment_id_response_to_dict(x: DeleteEnvironmentsEnvironmentIDResponse) -> Any:
    return to_class(DeleteEnvironmentsEnvironmentIDResponse, x)


def delete_environments_environment_id_response401_from_dict(s: Any) -> DeleteEnvironmentsEnvironmentIDResponse401:
    return DeleteEnvironmentsEnvironmentIDResponse401.from_dict(s)


def delete_environments_environment_id_response401_to_dict(x: DeleteEnvironmentsEnvironmentIDResponse401) -> Any:
    return to_class(DeleteEnvironmentsEnvironmentIDResponse401, x)


def delete_environments_environment_id_response404_from_dict(s: Any) -> DeleteEnvironmentsEnvironmentIDResponse404:
    return DeleteEnvironmentsEnvironmentIDResponse404.from_dict(s)


def delete_environments_environment_id_response404_to_dict(x: DeleteEnvironmentsEnvironmentIDResponse404) -> Any:
    return to_class(DeleteEnvironmentsEnvironmentIDResponse404, x)


def delete_environments_environment_id_response429_from_dict(s: Any) -> DeleteEnvironmentsEnvironmentIDResponse429:
    return DeleteEnvironmentsEnvironmentIDResponse429.from_dict(s)


def delete_environments_environment_id_response429_to_dict(x: DeleteEnvironmentsEnvironmentIDResponse429) -> Any:
    return to_class(DeleteEnvironmentsEnvironmentIDResponse429, x)


def delete_environments_environment_id_response500_from_dict(s: Any) -> DeleteEnvironmentsEnvironmentIDResponse500:
    return DeleteEnvironmentsEnvironmentIDResponse500.from_dict(s)


def delete_environments_environment_id_response500_to_dict(x: DeleteEnvironmentsEnvironmentIDResponse500) -> Any:
    return to_class(DeleteEnvironmentsEnvironmentIDResponse500, x)


def delete_mocks_mock_id_response_from_dict(s: Any) -> DeleteMocksMockIDResponse:
    return DeleteMocksMockIDResponse.from_dict(s)


def delete_mocks_mock_id_response_to_dict(x: DeleteMocksMockIDResponse) -> Any:
    return to_class(DeleteMocksMockIDResponse, x)


def delete_mocks_mock_id_response400_from_dict(s: Any) -> DeleteMocksMockIDResponse400:
    return DeleteMocksMockIDResponse400.from_dict(s)


def delete_mocks_mock_id_response400_to_dict(x: DeleteMocksMockIDResponse400) -> Any:
    return to_class(DeleteMocksMockIDResponse400, x)


def delete_mocks_mock_id_response401_from_dict(s: Any) -> DeleteMocksMockIDResponse401:
    return DeleteMocksMockIDResponse401.from_dict(s)


def delete_mocks_mock_id_response401_to_dict(x: DeleteMocksMockIDResponse401) -> Any:
    return to_class(DeleteMocksMockIDResponse401, x)


def delete_mocks_mock_id_response404_from_dict(s: Any) -> DeleteMocksMockIDResponse404:
    return DeleteMocksMockIDResponse404.from_dict(s)


def delete_mocks_mock_id_response404_to_dict(x: DeleteMocksMockIDResponse404) -> Any:
    return to_class(DeleteMocksMockIDResponse404, x)


def delete_mocks_mock_id_response429_from_dict(s: Any) -> DeleteMocksMockIDResponse429:
    return DeleteMocksMockIDResponse429.from_dict(s)


def delete_mocks_mock_id_response429_to_dict(x: DeleteMocksMockIDResponse429) -> Any:
    return to_class(DeleteMocksMockIDResponse429, x)


def delete_mocks_mock_id_response500_from_dict(s: Any) -> DeleteMocksMockIDResponse500:
    return DeleteMocksMockIDResponse500.from_dict(s)


def delete_mocks_mock_id_response500_to_dict(x: DeleteMocksMockIDResponse500) -> Any:
    return to_class(DeleteMocksMockIDResponse500, x)


def delete_mocks_mock_id_server_responses_server_response_id_response_from_dict(s: Any) -> DeleteMocksMockIDServerResponsesServerResponseIDResponse:
    return DeleteMocksMockIDServerResponsesServerResponseIDResponse.from_dict(s)


def delete_mocks_mock_id_server_responses_server_response_id_response_to_dict(x: DeleteMocksMockIDServerResponsesServerResponseIDResponse) -> Any:
    return to_class(DeleteMocksMockIDServerResponsesServerResponseIDResponse, x)


def delete_mocks_mock_id_server_responses_server_response_id_response400_from_dict(s: Any) -> DeleteMocksMockIDServerResponsesServerResponseIDResponse400:
    return DeleteMocksMockIDServerResponsesServerResponseIDResponse400.from_dict(s)


def delete_mocks_mock_id_server_responses_server_response_id_response400_to_dict(x: DeleteMocksMockIDServerResponsesServerResponseIDResponse400) -> Any:
    return to_class(DeleteMocksMockIDServerResponsesServerResponseIDResponse400, x)


def delete_mocks_mock_id_server_responses_server_response_id_response401_from_dict(s: Any) -> DeleteMocksMockIDServerResponsesServerResponseIDResponse401:
    return DeleteMocksMockIDServerResponsesServerResponseIDResponse401.from_dict(s)


def delete_mocks_mock_id_server_responses_server_response_id_response401_to_dict(x: DeleteMocksMockIDServerResponsesServerResponseIDResponse401) -> Any:
    return to_class(DeleteMocksMockIDServerResponsesServerResponseIDResponse401, x)


def delete_mocks_mock_id_server_responses_server_response_id_response404_from_dict(s: Any) -> DeleteMocksMockIDServerResponsesServerResponseIDResponse404:
    return DeleteMocksMockIDServerResponsesServerResponseIDResponse404.from_dict(s)


def delete_mocks_mock_id_server_responses_server_response_id_response404_to_dict(x: DeleteMocksMockIDServerResponsesServerResponseIDResponse404) -> Any:
    return to_class(DeleteMocksMockIDServerResponsesServerResponseIDResponse404, x)


def delete_mocks_mock_id_server_responses_server_response_id_response429_from_dict(s: Any) -> DeleteMocksMockIDServerResponsesServerResponseIDResponse429:
    return DeleteMocksMockIDServerResponsesServerResponseIDResponse429.from_dict(s)


def delete_mocks_mock_id_server_responses_server_response_id_response429_to_dict(x: DeleteMocksMockIDServerResponsesServerResponseIDResponse429) -> Any:
    return to_class(DeleteMocksMockIDServerResponsesServerResponseIDResponse429, x)


def delete_mocks_mock_id_server_responses_server_response_id_response500_from_dict(s: Any) -> DeleteMocksMockIDServerResponsesServerResponseIDResponse500:
    return DeleteMocksMockIDServerResponsesServerResponseIDResponse500.from_dict(s)


def delete_mocks_mock_id_server_responses_server_response_id_response500_to_dict(x: DeleteMocksMockIDServerResponsesServerResponseIDResponse500) -> Any:
    return to_class(DeleteMocksMockIDServerResponsesServerResponseIDResponse500, x)


def delete_mocks_mock_id_unpublish_response_from_dict(s: Any) -> DeleteMocksMockIDUnpublishResponse:
    return DeleteMocksMockIDUnpublishResponse.from_dict(s)


def delete_mocks_mock_id_unpublish_response_to_dict(x: DeleteMocksMockIDUnpublishResponse) -> Any:
    return to_class(DeleteMocksMockIDUnpublishResponse, x)


def delete_mocks_mock_id_unpublish_response400_from_dict(s: Any) -> DeleteMocksMockIDUnpublishResponse400:
    return DeleteMocksMockIDUnpublishResponse400.from_dict(s)


def delete_mocks_mock_id_unpublish_response400_to_dict(x: DeleteMocksMockIDUnpublishResponse400) -> Any:
    return to_class(DeleteMocksMockIDUnpublishResponse400, x)


def delete_mocks_mock_id_unpublish_response401_from_dict(s: Any) -> DeleteMocksMockIDUnpublishResponse401:
    return DeleteMocksMockIDUnpublishResponse401.from_dict(s)


def delete_mocks_mock_id_unpublish_response401_to_dict(x: DeleteMocksMockIDUnpublishResponse401) -> Any:
    return to_class(DeleteMocksMockIDUnpublishResponse401, x)


def delete_mocks_mock_id_unpublish_response404_from_dict(s: Any) -> DeleteMocksMockIDUnpublishResponse404:
    return DeleteMocksMockIDUnpublishResponse404.from_dict(s)


def delete_mocks_mock_id_unpublish_response404_to_dict(x: DeleteMocksMockIDUnpublishResponse404) -> Any:
    return to_class(DeleteMocksMockIDUnpublishResponse404, x)


def delete_mocks_mock_id_unpublish_response429_from_dict(s: Any) -> DeleteMocksMockIDUnpublishResponse429:
    return DeleteMocksMockIDUnpublishResponse429.from_dict(s)


def delete_mocks_mock_id_unpublish_response429_to_dict(x: DeleteMocksMockIDUnpublishResponse429) -> Any:
    return to_class(DeleteMocksMockIDUnpublishResponse429, x)


def delete_mocks_mock_id_unpublish_response500_from_dict(s: Any) -> DeleteMocksMockIDUnpublishResponse500:
    return DeleteMocksMockIDUnpublishResponse500.from_dict(s)


def delete_mocks_mock_id_unpublish_response500_to_dict(x: DeleteMocksMockIDUnpublishResponse500) -> Any:
    return to_class(DeleteMocksMockIDUnpublishResponse500, x)


def delete_monitors_monitor_id_response_from_dict(s: Any) -> DeleteMonitorsMonitorIDResponse:
    return DeleteMonitorsMonitorIDResponse.from_dict(s)


def delete_monitors_monitor_id_response_to_dict(x: DeleteMonitorsMonitorIDResponse) -> Any:
    return to_class(DeleteMonitorsMonitorIDResponse, x)


def delete_monitors_monitor_id_response400_from_dict(s: Any) -> DeleteMonitorsMonitorIDResponse400:
    return DeleteMonitorsMonitorIDResponse400.from_dict(s)


def delete_monitors_monitor_id_response400_to_dict(x: DeleteMonitorsMonitorIDResponse400) -> Any:
    return to_class(DeleteMonitorsMonitorIDResponse400, x)


def delete_monitors_monitor_id_response401_from_dict(s: Any) -> DeleteMonitorsMonitorIDResponse401:
    return DeleteMonitorsMonitorIDResponse401.from_dict(s)


def delete_monitors_monitor_id_response401_to_dict(x: DeleteMonitorsMonitorIDResponse401) -> Any:
    return to_class(DeleteMonitorsMonitorIDResponse401, x)


def delete_monitors_monitor_id_response429_from_dict(s: Any) -> DeleteMonitorsMonitorIDResponse429:
    return DeleteMonitorsMonitorIDResponse429.from_dict(s)


def delete_monitors_monitor_id_response429_to_dict(x: DeleteMonitorsMonitorIDResponse429) -> Any:
    return to_class(DeleteMonitorsMonitorIDResponse429, x)


def delete_monitors_monitor_id_response500_from_dict(s: Any) -> DeleteMonitorsMonitorIDResponse500:
    return DeleteMonitorsMonitorIDResponse500.from_dict(s)


def delete_monitors_monitor_id_response500_to_dict(x: DeleteMonitorsMonitorIDResponse500) -> Any:
    return to_class(DeleteMonitorsMonitorIDResponse500, x)


def delete_network_private_element_type_element_id_response_from_dict(s: Any) -> DeleteNetworkPrivateElementTypeElementIDResponse:
    return DeleteNetworkPrivateElementTypeElementIDResponse.from_dict(s)


def delete_network_private_element_type_element_id_response_to_dict(x: DeleteNetworkPrivateElementTypeElementIDResponse) -> Any:
    return to_class(DeleteNetworkPrivateElementTypeElementIDResponse, x)


def delete_network_private_element_type_element_id_response400_from_dict(s: Any) -> DeleteNetworkPrivateElementTypeElementIDResponse400:
    return DeleteNetworkPrivateElementTypeElementIDResponse400.from_dict(s)


def delete_network_private_element_type_element_id_response400_to_dict(x: DeleteNetworkPrivateElementTypeElementIDResponse400) -> Any:
    return to_class(DeleteNetworkPrivateElementTypeElementIDResponse400, x)


def delete_network_private_element_type_element_id_response401_from_dict(s: Any) -> DeleteNetworkPrivateElementTypeElementIDResponse401:
    return DeleteNetworkPrivateElementTypeElementIDResponse401.from_dict(s)


def delete_network_private_element_type_element_id_response401_to_dict(x: DeleteNetworkPrivateElementTypeElementIDResponse401) -> Any:
    return to_class(DeleteNetworkPrivateElementTypeElementIDResponse401, x)


def delete_network_private_element_type_element_id_response403_from_dict(s: Any) -> DeleteNetworkPrivateElementTypeElementIDResponse403:
    return DeleteNetworkPrivateElementTypeElementIDResponse403.from_dict(s)


def delete_network_private_element_type_element_id_response403_to_dict(x: DeleteNetworkPrivateElementTypeElementIDResponse403) -> Any:
    return to_class(DeleteNetworkPrivateElementTypeElementIDResponse403, x)


def delete_network_private_element_type_element_id_response404_from_dict(s: Any) -> DeleteNetworkPrivateElementTypeElementIDResponse404:
    return DeleteNetworkPrivateElementTypeElementIDResponse404.from_dict(s)


def delete_network_private_element_type_element_id_response404_to_dict(x: DeleteNetworkPrivateElementTypeElementIDResponse404) -> Any:
    return to_class(DeleteNetworkPrivateElementTypeElementIDResponse404, x)


def delete_network_private_element_type_element_id_response429_from_dict(s: Any) -> DeleteNetworkPrivateElementTypeElementIDResponse429:
    return DeleteNetworkPrivateElementTypeElementIDResponse429.from_dict(s)


def delete_network_private_element_type_element_id_response429_to_dict(x: DeleteNetworkPrivateElementTypeElementIDResponse429) -> Any:
    return to_class(DeleteNetworkPrivateElementTypeElementIDResponse429, x)


def delete_network_private_element_type_element_id_response500_from_dict(s: Any) -> DeleteNetworkPrivateElementTypeElementIDResponse500:
    return DeleteNetworkPrivateElementTypeElementIDResponse500.from_dict(s)


def delete_network_private_element_type_element_id_response500_to_dict(x: DeleteNetworkPrivateElementTypeElementIDResponse500) -> Any:
    return to_class(DeleteNetworkPrivateElementTypeElementIDResponse500, x)


def delete_scim_v2_groups_group_id_response400_from_dict(s: Any) -> DeleteScimV2GroupsGroupIDResponse400:
    return DeleteScimV2GroupsGroupIDResponse400.from_dict(s)


def delete_scim_v2_groups_group_id_response400_to_dict(x: DeleteScimV2GroupsGroupIDResponse400) -> Any:
    return to_class(DeleteScimV2GroupsGroupIDResponse400, x)


def delete_scim_v2_groups_group_id_response401_from_dict(s: Any) -> DeleteScimV2GroupsGroupIDResponse401:
    return DeleteScimV2GroupsGroupIDResponse401.from_dict(s)


def delete_scim_v2_groups_group_id_response401_to_dict(x: DeleteScimV2GroupsGroupIDResponse401) -> Any:
    return to_class(DeleteScimV2GroupsGroupIDResponse401, x)


def delete_scim_v2_groups_group_id_response403_from_dict(s: Any) -> DeleteScimV2GroupsGroupIDResponse403:
    return DeleteScimV2GroupsGroupIDResponse403.from_dict(s)


def delete_scim_v2_groups_group_id_response403_to_dict(x: DeleteScimV2GroupsGroupIDResponse403) -> Any:
    return to_class(DeleteScimV2GroupsGroupIDResponse403, x)


def delete_scim_v2_groups_group_id_response404_from_dict(s: Any) -> DeleteScimV2GroupsGroupIDResponse404:
    return DeleteScimV2GroupsGroupIDResponse404.from_dict(s)


def delete_scim_v2_groups_group_id_response404_to_dict(x: DeleteScimV2GroupsGroupIDResponse404) -> Any:
    return to_class(DeleteScimV2GroupsGroupIDResponse404, x)


def delete_scim_v2_groups_group_id_response429_from_dict(s: Any) -> DeleteScimV2GroupsGroupIDResponse429:
    return DeleteScimV2GroupsGroupIDResponse429.from_dict(s)


def delete_scim_v2_groups_group_id_response429_to_dict(x: DeleteScimV2GroupsGroupIDResponse429) -> Any:
    return to_class(DeleteScimV2GroupsGroupIDResponse429, x)


def delete_scim_v2_groups_group_id_response500_from_dict(s: Any) -> DeleteScimV2GroupsGroupIDResponse500:
    return DeleteScimV2GroupsGroupIDResponse500.from_dict(s)


def delete_scim_v2_groups_group_id_response500_to_dict(x: DeleteScimV2GroupsGroupIDResponse500) -> Any:
    return to_class(DeleteScimV2GroupsGroupIDResponse500, x)


def delete_workspaces_workspace_id_response_from_dict(s: Any) -> DeleteWorkspacesWorkspaceIDResponse:
    return DeleteWorkspacesWorkspaceIDResponse.from_dict(s)


def delete_workspaces_workspace_id_response_to_dict(x: DeleteWorkspacesWorkspaceIDResponse) -> Any:
    return to_class(DeleteWorkspacesWorkspaceIDResponse, x)


def delete_workspaces_workspace_id_response400_from_dict(s: Any) -> DeleteWorkspacesWorkspaceIDResponse400:
    return DeleteWorkspacesWorkspaceIDResponse400.from_dict(s)


def delete_workspaces_workspace_id_response400_to_dict(x: DeleteWorkspacesWorkspaceIDResponse400) -> Any:
    return to_class(DeleteWorkspacesWorkspaceIDResponse400, x)


def delete_workspaces_workspace_id_response401_from_dict(s: Any) -> DeleteWorkspacesWorkspaceIDResponse401:
    return DeleteWorkspacesWorkspaceIDResponse401.from_dict(s)


def delete_workspaces_workspace_id_response401_to_dict(x: DeleteWorkspacesWorkspaceIDResponse401) -> Any:
    return to_class(DeleteWorkspacesWorkspaceIDResponse401, x)


def delete_workspaces_workspace_id_response429_from_dict(s: Any) -> DeleteWorkspacesWorkspaceIDResponse429:
    return DeleteWorkspacesWorkspaceIDResponse429.from_dict(s)


def delete_workspaces_workspace_id_response429_to_dict(x: DeleteWorkspacesWorkspaceIDResponse429) -> Any:
    return to_class(DeleteWorkspacesWorkspaceIDResponse429, x)


def delete_workspaces_workspace_id_response500_from_dict(s: Any) -> DeleteWorkspacesWorkspaceIDResponse500:
    return DeleteWorkspacesWorkspaceIDResponse500.from_dict(s)


def delete_workspaces_workspace_id_response500_to_dict(x: DeleteWorkspacesWorkspaceIDResponse500) -> Any:
    return to_class(DeleteWorkspacesWorkspaceIDResponse500, x)


def get_apis_apiid_collections_collection_id_response_from_dict(s: Any) -> GetApisAPIIDCollectionsCollectionIDResponse:
    return GetApisAPIIDCollectionsCollectionIDResponse.from_dict(s)


def get_apis_apiid_collections_collection_id_response_to_dict(x: GetApisAPIIDCollectionsCollectionIDResponse) -> Any:
    return to_class(GetApisAPIIDCollectionsCollectionIDResponse, x)


def get_apis_apiid_collections_collection_id_response400_from_dict(s: Any) -> GetApisAPIIDCollectionsCollectionIDResponse400:
    return GetApisAPIIDCollectionsCollectionIDResponse400.from_dict(s)


def get_apis_apiid_collections_collection_id_response400_to_dict(x: GetApisAPIIDCollectionsCollectionIDResponse400) -> Any:
    return to_class(GetApisAPIIDCollectionsCollectionIDResponse400, x)


def get_apis_apiid_collections_collection_id_response401_from_dict(s: Any) -> GetApisAPIIDCollectionsCollectionIDResponse401:
    return GetApisAPIIDCollectionsCollectionIDResponse401.from_dict(s)


def get_apis_apiid_collections_collection_id_response401_to_dict(x: GetApisAPIIDCollectionsCollectionIDResponse401) -> Any:
    return to_class(GetApisAPIIDCollectionsCollectionIDResponse401, x)


def get_apis_apiid_collections_collection_id_response403_from_dict(s: Any) -> GetApisAPIIDCollectionsCollectionIDResponse403:
    return GetApisAPIIDCollectionsCollectionIDResponse403.from_dict(s)


def get_apis_apiid_collections_collection_id_response403_to_dict(x: GetApisAPIIDCollectionsCollectionIDResponse403) -> Any:
    return to_class(GetApisAPIIDCollectionsCollectionIDResponse403, x)


def get_apis_apiid_collections_collection_id_response404_from_dict(s: Any) -> GetApisAPIIDCollectionsCollectionIDResponse404:
    return GetApisAPIIDCollectionsCollectionIDResponse404.from_dict(s)


def get_apis_apiid_collections_collection_id_response404_to_dict(x: GetApisAPIIDCollectionsCollectionIDResponse404) -> Any:
    return to_class(GetApisAPIIDCollectionsCollectionIDResponse404, x)


def get_apis_apiid_collections_collection_id_response500_from_dict(s: Any) -> GetApisAPIIDCollectionsCollectionIDResponse500:
    return GetApisAPIIDCollectionsCollectionIDResponse500.from_dict(s)


def get_apis_apiid_collections_collection_id_response500_to_dict(x: GetApisAPIIDCollectionsCollectionIDResponse500) -> Any:
    return to_class(GetApisAPIIDCollectionsCollectionIDResponse500, x)


def get_apis_apiid_response401_from_dict(s: Any) -> GetApisAPIIDResponse401:
    return GetApisAPIIDResponse401.from_dict(s)


def get_apis_apiid_response401_to_dict(x: GetApisAPIIDResponse401) -> Any:
    return to_class(GetApisAPIIDResponse401, x)


def get_apis_apiid_response404_from_dict(s: Any) -> GetApisAPIIDResponse404:
    return GetApisAPIIDResponse404.from_dict(s)


def get_apis_apiid_response404_to_dict(x: GetApisAPIIDResponse404) -> Any:
    return to_class(GetApisAPIIDResponse404, x)


def get_apis_apiid_response422_from_dict(s: Any) -> GetApisAPIIDResponse422:
    return GetApisAPIIDResponse422.from_dict(s)


def get_apis_apiid_response422_to_dict(x: GetApisAPIIDResponse422) -> Any:
    return to_class(GetApisAPIIDResponse422, x)


def get_apis_apiid_response500_from_dict(s: Any) -> GetApisAPIIDResponse500:
    return GetApisAPIIDResponse500.from_dict(s)


def get_apis_apiid_response500_to_dict(x: GetApisAPIIDResponse500) -> Any:
    return to_class(GetApisAPIIDResponse500, x)


def get_apis_apiid_schemas_schema_id_files_file_path_response_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDFilesFilePathResponse:
    return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse.from_dict(s)


def get_apis_apiid_schemas_schema_id_files_file_path_response_to_dict(x: GetApisAPIIDSchemasSchemaIDFilesFilePathResponse) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDFilesFilePathResponse, x)


def get_apis_apiid_schemas_schema_id_files_file_path_response400_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDFilesFilePathResponse400:
    return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse400.from_dict(s)


def get_apis_apiid_schemas_schema_id_files_file_path_response400_to_dict(x: GetApisAPIIDSchemasSchemaIDFilesFilePathResponse400) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDFilesFilePathResponse400, x)


def get_apis_apiid_schemas_schema_id_files_file_path_response401_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDFilesFilePathResponse401:
    return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse401.from_dict(s)


def get_apis_apiid_schemas_schema_id_files_file_path_response401_to_dict(x: GetApisAPIIDSchemasSchemaIDFilesFilePathResponse401) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDFilesFilePathResponse401, x)


def get_apis_apiid_schemas_schema_id_files_file_path_response404_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDFilesFilePathResponse404:
    return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse404.from_dict(s)


def get_apis_apiid_schemas_schema_id_files_file_path_response404_to_dict(x: GetApisAPIIDSchemasSchemaIDFilesFilePathResponse404) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDFilesFilePathResponse404, x)


def get_apis_apiid_schemas_schema_id_files_file_path_response422_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDFilesFilePathResponse422:
    return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse422.from_dict(s)


def get_apis_apiid_schemas_schema_id_files_file_path_response422_to_dict(x: GetApisAPIIDSchemasSchemaIDFilesFilePathResponse422) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDFilesFilePathResponse422, x)


def get_apis_apiid_schemas_schema_id_files_file_path_response500_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDFilesFilePathResponse500:
    return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse500.from_dict(s)


def get_apis_apiid_schemas_schema_id_files_file_path_response500_to_dict(x: GetApisAPIIDSchemasSchemaIDFilesFilePathResponse500) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDFilesFilePathResponse500, x)


def get_apis_apiid_schemas_schema_id_files_response_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDFilesResponse:
    return GetApisAPIIDSchemasSchemaIDFilesResponse.from_dict(s)


def get_apis_apiid_schemas_schema_id_files_response_to_dict(x: GetApisAPIIDSchemasSchemaIDFilesResponse) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDFilesResponse, x)


def get_apis_apiid_schemas_schema_id_files_response400_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDFilesResponse400:
    return GetApisAPIIDSchemasSchemaIDFilesResponse400.from_dict(s)


def get_apis_apiid_schemas_schema_id_files_response400_to_dict(x: GetApisAPIIDSchemasSchemaIDFilesResponse400) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDFilesResponse400, x)


def get_apis_apiid_schemas_schema_id_files_response401_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDFilesResponse401:
    return GetApisAPIIDSchemasSchemaIDFilesResponse401.from_dict(s)


def get_apis_apiid_schemas_schema_id_files_response401_to_dict(x: GetApisAPIIDSchemasSchemaIDFilesResponse401) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDFilesResponse401, x)


def get_apis_apiid_schemas_schema_id_files_response404_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDFilesResponse404:
    return GetApisAPIIDSchemasSchemaIDFilesResponse404.from_dict(s)


def get_apis_apiid_schemas_schema_id_files_response404_to_dict(x: GetApisAPIIDSchemasSchemaIDFilesResponse404) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDFilesResponse404, x)


def get_apis_apiid_schemas_schema_id_files_response422_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDFilesResponse422:
    return GetApisAPIIDSchemasSchemaIDFilesResponse422.from_dict(s)


def get_apis_apiid_schemas_schema_id_files_response422_to_dict(x: GetApisAPIIDSchemasSchemaIDFilesResponse422) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDFilesResponse422, x)


def get_apis_apiid_schemas_schema_id_files_response500_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDFilesResponse500:
    return GetApisAPIIDSchemasSchemaIDFilesResponse500.from_dict(s)


def get_apis_apiid_schemas_schema_id_files_response500_to_dict(x: GetApisAPIIDSchemasSchemaIDFilesResponse500) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDFilesResponse500, x)


def get_apis_apiid_schemas_schema_id_response400_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDResponse400:
    return GetApisAPIIDSchemasSchemaIDResponse400.from_dict(s)


def get_apis_apiid_schemas_schema_id_response400_to_dict(x: GetApisAPIIDSchemasSchemaIDResponse400) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDResponse400, x)


def get_apis_apiid_schemas_schema_id_response401_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDResponse401:
    return GetApisAPIIDSchemasSchemaIDResponse401.from_dict(s)


def get_apis_apiid_schemas_schema_id_response401_to_dict(x: GetApisAPIIDSchemasSchemaIDResponse401) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDResponse401, x)


def get_apis_apiid_schemas_schema_id_response403_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDResponse403:
    return GetApisAPIIDSchemasSchemaIDResponse403.from_dict(s)


def get_apis_apiid_schemas_schema_id_response403_to_dict(x: GetApisAPIIDSchemasSchemaIDResponse403) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDResponse403, x)


def get_apis_apiid_schemas_schema_id_response404_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDResponse404:
    return GetApisAPIIDSchemasSchemaIDResponse404.from_dict(s)


def get_apis_apiid_schemas_schema_id_response404_to_dict(x: GetApisAPIIDSchemasSchemaIDResponse404) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDResponse404, x)


def get_apis_apiid_schemas_schema_id_response422_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDResponse422:
    return GetApisAPIIDSchemasSchemaIDResponse422.from_dict(s)


def get_apis_apiid_schemas_schema_id_response422_to_dict(x: GetApisAPIIDSchemasSchemaIDResponse422) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDResponse422, x)


def get_apis_apiid_schemas_schema_id_response500_from_dict(s: Any) -> GetApisAPIIDSchemasSchemaIDResponse500:
    return GetApisAPIIDSchemasSchemaIDResponse500.from_dict(s)


def get_apis_apiid_schemas_schema_id_response500_to_dict(x: GetApisAPIIDSchemasSchemaIDResponse500) -> Any:
    return to_class(GetApisAPIIDSchemasSchemaIDResponse500, x)


def get_apis_apiid_tags_response_from_dict(s: Any) -> GetApisAPIIDTagsResponse:
    return GetApisAPIIDTagsResponse.from_dict(s)


def get_apis_apiid_tags_response_to_dict(x: GetApisAPIIDTagsResponse) -> Any:
    return to_class(GetApisAPIIDTagsResponse, x)


def get_apis_apiid_tags_response401_from_dict(s: Any) -> GetApisAPIIDTagsResponse401:
    return GetApisAPIIDTagsResponse401.from_dict(s)


def get_apis_apiid_tags_response401_to_dict(x: GetApisAPIIDTagsResponse401) -> Any:
    return to_class(GetApisAPIIDTagsResponse401, x)


def get_apis_apiid_tags_response403_from_dict(s: Any) -> GetApisAPIIDTagsResponse403:
    return GetApisAPIIDTagsResponse403.from_dict(s)


def get_apis_apiid_tags_response403_to_dict(x: GetApisAPIIDTagsResponse403) -> Any:
    return to_class(GetApisAPIIDTagsResponse403, x)


def get_apis_apiid_tags_response404_from_dict(s: Any) -> GetApisAPIIDTagsResponse404:
    return GetApisAPIIDTagsResponse404.from_dict(s)


def get_apis_apiid_tags_response404_to_dict(x: GetApisAPIIDTagsResponse404) -> Any:
    return to_class(GetApisAPIIDTagsResponse404, x)


def get_apis_apiid_tags_response500_from_dict(s: Any) -> GetApisAPIIDTagsResponse500:
    return GetApisAPIIDTagsResponse500.from_dict(s)


def get_apis_apiid_tags_response500_to_dict(x: GetApisAPIIDTagsResponse500) -> Any:
    return to_class(GetApisAPIIDTagsResponse500, x)


def get_apis_apiid_tasks_task_id_response_from_dict(s: Any) -> GetApisAPIIDTasksTaskIDResponse:
    return GetApisAPIIDTasksTaskIDResponse.from_dict(s)


def get_apis_apiid_tasks_task_id_response_to_dict(x: GetApisAPIIDTasksTaskIDResponse) -> Any:
    return to_class(GetApisAPIIDTasksTaskIDResponse, x)


def get_apis_apiid_tasks_task_id_response400_from_dict(s: Any) -> GetApisAPIIDTasksTaskIDResponse400:
    return GetApisAPIIDTasksTaskIDResponse400.from_dict(s)


def get_apis_apiid_tasks_task_id_response400_to_dict(x: GetApisAPIIDTasksTaskIDResponse400) -> Any:
    return to_class(GetApisAPIIDTasksTaskIDResponse400, x)


def get_apis_apiid_tasks_task_id_response401_from_dict(s: Any) -> GetApisAPIIDTasksTaskIDResponse401:
    return GetApisAPIIDTasksTaskIDResponse401.from_dict(s)


def get_apis_apiid_tasks_task_id_response401_to_dict(x: GetApisAPIIDTasksTaskIDResponse401) -> Any:
    return to_class(GetApisAPIIDTasksTaskIDResponse401, x)


def get_apis_apiid_tasks_task_id_response403_from_dict(s: Any) -> GetApisAPIIDTasksTaskIDResponse403:
    return GetApisAPIIDTasksTaskIDResponse403.from_dict(s)


def get_apis_apiid_tasks_task_id_response403_to_dict(x: GetApisAPIIDTasksTaskIDResponse403) -> Any:
    return to_class(GetApisAPIIDTasksTaskIDResponse403, x)


def get_apis_apiid_tasks_task_id_response404_from_dict(s: Any) -> GetApisAPIIDTasksTaskIDResponse404:
    return GetApisAPIIDTasksTaskIDResponse404.from_dict(s)


def get_apis_apiid_tasks_task_id_response404_to_dict(x: GetApisAPIIDTasksTaskIDResponse404) -> Any:
    return to_class(GetApisAPIIDTasksTaskIDResponse404, x)


def get_apis_apiid_versions_response_from_dict(s: Any) -> GetApisAPIIDVersionsResponse:
    return GetApisAPIIDVersionsResponse.from_dict(s)


def get_apis_apiid_versions_response_to_dict(x: GetApisAPIIDVersionsResponse) -> Any:
    return to_class(GetApisAPIIDVersionsResponse, x)


def get_apis_apiid_versions_response401_from_dict(s: Any) -> GetApisAPIIDVersionsResponse401:
    return GetApisAPIIDVersionsResponse401.from_dict(s)


def get_apis_apiid_versions_response401_to_dict(x: GetApisAPIIDVersionsResponse401) -> Any:
    return to_class(GetApisAPIIDVersionsResponse401, x)


def get_apis_apiid_versions_response404_from_dict(s: Any) -> GetApisAPIIDVersionsResponse404:
    return GetApisAPIIDVersionsResponse404.from_dict(s)


def get_apis_apiid_versions_response404_to_dict(x: GetApisAPIIDVersionsResponse404) -> Any:
    return to_class(GetApisAPIIDVersionsResponse404, x)


def get_apis_apiid_versions_response422_from_dict(s: Any) -> GetApisAPIIDVersionsResponse422:
    return GetApisAPIIDVersionsResponse422.from_dict(s)


def get_apis_apiid_versions_response422_to_dict(x: GetApisAPIIDVersionsResponse422) -> Any:
    return to_class(GetApisAPIIDVersionsResponse422, x)


def get_apis_apiid_versions_response500_from_dict(s: Any) -> GetApisAPIIDVersionsResponse500:
    return GetApisAPIIDVersionsResponse500.from_dict(s)


def get_apis_apiid_versions_response500_to_dict(x: GetApisAPIIDVersionsResponse500) -> Any:
    return to_class(GetApisAPIIDVersionsResponse500, x)


def get_apis_apiid_versions_version_id_response_from_dict(s: Any) -> GetApisAPIIDVersionsVersionIDResponse:
    return GetApisAPIIDVersionsVersionIDResponse.from_dict(s)


def get_apis_apiid_versions_version_id_response_to_dict(x: GetApisAPIIDVersionsVersionIDResponse) -> Any:
    return to_class(GetApisAPIIDVersionsVersionIDResponse, x)


def get_apis_apiid_versions_version_id_response401_from_dict(s: Any) -> GetApisAPIIDVersionsVersionIDResponse401:
    return GetApisAPIIDVersionsVersionIDResponse401.from_dict(s)


def get_apis_apiid_versions_version_id_response401_to_dict(x: GetApisAPIIDVersionsVersionIDResponse401) -> Any:
    return to_class(GetApisAPIIDVersionsVersionIDResponse401, x)


def get_apis_apiid_versions_version_id_response404_from_dict(s: Any) -> GetApisAPIIDVersionsVersionIDResponse404:
    return GetApisAPIIDVersionsVersionIDResponse404.from_dict(s)


def get_apis_apiid_versions_version_id_response404_to_dict(x: GetApisAPIIDVersionsVersionIDResponse404) -> Any:
    return to_class(GetApisAPIIDVersionsVersionIDResponse404, x)


def get_apis_apiid_versions_version_id_response500_from_dict(s: Any) -> GetApisAPIIDVersionsVersionIDResponse500:
    return GetApisAPIIDVersionsVersionIDResponse500.from_dict(s)


def get_apis_apiid_versions_version_id_response500_to_dict(x: GetApisAPIIDVersionsVersionIDResponse500) -> Any:
    return to_class(GetApisAPIIDVersionsVersionIDResponse500, x)


def get_apis_response_from_dict(s: Any) -> GetApisResponse:
    return GetApisResponse.from_dict(s)


def get_apis_response_to_dict(x: GetApisResponse) -> Any:
    return to_class(GetApisResponse, x)


def get_apis_response401_from_dict(s: Any) -> GetApisResponse401:
    return GetApisResponse401.from_dict(s)


def get_apis_response401_to_dict(x: GetApisResponse401) -> Any:
    return to_class(GetApisResponse401, x)


def get_apis_response404_from_dict(s: Any) -> GetApisResponse404:
    return GetApisResponse404.from_dict(s)


def get_apis_response404_to_dict(x: GetApisResponse404) -> Any:
    return to_class(GetApisResponse404, x)


def get_apis_response422_from_dict(s: Any) -> GetApisResponse422:
    return GetApisResponse422.from_dict(s)


def get_apis_response422_to_dict(x: GetApisResponse422) -> Any:
    return to_class(GetApisResponse422, x)


def get_apis_response500_from_dict(s: Any) -> GetApisResponse500:
    return GetApisResponse500.from_dict(s)


def get_apis_response500_to_dict(x: GetApisResponse500) -> Any:
    return to_class(GetApisResponse500, x)


def get_audit_logs_response_from_dict(s: Any) -> GetAuditLogsResponse:
    return GetAuditLogsResponse.from_dict(s)


def get_audit_logs_response_to_dict(x: GetAuditLogsResponse) -> Any:
    return to_class(GetAuditLogsResponse, x)


def get_audit_logs_response401_from_dict(s: Any) -> GetAuditLogsResponse401:
    return GetAuditLogsResponse401.from_dict(s)


def get_audit_logs_response401_to_dict(x: GetAuditLogsResponse401) -> Any:
    return to_class(GetAuditLogsResponse401, x)


def get_audit_logs_response429_from_dict(s: Any) -> GetAuditLogsResponse429:
    return GetAuditLogsResponse429.from_dict(s)


def get_audit_logs_response429_to_dict(x: GetAuditLogsResponse429) -> Any:
    return to_class(GetAuditLogsResponse429, x)


def get_audit_logs_response500_from_dict(s: Any) -> GetAuditLogsResponse500:
    return GetAuditLogsResponse500.from_dict(s)


def get_audit_logs_response500_to_dict(x: GetAuditLogsResponse500) -> Any:
    return to_class(GetAuditLogsResponse500, x)


def get_collections_collection_id_folders_folder_id_response_from_dict(s: Any) -> GetCollectionsCollectionIDFoldersFolderIDResponse:
    return GetCollectionsCollectionIDFoldersFolderIDResponse.from_dict(s)


def get_collections_collection_id_folders_folder_id_response_to_dict(x: GetCollectionsCollectionIDFoldersFolderIDResponse) -> Any:
    return to_class(GetCollectionsCollectionIDFoldersFolderIDResponse, x)


def get_collections_collection_id_folders_folder_id_response401_from_dict(s: Any) -> GetCollectionsCollectionIDFoldersFolderIDResponse401:
    return GetCollectionsCollectionIDFoldersFolderIDResponse401.from_dict(s)


def get_collections_collection_id_folders_folder_id_response401_to_dict(x: GetCollectionsCollectionIDFoldersFolderIDResponse401) -> Any:
    return to_class(GetCollectionsCollectionIDFoldersFolderIDResponse401, x)


def get_collections_collection_id_folders_folder_id_response404_from_dict(s: Any) -> GetCollectionsCollectionIDFoldersFolderIDResponse404:
    return GetCollectionsCollectionIDFoldersFolderIDResponse404.from_dict(s)


def get_collections_collection_id_folders_folder_id_response404_to_dict(x: GetCollectionsCollectionIDFoldersFolderIDResponse404) -> Any:
    return to_class(GetCollectionsCollectionIDFoldersFolderIDResponse404, x)


def get_collections_collection_id_folders_folder_id_response500_from_dict(s: Any) -> GetCollectionsCollectionIDFoldersFolderIDResponse500:
    return GetCollectionsCollectionIDFoldersFolderIDResponse500.from_dict(s)


def get_collections_collection_id_folders_folder_id_response500_to_dict(x: GetCollectionsCollectionIDFoldersFolderIDResponse500) -> Any:
    return to_class(GetCollectionsCollectionIDFoldersFolderIDResponse500, x)


def get_collections_collection_id_requests_request_id_response_from_dict(s: Any) -> GetCollectionsCollectionIDRequestsRequestIDResponse:
    return GetCollectionsCollectionIDRequestsRequestIDResponse.from_dict(s)


def get_collections_collection_id_requests_request_id_response_to_dict(x: GetCollectionsCollectionIDRequestsRequestIDResponse) -> Any:
    return to_class(GetCollectionsCollectionIDRequestsRequestIDResponse, x)


def get_collections_collection_id_requests_request_id_response401_from_dict(s: Any) -> GetCollectionsCollectionIDRequestsRequestIDResponse401:
    return GetCollectionsCollectionIDRequestsRequestIDResponse401.from_dict(s)


def get_collections_collection_id_requests_request_id_response401_to_dict(x: GetCollectionsCollectionIDRequestsRequestIDResponse401) -> Any:
    return to_class(GetCollectionsCollectionIDRequestsRequestIDResponse401, x)


def get_collections_collection_id_requests_request_id_response404_from_dict(s: Any) -> GetCollectionsCollectionIDRequestsRequestIDResponse404:
    return GetCollectionsCollectionIDRequestsRequestIDResponse404.from_dict(s)


def get_collections_collection_id_requests_request_id_response404_to_dict(x: GetCollectionsCollectionIDRequestsRequestIDResponse404) -> Any:
    return to_class(GetCollectionsCollectionIDRequestsRequestIDResponse404, x)


def get_collections_collection_id_requests_request_id_response500_from_dict(s: Any) -> GetCollectionsCollectionIDRequestsRequestIDResponse500:
    return GetCollectionsCollectionIDRequestsRequestIDResponse500.from_dict(s)


def get_collections_collection_id_requests_request_id_response500_to_dict(x: GetCollectionsCollectionIDRequestsRequestIDResponse500) -> Any:
    return to_class(GetCollectionsCollectionIDRequestsRequestIDResponse500, x)


def get_collections_collection_id_response_from_dict(s: Any) -> GetCollectionsCollectionIDResponse:
    return GetCollectionsCollectionIDResponse.from_dict(s)


def get_collections_collection_id_response_to_dict(x: GetCollectionsCollectionIDResponse) -> Any:
    return to_class(GetCollectionsCollectionIDResponse, x)


def get_collections_collection_id_response400_from_dict(s: Any) -> GetCollectionsCollectionIDResponse400:
    return GetCollectionsCollectionIDResponse400.from_dict(s)


def get_collections_collection_id_response400_to_dict(x: GetCollectionsCollectionIDResponse400) -> Any:
    return to_class(GetCollectionsCollectionIDResponse400, x)


def get_collections_collection_id_response401_from_dict(s: Any) -> GetCollectionsCollectionIDResponse401:
    return GetCollectionsCollectionIDResponse401.from_dict(s)


def get_collections_collection_id_response401_to_dict(x: GetCollectionsCollectionIDResponse401) -> Any:
    return to_class(GetCollectionsCollectionIDResponse401, x)


def get_collections_collection_id_response429_from_dict(s: Any) -> GetCollectionsCollectionIDResponse429:
    return GetCollectionsCollectionIDResponse429.from_dict(s)


def get_collections_collection_id_response429_to_dict(x: GetCollectionsCollectionIDResponse429) -> Any:
    return to_class(GetCollectionsCollectionIDResponse429, x)


def get_collections_collection_id_response500_from_dict(s: Any) -> GetCollectionsCollectionIDResponse500:
    return GetCollectionsCollectionIDResponse500.from_dict(s)


def get_collections_collection_id_response500_to_dict(x: GetCollectionsCollectionIDResponse500) -> Any:
    return to_class(GetCollectionsCollectionIDResponse500, x)


def get_collections_collection_id_responses_response_id_response_from_dict(s: Any) -> GetCollectionsCollectionIDResponsesResponseIDResponse:
    return GetCollectionsCollectionIDResponsesResponseIDResponse.from_dict(s)


def get_collections_collection_id_responses_response_id_response_to_dict(x: GetCollectionsCollectionIDResponsesResponseIDResponse) -> Any:
    return to_class(GetCollectionsCollectionIDResponsesResponseIDResponse, x)


def get_collections_collection_id_responses_response_id_response401_from_dict(s: Any) -> GetCollectionsCollectionIDResponsesResponseIDResponse401:
    return GetCollectionsCollectionIDResponsesResponseIDResponse401.from_dict(s)


def get_collections_collection_id_responses_response_id_response401_to_dict(x: GetCollectionsCollectionIDResponsesResponseIDResponse401) -> Any:
    return to_class(GetCollectionsCollectionIDResponsesResponseIDResponse401, x)


def get_collections_collection_id_responses_response_id_response404_from_dict(s: Any) -> GetCollectionsCollectionIDResponsesResponseIDResponse404:
    return GetCollectionsCollectionIDResponsesResponseIDResponse404.from_dict(s)


def get_collections_collection_id_responses_response_id_response404_to_dict(x: GetCollectionsCollectionIDResponsesResponseIDResponse404) -> Any:
    return to_class(GetCollectionsCollectionIDResponsesResponseIDResponse404, x)


def get_collections_collection_id_responses_response_id_response500_from_dict(s: Any) -> GetCollectionsCollectionIDResponsesResponseIDResponse500:
    return GetCollectionsCollectionIDResponsesResponseIDResponse500.from_dict(s)


def get_collections_collection_id_responses_response_id_response500_to_dict(x: GetCollectionsCollectionIDResponsesResponseIDResponse500) -> Any:
    return to_class(GetCollectionsCollectionIDResponsesResponseIDResponse500, x)


def get_collections_collection_id_tags_response_from_dict(s: Any) -> GetCollectionsCollectionIDTagsResponse:
    return GetCollectionsCollectionIDTagsResponse.from_dict(s)


def get_collections_collection_id_tags_response_to_dict(x: GetCollectionsCollectionIDTagsResponse) -> Any:
    return to_class(GetCollectionsCollectionIDTagsResponse, x)


def get_collections_collection_id_tags_response401_from_dict(s: Any) -> GetCollectionsCollectionIDTagsResponse401:
    return GetCollectionsCollectionIDTagsResponse401.from_dict(s)


def get_collections_collection_id_tags_response401_to_dict(x: GetCollectionsCollectionIDTagsResponse401) -> Any:
    return to_class(GetCollectionsCollectionIDTagsResponse401, x)


def get_collections_collection_id_tags_response403_from_dict(s: Any) -> GetCollectionsCollectionIDTagsResponse403:
    return GetCollectionsCollectionIDTagsResponse403.from_dict(s)


def get_collections_collection_id_tags_response403_to_dict(x: GetCollectionsCollectionIDTagsResponse403) -> Any:
    return to_class(GetCollectionsCollectionIDTagsResponse403, x)


def get_collections_collection_id_tags_response500_from_dict(s: Any) -> GetCollectionsCollectionIDTagsResponse500:
    return GetCollectionsCollectionIDTagsResponse500.from_dict(s)


def get_collections_collection_id_tags_response500_to_dict(x: GetCollectionsCollectionIDTagsResponse500) -> Any:
    return to_class(GetCollectionsCollectionIDTagsResponse500, x)


def get_collections_collection_id_transformations_response_from_dict(s: Any) -> GetCollectionsCollectionIDTransformationsResponse:
    return GetCollectionsCollectionIDTransformationsResponse.from_dict(s)


def get_collections_collection_id_transformations_response_to_dict(x: GetCollectionsCollectionIDTransformationsResponse) -> Any:
    return to_class(GetCollectionsCollectionIDTransformationsResponse, x)


def get_collections_collection_id_transformations_response401_from_dict(s: Any) -> GetCollectionsCollectionIDTransformationsResponse401:
    return GetCollectionsCollectionIDTransformationsResponse401.from_dict(s)


def get_collections_collection_id_transformations_response401_to_dict(x: GetCollectionsCollectionIDTransformationsResponse401) -> Any:
    return to_class(GetCollectionsCollectionIDTransformationsResponse401, x)


def get_collections_collection_id_transformations_response404_from_dict(s: Any) -> GetCollectionsCollectionIDTransformationsResponse404:
    return GetCollectionsCollectionIDTransformationsResponse404.from_dict(s)


def get_collections_collection_id_transformations_response404_to_dict(x: GetCollectionsCollectionIDTransformationsResponse404) -> Any:
    return to_class(GetCollectionsCollectionIDTransformationsResponse404, x)


def get_collections_collection_id_transformations_response500_from_dict(s: Any) -> GetCollectionsCollectionIDTransformationsResponse500:
    return GetCollectionsCollectionIDTransformationsResponse500.from_dict(s)


def get_collections_collection_id_transformations_response500_to_dict(x: GetCollectionsCollectionIDTransformationsResponse500) -> Any:
    return to_class(GetCollectionsCollectionIDTransformationsResponse500, x)


def get_collections_response_from_dict(s: Any) -> GetCollectionsResponse:
    return GetCollectionsResponse.from_dict(s)


def get_collections_response_to_dict(x: GetCollectionsResponse) -> Any:
    return to_class(GetCollectionsResponse, x)


def get_collections_response401_from_dict(s: Any) -> GetCollectionsResponse401:
    return GetCollectionsResponse401.from_dict(s)


def get_collections_response401_to_dict(x: GetCollectionsResponse401) -> Any:
    return to_class(GetCollectionsResponse401, x)


def get_collections_response429_from_dict(s: Any) -> GetCollectionsResponse429:
    return GetCollectionsResponse429.from_dict(s)


def get_collections_response429_to_dict(x: GetCollectionsResponse429) -> Any:
    return to_class(GetCollectionsResponse429, x)


def get_collections_response500_from_dict(s: Any) -> GetCollectionsResponse500:
    return GetCollectionsResponse500.from_dict(s)


def get_collections_response500_to_dict(x: GetCollectionsResponse500) -> Any:
    return to_class(GetCollectionsResponse500, x)


def get_detected_secrets_secret_id_locations_response_from_dict(s: Any) -> GetDetectedSecretsSecretIDLocationsResponse:
    return GetDetectedSecretsSecretIDLocationsResponse.from_dict(s)


def get_detected_secrets_secret_id_locations_response_to_dict(x: GetDetectedSecretsSecretIDLocationsResponse) -> Any:
    return to_class(GetDetectedSecretsSecretIDLocationsResponse, x)


def get_detected_secrets_secret_id_locations_response400_from_dict(s: Any) -> GetDetectedSecretsSecretIDLocationsResponse400:
    return GetDetectedSecretsSecretIDLocationsResponse400.from_dict(s)


def get_detected_secrets_secret_id_locations_response400_to_dict(x: GetDetectedSecretsSecretIDLocationsResponse400) -> Any:
    return to_class(GetDetectedSecretsSecretIDLocationsResponse400, x)


def get_detected_secrets_secret_id_locations_response401_from_dict(s: Any) -> GetDetectedSecretsSecretIDLocationsResponse401:
    return GetDetectedSecretsSecretIDLocationsResponse401.from_dict(s)


def get_detected_secrets_secret_id_locations_response401_to_dict(x: GetDetectedSecretsSecretIDLocationsResponse401) -> Any:
    return to_class(GetDetectedSecretsSecretIDLocationsResponse401, x)


def get_detected_secrets_secret_id_locations_response403_from_dict(s: Any) -> GetDetectedSecretsSecretIDLocationsResponse403:
    return GetDetectedSecretsSecretIDLocationsResponse403.from_dict(s)


def get_detected_secrets_secret_id_locations_response403_to_dict(x: GetDetectedSecretsSecretIDLocationsResponse403) -> Any:
    return to_class(GetDetectedSecretsSecretIDLocationsResponse403, x)


def get_detected_secrets_secret_id_locations_response500_from_dict(s: Any) -> GetDetectedSecretsSecretIDLocationsResponse500:
    return GetDetectedSecretsSecretIDLocationsResponse500.from_dict(s)


def get_detected_secrets_secret_id_locations_response500_to_dict(x: GetDetectedSecretsSecretIDLocationsResponse500) -> Any:
    return to_class(GetDetectedSecretsSecretIDLocationsResponse500, x)


def get_environments_environment_id_response_from_dict(s: Any) -> GetEnvironmentsEnvironmentIDResponse:
    return GetEnvironmentsEnvironmentIDResponse.from_dict(s)


def get_environments_environment_id_response_to_dict(x: GetEnvironmentsEnvironmentIDResponse) -> Any:
    return to_class(GetEnvironmentsEnvironmentIDResponse, x)


def get_environments_environment_id_response400_from_dict(s: Any) -> GetEnvironmentsEnvironmentIDResponse400:
    return GetEnvironmentsEnvironmentIDResponse400.from_dict(s)


def get_environments_environment_id_response400_to_dict(x: GetEnvironmentsEnvironmentIDResponse400) -> Any:
    return to_class(GetEnvironmentsEnvironmentIDResponse400, x)


def get_environments_environment_id_response401_from_dict(s: Any) -> GetEnvironmentsEnvironmentIDResponse401:
    return GetEnvironmentsEnvironmentIDResponse401.from_dict(s)


def get_environments_environment_id_response401_to_dict(x: GetEnvironmentsEnvironmentIDResponse401) -> Any:
    return to_class(GetEnvironmentsEnvironmentIDResponse401, x)


def get_environments_environment_id_response429_from_dict(s: Any) -> GetEnvironmentsEnvironmentIDResponse429:
    return GetEnvironmentsEnvironmentIDResponse429.from_dict(s)


def get_environments_environment_id_response429_to_dict(x: GetEnvironmentsEnvironmentIDResponse429) -> Any:
    return to_class(GetEnvironmentsEnvironmentIDResponse429, x)


def get_environments_environment_id_response500_from_dict(s: Any) -> GetEnvironmentsEnvironmentIDResponse500:
    return GetEnvironmentsEnvironmentIDResponse500.from_dict(s)


def get_environments_environment_id_response500_to_dict(x: GetEnvironmentsEnvironmentIDResponse500) -> Any:
    return to_class(GetEnvironmentsEnvironmentIDResponse500, x)


def get_environments_response_from_dict(s: Any) -> GetEnvironmentsResponse:
    return GetEnvironmentsResponse.from_dict(s)


def get_environments_response_to_dict(x: GetEnvironmentsResponse) -> Any:
    return to_class(GetEnvironmentsResponse, x)


def get_environments_response401_from_dict(s: Any) -> GetEnvironmentsResponse401:
    return GetEnvironmentsResponse401.from_dict(s)


def get_environments_response401_to_dict(x: GetEnvironmentsResponse401) -> Any:
    return to_class(GetEnvironmentsResponse401, x)


def get_environments_response404_from_dict(s: Any) -> GetEnvironmentsResponse404:
    return GetEnvironmentsResponse404.from_dict(s)


def get_environments_response404_to_dict(x: GetEnvironmentsResponse404) -> Any:
    return to_class(GetEnvironmentsResponse404, x)


def get_environments_response429_from_dict(s: Any) -> GetEnvironmentsResponse429:
    return GetEnvironmentsResponse429.from_dict(s)


def get_environments_response429_to_dict(x: GetEnvironmentsResponse429) -> Any:
    return to_class(GetEnvironmentsResponse429, x)


def get_environments_response500_from_dict(s: Any) -> GetEnvironmentsResponse500:
    return GetEnvironmentsResponse500.from_dict(s)


def get_environments_response500_to_dict(x: GetEnvironmentsResponse500) -> Any:
    return to_class(GetEnvironmentsResponse500, x)


def get_me_response_from_dict(s: Any) -> GetMeResponse:
    return GetMeResponse.from_dict(s)


def get_me_response_to_dict(x: GetMeResponse) -> Any:
    return to_class(GetMeResponse, x)


def get_me_response401_from_dict(s: Any) -> GetMeResponse401:
    return GetMeResponse401.from_dict(s)


def get_me_response401_to_dict(x: GetMeResponse401) -> Any:
    return to_class(GetMeResponse401, x)


def get_me_response429_from_dict(s: Any) -> GetMeResponse429:
    return GetMeResponse429.from_dict(s)


def get_me_response429_to_dict(x: GetMeResponse429) -> Any:
    return to_class(GetMeResponse429, x)


def get_me_response500_from_dict(s: Any) -> GetMeResponse500:
    return GetMeResponse500.from_dict(s)


def get_me_response500_to_dict(x: GetMeResponse500) -> Any:
    return to_class(GetMeResponse500, x)


def get_mocks_mock_id_call_logs_response_from_dict(s: Any) -> GetMocksMockIDCallLogsResponse:
    return GetMocksMockIDCallLogsResponse.from_dict(s)


def get_mocks_mock_id_call_logs_response_to_dict(x: GetMocksMockIDCallLogsResponse) -> Any:
    return to_class(GetMocksMockIDCallLogsResponse, x)


def get_mocks_mock_id_call_logs_response400_from_dict(s: Any) -> GetMocksMockIDCallLogsResponse400:
    return GetMocksMockIDCallLogsResponse400.from_dict(s)


def get_mocks_mock_id_call_logs_response400_to_dict(x: GetMocksMockIDCallLogsResponse400) -> Any:
    return to_class(GetMocksMockIDCallLogsResponse400, x)


def get_mocks_mock_id_call_logs_response401_from_dict(s: Any) -> GetMocksMockIDCallLogsResponse401:
    return GetMocksMockIDCallLogsResponse401.from_dict(s)


def get_mocks_mock_id_call_logs_response401_to_dict(x: GetMocksMockIDCallLogsResponse401) -> Any:
    return to_class(GetMocksMockIDCallLogsResponse401, x)


def get_mocks_mock_id_call_logs_response404_from_dict(s: Any) -> GetMocksMockIDCallLogsResponse404:
    return GetMocksMockIDCallLogsResponse404.from_dict(s)


def get_mocks_mock_id_call_logs_response404_to_dict(x: GetMocksMockIDCallLogsResponse404) -> Any:
    return to_class(GetMocksMockIDCallLogsResponse404, x)


def get_mocks_mock_id_call_logs_response429_from_dict(s: Any) -> GetMocksMockIDCallLogsResponse429:
    return GetMocksMockIDCallLogsResponse429.from_dict(s)


def get_mocks_mock_id_call_logs_response429_to_dict(x: GetMocksMockIDCallLogsResponse429) -> Any:
    return to_class(GetMocksMockIDCallLogsResponse429, x)


def get_mocks_mock_id_call_logs_response500_from_dict(s: Any) -> GetMocksMockIDCallLogsResponse500:
    return GetMocksMockIDCallLogsResponse500.from_dict(s)


def get_mocks_mock_id_call_logs_response500_to_dict(x: GetMocksMockIDCallLogsResponse500) -> Any:
    return to_class(GetMocksMockIDCallLogsResponse500, x)


def get_mocks_mock_id_response_from_dict(s: Any) -> GetMocksMockIDResponse:
    return GetMocksMockIDResponse.from_dict(s)


def get_mocks_mock_id_response_to_dict(x: GetMocksMockIDResponse) -> Any:
    return to_class(GetMocksMockIDResponse, x)


def get_mocks_mock_id_response401_from_dict(s: Any) -> GetMocksMockIDResponse401:
    return GetMocksMockIDResponse401.from_dict(s)


def get_mocks_mock_id_response401_to_dict(x: GetMocksMockIDResponse401) -> Any:
    return to_class(GetMocksMockIDResponse401, x)


def get_mocks_mock_id_response404_from_dict(s: Any) -> GetMocksMockIDResponse404:
    return GetMocksMockIDResponse404.from_dict(s)


def get_mocks_mock_id_response404_to_dict(x: GetMocksMockIDResponse404) -> Any:
    return to_class(GetMocksMockIDResponse404, x)


def get_mocks_mock_id_response429_from_dict(s: Any) -> GetMocksMockIDResponse429:
    return GetMocksMockIDResponse429.from_dict(s)


def get_mocks_mock_id_response429_to_dict(x: GetMocksMockIDResponse429) -> Any:
    return to_class(GetMocksMockIDResponse429, x)


def get_mocks_mock_id_response500_from_dict(s: Any) -> GetMocksMockIDResponse500:
    return GetMocksMockIDResponse500.from_dict(s)


def get_mocks_mock_id_response500_to_dict(x: GetMocksMockIDResponse500) -> Any:
    return to_class(GetMocksMockIDResponse500, x)


def get_mocks_mock_id_server_responses_response401_from_dict(s: Any) -> GetMocksMockIDServerResponsesResponse401:
    return GetMocksMockIDServerResponsesResponse401.from_dict(s)


def get_mocks_mock_id_server_responses_response401_to_dict(x: GetMocksMockIDServerResponsesResponse401) -> Any:
    return to_class(GetMocksMockIDServerResponsesResponse401, x)


def get_mocks_mock_id_server_responses_response404_from_dict(s: Any) -> GetMocksMockIDServerResponsesResponse404:
    return GetMocksMockIDServerResponsesResponse404.from_dict(s)


def get_mocks_mock_id_server_responses_response404_to_dict(x: GetMocksMockIDServerResponsesResponse404) -> Any:
    return to_class(GetMocksMockIDServerResponsesResponse404, x)


def get_mocks_mock_id_server_responses_response429_from_dict(s: Any) -> GetMocksMockIDServerResponsesResponse429:
    return GetMocksMockIDServerResponsesResponse429.from_dict(s)


def get_mocks_mock_id_server_responses_response429_to_dict(x: GetMocksMockIDServerResponsesResponse429) -> Any:
    return to_class(GetMocksMockIDServerResponsesResponse429, x)


def get_mocks_mock_id_server_responses_response500_from_dict(s: Any) -> GetMocksMockIDServerResponsesResponse500:
    return GetMocksMockIDServerResponsesResponse500.from_dict(s)


def get_mocks_mock_id_server_responses_response500_to_dict(x: GetMocksMockIDServerResponsesResponse500) -> Any:
    return to_class(GetMocksMockIDServerResponsesResponse500, x)


def get_mocks_mock_id_server_responses_response_item_from_dict(s: Any) -> GetMocksMockIDServerResponsesResponseItem:
    return GetMocksMockIDServerResponsesResponseItem.from_dict(s)


def get_mocks_mock_id_server_responses_response_item_to_dict(x: GetMocksMockIDServerResponsesResponseItem) -> Any:
    return to_class(GetMocksMockIDServerResponsesResponseItem, x)


def get_mocks_mock_id_server_responses_server_response_id_response400_from_dict(s: Any) -> GetMocksMockIDServerResponsesServerResponseIDResponse400:
    return GetMocksMockIDServerResponsesServerResponseIDResponse400.from_dict(s)


def get_mocks_mock_id_server_responses_server_response_id_response400_to_dict(x: GetMocksMockIDServerResponsesServerResponseIDResponse400) -> Any:
    return to_class(GetMocksMockIDServerResponsesServerResponseIDResponse400, x)


def get_mocks_mock_id_server_responses_server_response_id_response401_from_dict(s: Any) -> GetMocksMockIDServerResponsesServerResponseIDResponse401:
    return GetMocksMockIDServerResponsesServerResponseIDResponse401.from_dict(s)


def get_mocks_mock_id_server_responses_server_response_id_response401_to_dict(x: GetMocksMockIDServerResponsesServerResponseIDResponse401) -> Any:
    return to_class(GetMocksMockIDServerResponsesServerResponseIDResponse401, x)


def get_mocks_mock_id_server_responses_server_response_id_response404_from_dict(s: Any) -> GetMocksMockIDServerResponsesServerResponseIDResponse404:
    return GetMocksMockIDServerResponsesServerResponseIDResponse404.from_dict(s)


def get_mocks_mock_id_server_responses_server_response_id_response404_to_dict(x: GetMocksMockIDServerResponsesServerResponseIDResponse404) -> Any:
    return to_class(GetMocksMockIDServerResponsesServerResponseIDResponse404, x)


def get_mocks_mock_id_server_responses_server_response_id_response429_from_dict(s: Any) -> GetMocksMockIDServerResponsesServerResponseIDResponse429:
    return GetMocksMockIDServerResponsesServerResponseIDResponse429.from_dict(s)


def get_mocks_mock_id_server_responses_server_response_id_response429_to_dict(x: GetMocksMockIDServerResponsesServerResponseIDResponse429) -> Any:
    return to_class(GetMocksMockIDServerResponsesServerResponseIDResponse429, x)


def get_mocks_mock_id_server_responses_server_response_id_response500_from_dict(s: Any) -> GetMocksMockIDServerResponsesServerResponseIDResponse500:
    return GetMocksMockIDServerResponsesServerResponseIDResponse500.from_dict(s)


def get_mocks_mock_id_server_responses_server_response_id_response500_to_dict(x: GetMocksMockIDServerResponsesServerResponseIDResponse500) -> Any:
    return to_class(GetMocksMockIDServerResponsesServerResponseIDResponse500, x)


def get_mocks_mock_id_server_responses_server_response_id_response_item_from_dict(s: Any) -> GetMocksMockIDServerResponsesServerResponseIDResponseItem:
    return GetMocksMockIDServerResponsesServerResponseIDResponseItem.from_dict(s)


def get_mocks_mock_id_server_responses_server_response_id_response_item_to_dict(x: GetMocksMockIDServerResponsesServerResponseIDResponseItem) -> Any:
    return to_class(GetMocksMockIDServerResponsesServerResponseIDResponseItem, x)


def get_mocks_response_from_dict(s: Any) -> GetMocksResponse:
    return GetMocksResponse.from_dict(s)


def get_mocks_response_to_dict(x: GetMocksResponse) -> Any:
    return to_class(GetMocksResponse, x)


def get_mocks_response401_from_dict(s: Any) -> GetMocksResponse401:
    return GetMocksResponse401.from_dict(s)


def get_mocks_response401_to_dict(x: GetMocksResponse401) -> Any:
    return to_class(GetMocksResponse401, x)


def get_mocks_response429_from_dict(s: Any) -> GetMocksResponse429:
    return GetMocksResponse429.from_dict(s)


def get_mocks_response429_to_dict(x: GetMocksResponse429) -> Any:
    return to_class(GetMocksResponse429, x)


def get_mocks_response500_from_dict(s: Any) -> GetMocksResponse500:
    return GetMocksResponse500.from_dict(s)


def get_mocks_response500_to_dict(x: GetMocksResponse500) -> Any:
    return to_class(GetMocksResponse500, x)


def get_monitors_monitor_id_response_from_dict(s: Any) -> GetMonitorsMonitorIDResponse:
    return GetMonitorsMonitorIDResponse.from_dict(s)


def get_monitors_monitor_id_response_to_dict(x: GetMonitorsMonitorIDResponse) -> Any:
    return to_class(GetMonitorsMonitorIDResponse, x)


def get_monitors_monitor_id_response401_from_dict(s: Any) -> GetMonitorsMonitorIDResponse401:
    return GetMonitorsMonitorIDResponse401.from_dict(s)


def get_monitors_monitor_id_response401_to_dict(x: GetMonitorsMonitorIDResponse401) -> Any:
    return to_class(GetMonitorsMonitorIDResponse401, x)


def get_monitors_monitor_id_response404_from_dict(s: Any) -> GetMonitorsMonitorIDResponse404:
    return GetMonitorsMonitorIDResponse404.from_dict(s)


def get_monitors_monitor_id_response404_to_dict(x: GetMonitorsMonitorIDResponse404) -> Any:
    return to_class(GetMonitorsMonitorIDResponse404, x)


def get_monitors_monitor_id_response429_from_dict(s: Any) -> GetMonitorsMonitorIDResponse429:
    return GetMonitorsMonitorIDResponse429.from_dict(s)


def get_monitors_monitor_id_response429_to_dict(x: GetMonitorsMonitorIDResponse429) -> Any:
    return to_class(GetMonitorsMonitorIDResponse429, x)


def get_monitors_monitor_id_response500_from_dict(s: Any) -> GetMonitorsMonitorIDResponse500:
    return GetMonitorsMonitorIDResponse500.from_dict(s)


def get_monitors_monitor_id_response500_to_dict(x: GetMonitorsMonitorIDResponse500) -> Any:
    return to_class(GetMonitorsMonitorIDResponse500, x)


def get_monitors_response_from_dict(s: Any) -> GetMonitorsResponse:
    return GetMonitorsResponse.from_dict(s)


def get_monitors_response_to_dict(x: GetMonitorsResponse) -> Any:
    return to_class(GetMonitorsResponse, x)


def get_monitors_response401_from_dict(s: Any) -> GetMonitorsResponse401:
    return GetMonitorsResponse401.from_dict(s)


def get_monitors_response401_to_dict(x: GetMonitorsResponse401) -> Any:
    return to_class(GetMonitorsResponse401, x)


def get_monitors_response429_from_dict(s: Any) -> GetMonitorsResponse429:
    return GetMonitorsResponse429.from_dict(s)


def get_monitors_response429_to_dict(x: GetMonitorsResponse429) -> Any:
    return to_class(GetMonitorsResponse429, x)


def get_monitors_response500_from_dict(s: Any) -> GetMonitorsResponse500:
    return GetMonitorsResponse500.from_dict(s)


def get_monitors_response500_to_dict(x: GetMonitorsResponse500) -> Any:
    return to_class(GetMonitorsResponse500, x)


def get_network_private_network_entity_request_all_response_from_dict(s: Any) -> GetNetworkPrivateNetworkEntityRequestAllResponse:
    return GetNetworkPrivateNetworkEntityRequestAllResponse.from_dict(s)


def get_network_private_network_entity_request_all_response_to_dict(x: GetNetworkPrivateNetworkEntityRequestAllResponse) -> Any:
    return to_class(GetNetworkPrivateNetworkEntityRequestAllResponse, x)


def get_network_private_network_entity_request_all_response400_from_dict(s: Any) -> GetNetworkPrivateNetworkEntityRequestAllResponse400:
    return GetNetworkPrivateNetworkEntityRequestAllResponse400.from_dict(s)


def get_network_private_network_entity_request_all_response400_to_dict(x: GetNetworkPrivateNetworkEntityRequestAllResponse400) -> Any:
    return to_class(GetNetworkPrivateNetworkEntityRequestAllResponse400, x)


def get_network_private_network_entity_request_all_response401_from_dict(s: Any) -> GetNetworkPrivateNetworkEntityRequestAllResponse401:
    return GetNetworkPrivateNetworkEntityRequestAllResponse401.from_dict(s)


def get_network_private_network_entity_request_all_response401_to_dict(x: GetNetworkPrivateNetworkEntityRequestAllResponse401) -> Any:
    return to_class(GetNetworkPrivateNetworkEntityRequestAllResponse401, x)


def get_network_private_network_entity_request_all_response403_from_dict(s: Any) -> GetNetworkPrivateNetworkEntityRequestAllResponse403:
    return GetNetworkPrivateNetworkEntityRequestAllResponse403.from_dict(s)


def get_network_private_network_entity_request_all_response403_to_dict(x: GetNetworkPrivateNetworkEntityRequestAllResponse403) -> Any:
    return to_class(GetNetworkPrivateNetworkEntityRequestAllResponse403, x)


def get_network_private_network_entity_request_all_response429_from_dict(s: Any) -> GetNetworkPrivateNetworkEntityRequestAllResponse429:
    return GetNetworkPrivateNetworkEntityRequestAllResponse429.from_dict(s)


def get_network_private_network_entity_request_all_response429_to_dict(x: GetNetworkPrivateNetworkEntityRequestAllResponse429) -> Any:
    return to_class(GetNetworkPrivateNetworkEntityRequestAllResponse429, x)


def get_network_private_network_entity_request_all_response500_from_dict(s: Any) -> GetNetworkPrivateNetworkEntityRequestAllResponse500:
    return GetNetworkPrivateNetworkEntityRequestAllResponse500.from_dict(s)


def get_network_private_network_entity_request_all_response500_to_dict(x: GetNetworkPrivateNetworkEntityRequestAllResponse500) -> Any:
    return to_class(GetNetworkPrivateNetworkEntityRequestAllResponse500, x)


def get_network_private_response_from_dict(s: Any) -> GetNetworkPrivateResponse:
    return GetNetworkPrivateResponse.from_dict(s)


def get_network_private_response_to_dict(x: GetNetworkPrivateResponse) -> Any:
    return to_class(GetNetworkPrivateResponse, x)


def get_network_private_response401_from_dict(s: Any) -> GetNetworkPrivateResponse401:
    return GetNetworkPrivateResponse401.from_dict(s)


def get_network_private_response401_to_dict(x: GetNetworkPrivateResponse401) -> Any:
    return to_class(GetNetworkPrivateResponse401, x)


def get_network_private_response403_from_dict(s: Any) -> GetNetworkPrivateResponse403:
    return GetNetworkPrivateResponse403.from_dict(s)


def get_network_private_response403_to_dict(x: GetNetworkPrivateResponse403) -> Any:
    return to_class(GetNetworkPrivateResponse403, x)


def get_network_private_response429_from_dict(s: Any) -> GetNetworkPrivateResponse429:
    return GetNetworkPrivateResponse429.from_dict(s)


def get_network_private_response429_to_dict(x: GetNetworkPrivateResponse429) -> Any:
    return to_class(GetNetworkPrivateResponse429, x)


def get_network_private_response500_from_dict(s: Any) -> GetNetworkPrivateResponse500:
    return GetNetworkPrivateResponse500.from_dict(s)


def get_network_private_response500_to_dict(x: GetNetworkPrivateResponse500) -> Any:
    return to_class(GetNetworkPrivateResponse500, x)


def get_scim_v2_groups_group_id_response_from_dict(s: Any) -> GetScimV2GroupsGroupIDResponse:
    return GetScimV2GroupsGroupIDResponse.from_dict(s)


def get_scim_v2_groups_group_id_response_to_dict(x: GetScimV2GroupsGroupIDResponse) -> Any:
    return to_class(GetScimV2GroupsGroupIDResponse, x)


def get_scim_v2_groups_group_id_response400_from_dict(s: Any) -> GetScimV2GroupsGroupIDResponse400:
    return GetScimV2GroupsGroupIDResponse400.from_dict(s)


def get_scim_v2_groups_group_id_response400_to_dict(x: GetScimV2GroupsGroupIDResponse400) -> Any:
    return to_class(GetScimV2GroupsGroupIDResponse400, x)


def get_scim_v2_groups_group_id_response401_from_dict(s: Any) -> GetScimV2GroupsGroupIDResponse401:
    return GetScimV2GroupsGroupIDResponse401.from_dict(s)


def get_scim_v2_groups_group_id_response401_to_dict(x: GetScimV2GroupsGroupIDResponse401) -> Any:
    return to_class(GetScimV2GroupsGroupIDResponse401, x)


def get_scim_v2_groups_group_id_response403_from_dict(s: Any) -> GetScimV2GroupsGroupIDResponse403:
    return GetScimV2GroupsGroupIDResponse403.from_dict(s)


def get_scim_v2_groups_group_id_response403_to_dict(x: GetScimV2GroupsGroupIDResponse403) -> Any:
    return to_class(GetScimV2GroupsGroupIDResponse403, x)


def get_scim_v2_groups_group_id_response404_from_dict(s: Any) -> GetScimV2GroupsGroupIDResponse404:
    return GetScimV2GroupsGroupIDResponse404.from_dict(s)


def get_scim_v2_groups_group_id_response404_to_dict(x: GetScimV2GroupsGroupIDResponse404) -> Any:
    return to_class(GetScimV2GroupsGroupIDResponse404, x)


def get_scim_v2_groups_group_id_response429_from_dict(s: Any) -> GetScimV2GroupsGroupIDResponse429:
    return GetScimV2GroupsGroupIDResponse429.from_dict(s)


def get_scim_v2_groups_group_id_response429_to_dict(x: GetScimV2GroupsGroupIDResponse429) -> Any:
    return to_class(GetScimV2GroupsGroupIDResponse429, x)


def get_scim_v2_groups_group_id_response500_from_dict(s: Any) -> GetScimV2GroupsGroupIDResponse500:
    return GetScimV2GroupsGroupIDResponse500.from_dict(s)


def get_scim_v2_groups_group_id_response500_to_dict(x: GetScimV2GroupsGroupIDResponse500) -> Any:
    return to_class(GetScimV2GroupsGroupIDResponse500, x)


def get_scim_v2_groups_response_from_dict(s: Any) -> GetScimV2GroupsResponse:
    return GetScimV2GroupsResponse.from_dict(s)


def get_scim_v2_groups_response_to_dict(x: GetScimV2GroupsResponse) -> Any:
    return to_class(GetScimV2GroupsResponse, x)


def get_scim_v2_groups_response400_from_dict(s: Any) -> GetScimV2GroupsResponse400:
    return GetScimV2GroupsResponse400.from_dict(s)


def get_scim_v2_groups_response400_to_dict(x: GetScimV2GroupsResponse400) -> Any:
    return to_class(GetScimV2GroupsResponse400, x)


def get_scim_v2_groups_response401_from_dict(s: Any) -> GetScimV2GroupsResponse401:
    return GetScimV2GroupsResponse401.from_dict(s)


def get_scim_v2_groups_response401_to_dict(x: GetScimV2GroupsResponse401) -> Any:
    return to_class(GetScimV2GroupsResponse401, x)


def get_scim_v2_groups_response403_from_dict(s: Any) -> GetScimV2GroupsResponse403:
    return GetScimV2GroupsResponse403.from_dict(s)


def get_scim_v2_groups_response403_to_dict(x: GetScimV2GroupsResponse403) -> Any:
    return to_class(GetScimV2GroupsResponse403, x)


def get_scim_v2_groups_response429_from_dict(s: Any) -> GetScimV2GroupsResponse429:
    return GetScimV2GroupsResponse429.from_dict(s)


def get_scim_v2_groups_response429_to_dict(x: GetScimV2GroupsResponse429) -> Any:
    return to_class(GetScimV2GroupsResponse429, x)


def get_scim_v2_groups_response500_from_dict(s: Any) -> GetScimV2GroupsResponse500:
    return GetScimV2GroupsResponse500.from_dict(s)


def get_scim_v2_groups_response500_to_dict(x: GetScimV2GroupsResponse500) -> Any:
    return to_class(GetScimV2GroupsResponse500, x)


def get_scim_v2_resource_types_response401_from_dict(s: Any) -> GetScimV2ResourceTypesResponse401:
    return GetScimV2ResourceTypesResponse401.from_dict(s)


def get_scim_v2_resource_types_response401_to_dict(x: GetScimV2ResourceTypesResponse401) -> Any:
    return to_class(GetScimV2ResourceTypesResponse401, x)


def get_scim_v2_resource_types_response500_from_dict(s: Any) -> GetScimV2ResourceTypesResponse500:
    return GetScimV2ResourceTypesResponse500.from_dict(s)


def get_scim_v2_resource_types_response500_to_dict(x: GetScimV2ResourceTypesResponse500) -> Any:
    return to_class(GetScimV2ResourceTypesResponse500, x)


def get_scim_v2_resource_types_response_item_from_dict(s: Any) -> GetScimV2ResourceTypesResponseItem:
    return GetScimV2ResourceTypesResponseItem.from_dict(s)


def get_scim_v2_resource_types_response_item_to_dict(x: GetScimV2ResourceTypesResponseItem) -> Any:
    return to_class(GetScimV2ResourceTypesResponseItem, x)


def get_scim_v2_service_provider_config_response_from_dict(s: Any) -> GetScimV2ServiceProviderConfigResponse:
    return GetScimV2ServiceProviderConfigResponse.from_dict(s)


def get_scim_v2_service_provider_config_response_to_dict(x: GetScimV2ServiceProviderConfigResponse) -> Any:
    return to_class(GetScimV2ServiceProviderConfigResponse, x)


def get_scim_v2_service_provider_config_response401_from_dict(s: Any) -> GetScimV2ServiceProviderConfigResponse401:
    return GetScimV2ServiceProviderConfigResponse401.from_dict(s)


def get_scim_v2_service_provider_config_response401_to_dict(x: GetScimV2ServiceProviderConfigResponse401) -> Any:
    return to_class(GetScimV2ServiceProviderConfigResponse401, x)


def get_scim_v2_service_provider_config_response500_from_dict(s: Any) -> GetScimV2ServiceProviderConfigResponse500:
    return GetScimV2ServiceProviderConfigResponse500.from_dict(s)


def get_scim_v2_service_provider_config_response500_to_dict(x: GetScimV2ServiceProviderConfigResponse500) -> Any:
    return to_class(GetScimV2ServiceProviderConfigResponse500, x)


def get_scim_v2_users_response_from_dict(s: Any) -> GetScimV2UsersResponse:
    return GetScimV2UsersResponse.from_dict(s)


def get_scim_v2_users_response_to_dict(x: GetScimV2UsersResponse) -> Any:
    return to_class(GetScimV2UsersResponse, x)


def get_scim_v2_users_response400_from_dict(s: Any) -> GetScimV2UsersResponse400:
    return GetScimV2UsersResponse400.from_dict(s)


def get_scim_v2_users_response400_to_dict(x: GetScimV2UsersResponse400) -> Any:
    return to_class(GetScimV2UsersResponse400, x)


def get_scim_v2_users_response401_from_dict(s: Any) -> GetScimV2UsersResponse401:
    return GetScimV2UsersResponse401.from_dict(s)


def get_scim_v2_users_response401_to_dict(x: GetScimV2UsersResponse401) -> Any:
    return to_class(GetScimV2UsersResponse401, x)


def get_scim_v2_users_response403_from_dict(s: Any) -> GetScimV2UsersResponse403:
    return GetScimV2UsersResponse403.from_dict(s)


def get_scim_v2_users_response403_to_dict(x: GetScimV2UsersResponse403) -> Any:
    return to_class(GetScimV2UsersResponse403, x)


def get_scim_v2_users_response429_from_dict(s: Any) -> GetScimV2UsersResponse429:
    return GetScimV2UsersResponse429.from_dict(s)


def get_scim_v2_users_response429_to_dict(x: GetScimV2UsersResponse429) -> Any:
    return to_class(GetScimV2UsersResponse429, x)


def get_scim_v2_users_response500_from_dict(s: Any) -> GetScimV2UsersResponse500:
    return GetScimV2UsersResponse500.from_dict(s)


def get_scim_v2_users_response500_to_dict(x: GetScimV2UsersResponse500) -> Any:
    return to_class(GetScimV2UsersResponse500, x)


def get_scim_v2_users_user_id_response_from_dict(s: Any) -> GetScimV2UsersUserIDResponse:
    return GetScimV2UsersUserIDResponse.from_dict(s)


def get_scim_v2_users_user_id_response_to_dict(x: GetScimV2UsersUserIDResponse) -> Any:
    return to_class(GetScimV2UsersUserIDResponse, x)


def get_scim_v2_users_user_id_response400_from_dict(s: Any) -> GetScimV2UsersUserIDResponse400:
    return GetScimV2UsersUserIDResponse400.from_dict(s)


def get_scim_v2_users_user_id_response400_to_dict(x: GetScimV2UsersUserIDResponse400) -> Any:
    return to_class(GetScimV2UsersUserIDResponse400, x)


def get_scim_v2_users_user_id_response401_from_dict(s: Any) -> GetScimV2UsersUserIDResponse401:
    return GetScimV2UsersUserIDResponse401.from_dict(s)


def get_scim_v2_users_user_id_response401_to_dict(x: GetScimV2UsersUserIDResponse401) -> Any:
    return to_class(GetScimV2UsersUserIDResponse401, x)


def get_scim_v2_users_user_id_response403_from_dict(s: Any) -> GetScimV2UsersUserIDResponse403:
    return GetScimV2UsersUserIDResponse403.from_dict(s)


def get_scim_v2_users_user_id_response403_to_dict(x: GetScimV2UsersUserIDResponse403) -> Any:
    return to_class(GetScimV2UsersUserIDResponse403, x)


def get_scim_v2_users_user_id_response404_from_dict(s: Any) -> GetScimV2UsersUserIDResponse404:
    return GetScimV2UsersUserIDResponse404.from_dict(s)


def get_scim_v2_users_user_id_response404_to_dict(x: GetScimV2UsersUserIDResponse404) -> Any:
    return to_class(GetScimV2UsersUserIDResponse404, x)


def get_scim_v2_users_user_id_response429_from_dict(s: Any) -> GetScimV2UsersUserIDResponse429:
    return GetScimV2UsersUserIDResponse429.from_dict(s)


def get_scim_v2_users_user_id_response429_to_dict(x: GetScimV2UsersUserIDResponse429) -> Any:
    return to_class(GetScimV2UsersUserIDResponse429, x)


def get_scim_v2_users_user_id_response500_from_dict(s: Any) -> GetScimV2UsersUserIDResponse500:
    return GetScimV2UsersUserIDResponse500.from_dict(s)


def get_scim_v2_users_user_id_response500_to_dict(x: GetScimV2UsersUserIDResponse500) -> Any:
    return to_class(GetScimV2UsersUserIDResponse500, x)


def get_secret_types_response_from_dict(s: Any) -> GetSecretTypesResponse:
    return GetSecretTypesResponse.from_dict(s)


def get_secret_types_response_to_dict(x: GetSecretTypesResponse) -> Any:
    return to_class(GetSecretTypesResponse, x)


def get_secret_types_response401_from_dict(s: Any) -> GetSecretTypesResponse401:
    return GetSecretTypesResponse401.from_dict(s)


def get_secret_types_response401_to_dict(x: GetSecretTypesResponse401) -> Any:
    return to_class(GetSecretTypesResponse401, x)


def get_secret_types_response403_from_dict(s: Any) -> GetSecretTypesResponse403:
    return GetSecretTypesResponse403.from_dict(s)


def get_secret_types_response403_to_dict(x: GetSecretTypesResponse403) -> Any:
    return to_class(GetSecretTypesResponse403, x)


def get_secret_types_response500_from_dict(s: Any) -> GetSecretTypesResponse500:
    return GetSecretTypesResponse500.from_dict(s)


def get_secret_types_response500_to_dict(x: GetSecretTypesResponse500) -> Any:
    return to_class(GetSecretTypesResponse500, x)


def get_tags_slug_entities_response_from_dict(s: Any) -> GetTagsSlugEntitiesResponse:
    return GetTagsSlugEntitiesResponse.from_dict(s)


def get_tags_slug_entities_response_to_dict(x: GetTagsSlugEntitiesResponse) -> Any:
    return to_class(GetTagsSlugEntitiesResponse, x)


def get_tags_slug_entities_response400_from_dict(s: Any) -> GetTagsSlugEntitiesResponse400:
    return GetTagsSlugEntitiesResponse400.from_dict(s)


def get_tags_slug_entities_response400_to_dict(x: GetTagsSlugEntitiesResponse400) -> Any:
    return to_class(GetTagsSlugEntitiesResponse400, x)


def get_tags_slug_entities_response401_from_dict(s: Any) -> GetTagsSlugEntitiesResponse401:
    return GetTagsSlugEntitiesResponse401.from_dict(s)


def get_tags_slug_entities_response401_to_dict(x: GetTagsSlugEntitiesResponse401) -> Any:
    return to_class(GetTagsSlugEntitiesResponse401, x)


def get_tags_slug_entities_response403_from_dict(s: Any) -> GetTagsSlugEntitiesResponse403:
    return GetTagsSlugEntitiesResponse403.from_dict(s)


def get_tags_slug_entities_response403_to_dict(x: GetTagsSlugEntitiesResponse403) -> Any:
    return to_class(GetTagsSlugEntitiesResponse403, x)


def get_tags_slug_entities_response404_from_dict(s: Any) -> GetTagsSlugEntitiesResponse404:
    return GetTagsSlugEntitiesResponse404.from_dict(s)


def get_tags_slug_entities_response404_to_dict(x: GetTagsSlugEntitiesResponse404) -> Any:
    return to_class(GetTagsSlugEntitiesResponse404, x)


def get_tags_slug_entities_response500_from_dict(s: Any) -> GetTagsSlugEntitiesResponse500:
    return GetTagsSlugEntitiesResponse500.from_dict(s)


def get_tags_slug_entities_response500_to_dict(x: GetTagsSlugEntitiesResponse500) -> Any:
    return to_class(GetTagsSlugEntitiesResponse500, x)


def get_workspaces_response_from_dict(s: Any) -> GetWorkspacesResponse:
    return GetWorkspacesResponse.from_dict(s)


def get_workspaces_response_to_dict(x: GetWorkspacesResponse) -> Any:
    return to_class(GetWorkspacesResponse, x)


def get_workspaces_response401_from_dict(s: Any) -> GetWorkspacesResponse401:
    return GetWorkspacesResponse401.from_dict(s)


def get_workspaces_response401_to_dict(x: GetWorkspacesResponse401) -> Any:
    return to_class(GetWorkspacesResponse401, x)


def get_workspaces_response429_from_dict(s: Any) -> GetWorkspacesResponse429:
    return GetWorkspacesResponse429.from_dict(s)


def get_workspaces_response429_to_dict(x: GetWorkspacesResponse429) -> Any:
    return to_class(GetWorkspacesResponse429, x)


def get_workspaces_response500_from_dict(s: Any) -> GetWorkspacesResponse500:
    return GetWorkspacesResponse500.from_dict(s)


def get_workspaces_response500_to_dict(x: GetWorkspacesResponse500) -> Any:
    return to_class(GetWorkspacesResponse500, x)


def get_workspaces_workspace_id_global_variables_response_from_dict(s: Any) -> GetWorkspacesWorkspaceIDGlobalVariablesResponse:
    return GetWorkspacesWorkspaceIDGlobalVariablesResponse.from_dict(s)


def get_workspaces_workspace_id_global_variables_response_to_dict(x: GetWorkspacesWorkspaceIDGlobalVariablesResponse) -> Any:
    return to_class(GetWorkspacesWorkspaceIDGlobalVariablesResponse, x)


def get_workspaces_workspace_id_global_variables_response500_from_dict(s: Any) -> GetWorkspacesWorkspaceIDGlobalVariablesResponse500:
    return GetWorkspacesWorkspaceIDGlobalVariablesResponse500.from_dict(s)


def get_workspaces_workspace_id_global_variables_response500_to_dict(x: GetWorkspacesWorkspaceIDGlobalVariablesResponse500) -> Any:
    return to_class(GetWorkspacesWorkspaceIDGlobalVariablesResponse500, x)


def get_workspaces_workspace_id_response_from_dict(s: Any) -> GetWorkspacesWorkspaceIDResponse:
    return GetWorkspacesWorkspaceIDResponse.from_dict(s)


def get_workspaces_workspace_id_response_to_dict(x: GetWorkspacesWorkspaceIDResponse) -> Any:
    return to_class(GetWorkspacesWorkspaceIDResponse, x)


def get_workspaces_workspace_id_response401_from_dict(s: Any) -> GetWorkspacesWorkspaceIDResponse401:
    return GetWorkspacesWorkspaceIDResponse401.from_dict(s)


def get_workspaces_workspace_id_response401_to_dict(x: GetWorkspacesWorkspaceIDResponse401) -> Any:
    return to_class(GetWorkspacesWorkspaceIDResponse401, x)


def get_workspaces_workspace_id_response404_from_dict(s: Any) -> GetWorkspacesWorkspaceIDResponse404:
    return GetWorkspacesWorkspaceIDResponse404.from_dict(s)


def get_workspaces_workspace_id_response404_to_dict(x: GetWorkspacesWorkspaceIDResponse404) -> Any:
    return to_class(GetWorkspacesWorkspaceIDResponse404, x)


def get_workspaces_workspace_id_response429_from_dict(s: Any) -> GetWorkspacesWorkspaceIDResponse429:
    return GetWorkspacesWorkspaceIDResponse429.from_dict(s)


def get_workspaces_workspace_id_response429_to_dict(x: GetWorkspacesWorkspaceIDResponse429) -> Any:
    return to_class(GetWorkspacesWorkspaceIDResponse429, x)


def get_workspaces_workspace_id_response500_from_dict(s: Any) -> GetWorkspacesWorkspaceIDResponse500:
    return GetWorkspacesWorkspaceIDResponse500.from_dict(s)


def get_workspaces_workspace_id_response500_to_dict(x: GetWorkspacesWorkspaceIDResponse500) -> Any:
    return to_class(GetWorkspacesWorkspaceIDResponse500, x)


def get_workspaces_workspace_id_tags_response_from_dict(s: Any) -> GetWorkspacesWorkspaceIDTagsResponse:
    return GetWorkspacesWorkspaceIDTagsResponse.from_dict(s)


def get_workspaces_workspace_id_tags_response_to_dict(x: GetWorkspacesWorkspaceIDTagsResponse) -> Any:
    return to_class(GetWorkspacesWorkspaceIDTagsResponse, x)


def get_workspaces_workspace_id_tags_response401_from_dict(s: Any) -> GetWorkspacesWorkspaceIDTagsResponse401:
    return GetWorkspacesWorkspaceIDTagsResponse401.from_dict(s)


def get_workspaces_workspace_id_tags_response401_to_dict(x: GetWorkspacesWorkspaceIDTagsResponse401) -> Any:
    return to_class(GetWorkspacesWorkspaceIDTagsResponse401, x)


def get_workspaces_workspace_id_tags_response403_from_dict(s: Any) -> GetWorkspacesWorkspaceIDTagsResponse403:
    return GetWorkspacesWorkspaceIDTagsResponse403.from_dict(s)


def get_workspaces_workspace_id_tags_response403_to_dict(x: GetWorkspacesWorkspaceIDTagsResponse403) -> Any:
    return to_class(GetWorkspacesWorkspaceIDTagsResponse403, x)


def get_workspaces_workspace_id_tags_response404_from_dict(s: Any) -> GetWorkspacesWorkspaceIDTagsResponse404:
    return GetWorkspacesWorkspaceIDTagsResponse404.from_dict(s)


def get_workspaces_workspace_id_tags_response404_to_dict(x: GetWorkspacesWorkspaceIDTagsResponse404) -> Any:
    return to_class(GetWorkspacesWorkspaceIDTagsResponse404, x)


def get_workspaces_workspace_id_tags_response500_from_dict(s: Any) -> GetWorkspacesWorkspaceIDTagsResponse500:
    return GetWorkspacesWorkspaceIDTagsResponse500.from_dict(s)


def get_workspaces_workspace_id_tags_response500_to_dict(x: GetWorkspacesWorkspaceIDTagsResponse500) -> Any:
    return to_class(GetWorkspacesWorkspaceIDTagsResponse500, x)


def pan_element_created_from_dict(s: Any) -> PANElementCreated:
    return PANElementCreated.from_dict(s)


def pan_element_created_to_dict(x: PANElementCreated) -> Any:
    return to_class(PANElementCreated, x)


def pan_folder_created_from_dict(s: Any) -> PANFolderCreated:
    return PANFolderCreated.from_dict(s)


def pan_folder_created_to_dict(x: PANFolderCreated) -> Any:
    return to_class(PANFolderCreated, x)


def patch_collections_collection_id_body_from_dict(s: Any) -> PatchCollectionsCollectionIDBody:
    return PatchCollectionsCollectionIDBody.from_dict(s)


def patch_collections_collection_id_body_to_dict(x: PatchCollectionsCollectionIDBody) -> Any:
    return to_class(PatchCollectionsCollectionIDBody, x)


def patch_collections_collection_id_response_from_dict(s: Any) -> PatchCollectionsCollectionIDResponse:
    return PatchCollectionsCollectionIDResponse.from_dict(s)


def patch_collections_collection_id_response_to_dict(x: PatchCollectionsCollectionIDResponse) -> Any:
    return to_class(PatchCollectionsCollectionIDResponse, x)


def patch_collections_collection_id_response400_from_dict(s: Any) -> PatchCollectionsCollectionIDResponse400:
    return PatchCollectionsCollectionIDResponse400.from_dict(s)


def patch_collections_collection_id_response400_to_dict(x: PatchCollectionsCollectionIDResponse400) -> Any:
    return to_class(PatchCollectionsCollectionIDResponse400, x)


def patch_collections_collection_id_response401_from_dict(s: Any) -> PatchCollectionsCollectionIDResponse401:
    return PatchCollectionsCollectionIDResponse401.from_dict(s)


def patch_collections_collection_id_response401_to_dict(x: PatchCollectionsCollectionIDResponse401) -> Any:
    return to_class(PatchCollectionsCollectionIDResponse401, x)


def patch_collections_collection_id_response403_from_dict(s: Any) -> PatchCollectionsCollectionIDResponse403:
    return PatchCollectionsCollectionIDResponse403.from_dict(s)


def patch_collections_collection_id_response403_to_dict(x: PatchCollectionsCollectionIDResponse403) -> Any:
    return to_class(PatchCollectionsCollectionIDResponse403, x)


def patch_collections_collection_id_response404_from_dict(s: Any) -> PatchCollectionsCollectionIDResponse404:
    return PatchCollectionsCollectionIDResponse404.from_dict(s)


def patch_collections_collection_id_response404_to_dict(x: PatchCollectionsCollectionIDResponse404) -> Any:
    return to_class(PatchCollectionsCollectionIDResponse404, x)


def patch_collections_collection_id_response429_from_dict(s: Any) -> PatchCollectionsCollectionIDResponse429:
    return PatchCollectionsCollectionIDResponse429.from_dict(s)


def patch_collections_collection_id_response429_to_dict(x: PatchCollectionsCollectionIDResponse429) -> Any:
    return to_class(PatchCollectionsCollectionIDResponse429, x)


def patch_collections_collection_id_response500_from_dict(s: Any) -> PatchCollectionsCollectionIDResponse500:
    return PatchCollectionsCollectionIDResponse500.from_dict(s)


def patch_collections_collection_id_response500_to_dict(x: PatchCollectionsCollectionIDResponse500) -> Any:
    return to_class(PatchCollectionsCollectionIDResponse500, x)


def patch_scim_v2_groups_group_id_body_from_dict(s: Any) -> PatchScimV2GroupsGroupIDBody:
    return PatchScimV2GroupsGroupIDBody.from_dict(s)


def patch_scim_v2_groups_group_id_body_to_dict(x: PatchScimV2GroupsGroupIDBody) -> Any:
    return to_class(PatchScimV2GroupsGroupIDBody, x)


def patch_scim_v2_groups_group_id_response_from_dict(s: Any) -> PatchScimV2GroupsGroupIDResponse:
    return PatchScimV2GroupsGroupIDResponse.from_dict(s)


def patch_scim_v2_groups_group_id_response_to_dict(x: PatchScimV2GroupsGroupIDResponse) -> Any:
    return to_class(PatchScimV2GroupsGroupIDResponse, x)


def patch_scim_v2_groups_group_id_response400_from_dict(s: Any) -> PatchScimV2GroupsGroupIDResponse400:
    return PatchScimV2GroupsGroupIDResponse400.from_dict(s)


def patch_scim_v2_groups_group_id_response400_to_dict(x: PatchScimV2GroupsGroupIDResponse400) -> Any:
    return to_class(PatchScimV2GroupsGroupIDResponse400, x)


def patch_scim_v2_groups_group_id_response401_from_dict(s: Any) -> PatchScimV2GroupsGroupIDResponse401:
    return PatchScimV2GroupsGroupIDResponse401.from_dict(s)


def patch_scim_v2_groups_group_id_response401_to_dict(x: PatchScimV2GroupsGroupIDResponse401) -> Any:
    return to_class(PatchScimV2GroupsGroupIDResponse401, x)


def patch_scim_v2_groups_group_id_response403_from_dict(s: Any) -> PatchScimV2GroupsGroupIDResponse403:
    return PatchScimV2GroupsGroupIDResponse403.from_dict(s)


def patch_scim_v2_groups_group_id_response403_to_dict(x: PatchScimV2GroupsGroupIDResponse403) -> Any:
    return to_class(PatchScimV2GroupsGroupIDResponse403, x)


def patch_scim_v2_groups_group_id_response404_from_dict(s: Any) -> PatchScimV2GroupsGroupIDResponse404:
    return PatchScimV2GroupsGroupIDResponse404.from_dict(s)


def patch_scim_v2_groups_group_id_response404_to_dict(x: PatchScimV2GroupsGroupIDResponse404) -> Any:
    return to_class(PatchScimV2GroupsGroupIDResponse404, x)


def patch_scim_v2_groups_group_id_response429_from_dict(s: Any) -> PatchScimV2GroupsGroupIDResponse429:
    return PatchScimV2GroupsGroupIDResponse429.from_dict(s)


def patch_scim_v2_groups_group_id_response429_to_dict(x: PatchScimV2GroupsGroupIDResponse429) -> Any:
    return to_class(PatchScimV2GroupsGroupIDResponse429, x)


def patch_scim_v2_groups_group_id_response500_from_dict(s: Any) -> PatchScimV2GroupsGroupIDResponse500:
    return PatchScimV2GroupsGroupIDResponse500.from_dict(s)


def patch_scim_v2_groups_group_id_response500_to_dict(x: PatchScimV2GroupsGroupIDResponse500) -> Any:
    return to_class(PatchScimV2GroupsGroupIDResponse500, x)


def patch_scim_v2_users_user_id_body_from_dict(s: Any) -> PatchScimV2UsersUserIDBody:
    return PatchScimV2UsersUserIDBody.from_dict(s)


def patch_scim_v2_users_user_id_body_to_dict(x: PatchScimV2UsersUserIDBody) -> Any:
    return to_class(PatchScimV2UsersUserIDBody, x)


def patch_scim_v2_users_user_id_response_from_dict(s: Any) -> PatchScimV2UsersUserIDResponse:
    return PatchScimV2UsersUserIDResponse.from_dict(s)


def patch_scim_v2_users_user_id_response_to_dict(x: PatchScimV2UsersUserIDResponse) -> Any:
    return to_class(PatchScimV2UsersUserIDResponse, x)


def patch_scim_v2_users_user_id_response400_from_dict(s: Any) -> PatchScimV2UsersUserIDResponse400:
    return PatchScimV2UsersUserIDResponse400.from_dict(s)


def patch_scim_v2_users_user_id_response400_to_dict(x: PatchScimV2UsersUserIDResponse400) -> Any:
    return to_class(PatchScimV2UsersUserIDResponse400, x)


def patch_scim_v2_users_user_id_response401_from_dict(s: Any) -> PatchScimV2UsersUserIDResponse401:
    return PatchScimV2UsersUserIDResponse401.from_dict(s)


def patch_scim_v2_users_user_id_response401_to_dict(x: PatchScimV2UsersUserIDResponse401) -> Any:
    return to_class(PatchScimV2UsersUserIDResponse401, x)


def patch_scim_v2_users_user_id_response403_from_dict(s: Any) -> PatchScimV2UsersUserIDResponse403:
    return PatchScimV2UsersUserIDResponse403.from_dict(s)


def patch_scim_v2_users_user_id_response403_to_dict(x: PatchScimV2UsersUserIDResponse403) -> Any:
    return to_class(PatchScimV2UsersUserIDResponse403, x)


def patch_scim_v2_users_user_id_response404_from_dict(s: Any) -> PatchScimV2UsersUserIDResponse404:
    return PatchScimV2UsersUserIDResponse404.from_dict(s)


def patch_scim_v2_users_user_id_response404_to_dict(x: PatchScimV2UsersUserIDResponse404) -> Any:
    return to_class(PatchScimV2UsersUserIDResponse404, x)


def patch_scim_v2_users_user_id_response429_from_dict(s: Any) -> PatchScimV2UsersUserIDResponse429:
    return PatchScimV2UsersUserIDResponse429.from_dict(s)


def patch_scim_v2_users_user_id_response429_to_dict(x: PatchScimV2UsersUserIDResponse429) -> Any:
    return to_class(PatchScimV2UsersUserIDResponse429, x)


def patch_scim_v2_users_user_id_response500_from_dict(s: Any) -> PatchScimV2UsersUserIDResponse500:
    return PatchScimV2UsersUserIDResponse500.from_dict(s)


def patch_scim_v2_users_user_id_response500_to_dict(x: PatchScimV2UsersUserIDResponse500) -> Any:
    return to_class(PatchScimV2UsersUserIDResponse500, x)


def post_apis_apiid_collections_response_from_dict(s: Any) -> PostApisAPIIDCollectionsResponse:
    return PostApisAPIIDCollectionsResponse.from_dict(s)


def post_apis_apiid_collections_response_to_dict(x: PostApisAPIIDCollectionsResponse) -> Any:
    return to_class(PostApisAPIIDCollectionsResponse, x)


def post_apis_apiid_collections_response401_from_dict(s: Any) -> PostApisAPIIDCollectionsResponse401:
    return PostApisAPIIDCollectionsResponse401.from_dict(s)


def post_apis_apiid_collections_response401_to_dict(x: PostApisAPIIDCollectionsResponse401) -> Any:
    return to_class(PostApisAPIIDCollectionsResponse401, x)


def post_apis_apiid_collections_response403_from_dict(s: Any) -> PostApisAPIIDCollectionsResponse403:
    return PostApisAPIIDCollectionsResponse403.from_dict(s)


def post_apis_apiid_collections_response403_to_dict(x: PostApisAPIIDCollectionsResponse403) -> Any:
    return to_class(PostApisAPIIDCollectionsResponse403, x)


def post_apis_apiid_collections_response404_from_dict(s: Any) -> PostApisAPIIDCollectionsResponse404:
    return PostApisAPIIDCollectionsResponse404.from_dict(s)


def post_apis_apiid_collections_response404_to_dict(x: PostApisAPIIDCollectionsResponse404) -> Any:
    return to_class(PostApisAPIIDCollectionsResponse404, x)


def post_apis_apiid_collections_response500_from_dict(s: Any) -> PostApisAPIIDCollectionsResponse500:
    return PostApisAPIIDCollectionsResponse500.from_dict(s)


def post_apis_apiid_collections_response500_to_dict(x: PostApisAPIIDCollectionsResponse500) -> Any:
    return to_class(PostApisAPIIDCollectionsResponse500, x)


def post_apis_apiid_schemas_body_from_dict(s: Any) -> PostApisAPIIDSchemasBody:
    return PostApisAPIIDSchemasBody.from_dict(s)


def post_apis_apiid_schemas_body_to_dict(x: PostApisAPIIDSchemasBody) -> Any:
    return to_class(PostApisAPIIDSchemasBody, x)


def post_apis_apiid_schemas_response_from_dict(s: Any) -> PostApisAPIIDSchemasResponse:
    return PostApisAPIIDSchemasResponse.from_dict(s)


def post_apis_apiid_schemas_response_to_dict(x: PostApisAPIIDSchemasResponse) -> Any:
    return to_class(PostApisAPIIDSchemasResponse, x)


def post_apis_apiid_schemas_response400_from_dict(s: Any) -> PostApisAPIIDSchemasResponse400:
    return PostApisAPIIDSchemasResponse400.from_dict(s)


def post_apis_apiid_schemas_response400_to_dict(x: PostApisAPIIDSchemasResponse400) -> Any:
    return to_class(PostApisAPIIDSchemasResponse400, x)


def post_apis_apiid_schemas_response401_from_dict(s: Any) -> PostApisAPIIDSchemasResponse401:
    return PostApisAPIIDSchemasResponse401.from_dict(s)


def post_apis_apiid_schemas_response401_to_dict(x: PostApisAPIIDSchemasResponse401) -> Any:
    return to_class(PostApisAPIIDSchemasResponse401, x)


def post_apis_apiid_schemas_response403_from_dict(s: Any) -> PostApisAPIIDSchemasResponse403:
    return PostApisAPIIDSchemasResponse403.from_dict(s)


def post_apis_apiid_schemas_response403_to_dict(x: PostApisAPIIDSchemasResponse403) -> Any:
    return to_class(PostApisAPIIDSchemasResponse403, x)


def post_apis_apiid_schemas_response404_from_dict(s: Any) -> PostApisAPIIDSchemasResponse404:
    return PostApisAPIIDSchemasResponse404.from_dict(s)


def post_apis_apiid_schemas_response404_to_dict(x: PostApisAPIIDSchemasResponse404) -> Any:
    return to_class(PostApisAPIIDSchemasResponse404, x)


def post_apis_apiid_schemas_response422_from_dict(s: Any) -> PostApisAPIIDSchemasResponse422:
    return PostApisAPIIDSchemasResponse422.from_dict(s)


def post_apis_apiid_schemas_response422_to_dict(x: PostApisAPIIDSchemasResponse422) -> Any:
    return to_class(PostApisAPIIDSchemasResponse422, x)


def post_apis_apiid_schemas_response500_from_dict(s: Any) -> PostApisAPIIDSchemasResponse500:
    return PostApisAPIIDSchemasResponse500.from_dict(s)


def post_apis_apiid_schemas_response500_to_dict(x: PostApisAPIIDSchemasResponse500) -> Any:
    return to_class(PostApisAPIIDSchemasResponse500, x)


def post_apis_apiid_versions_response_from_dict(s: Any) -> PostApisAPIIDVersionsResponse:
    return PostApisAPIIDVersionsResponse.from_dict(s)


def post_apis_apiid_versions_response_to_dict(x: PostApisAPIIDVersionsResponse) -> Any:
    return to_class(PostApisAPIIDVersionsResponse, x)


def post_apis_apiid_versions_response401_from_dict(s: Any) -> PostApisAPIIDVersionsResponse401:
    return PostApisAPIIDVersionsResponse401.from_dict(s)


def post_apis_apiid_versions_response401_to_dict(x: PostApisAPIIDVersionsResponse401) -> Any:
    return to_class(PostApisAPIIDVersionsResponse401, x)


def post_apis_apiid_versions_response403_from_dict(s: Any) -> PostApisAPIIDVersionsResponse403:
    return PostApisAPIIDVersionsResponse403.from_dict(s)


def post_apis_apiid_versions_response403_to_dict(x: PostApisAPIIDVersionsResponse403) -> Any:
    return to_class(PostApisAPIIDVersionsResponse403, x)


def post_apis_apiid_versions_response404_from_dict(s: Any) -> PostApisAPIIDVersionsResponse404:
    return PostApisAPIIDVersionsResponse404.from_dict(s)


def post_apis_apiid_versions_response404_to_dict(x: PostApisAPIIDVersionsResponse404) -> Any:
    return to_class(PostApisAPIIDVersionsResponse404, x)


def post_apis_apiid_versions_response422_from_dict(s: Any) -> PostApisAPIIDVersionsResponse422:
    return PostApisAPIIDVersionsResponse422.from_dict(s)


def post_apis_apiid_versions_response422_to_dict(x: PostApisAPIIDVersionsResponse422) -> Any:
    return to_class(PostApisAPIIDVersionsResponse422, x)


def post_apis_apiid_versions_response500_from_dict(s: Any) -> PostApisAPIIDVersionsResponse500:
    return PostApisAPIIDVersionsResponse500.from_dict(s)


def post_apis_apiid_versions_response500_to_dict(x: PostApisAPIIDVersionsResponse500) -> Any:
    return to_class(PostApisAPIIDVersionsResponse500, x)


def post_apis_body_from_dict(s: Any) -> PostApisBody:
    return PostApisBody.from_dict(s)


def post_apis_body_to_dict(x: PostApisBody) -> Any:
    return to_class(PostApisBody, x)


def post_apis_response_from_dict(s: Any) -> PostApisResponse:
    return PostApisResponse.from_dict(s)


def post_apis_response_to_dict(x: PostApisResponse) -> Any:
    return to_class(PostApisResponse, x)


def post_apis_response400_from_dict(s: Any) -> PostApisResponse400:
    return PostApisResponse400.from_dict(s)


def post_apis_response400_to_dict(x: PostApisResponse400) -> Any:
    return to_class(PostApisResponse400, x)


def post_apis_response401_from_dict(s: Any) -> PostApisResponse401:
    return PostApisResponse401.from_dict(s)


def post_apis_response401_to_dict(x: PostApisResponse401) -> Any:
    return to_class(PostApisResponse401, x)


def post_apis_response403_from_dict(s: Any) -> PostApisResponse403:
    return PostApisResponse403.from_dict(s)


def post_apis_response403_to_dict(x: PostApisResponse403) -> Any:
    return to_class(PostApisResponse403, x)


def post_apis_response404_from_dict(s: Any) -> PostApisResponse404:
    return PostApisResponse404.from_dict(s)


def post_apis_response404_to_dict(x: PostApisResponse404) -> Any:
    return to_class(PostApisResponse404, x)


def post_apis_response500_from_dict(s: Any) -> PostApisResponse500:
    return PostApisResponse500.from_dict(s)


def post_apis_response500_to_dict(x: PostApisResponse500) -> Any:
    return to_class(PostApisResponse500, x)


def post_collections_body_from_dict(s: Any) -> PostCollectionsBody:
    return PostCollectionsBody.from_dict(s)


def post_collections_body_to_dict(x: PostCollectionsBody) -> Any:
    return to_class(PostCollectionsBody, x)


def post_collections_collection_id_folders_body_from_dict(s: Any) -> PostCollectionsCollectionIDFoldersBody:
    return PostCollectionsCollectionIDFoldersBody.from_dict(s)


def post_collections_collection_id_folders_body_to_dict(x: PostCollectionsCollectionIDFoldersBody) -> Any:
    return to_class(PostCollectionsCollectionIDFoldersBody, x)


def post_collections_collection_id_folders_response_from_dict(s: Any) -> PostCollectionsCollectionIDFoldersResponse:
    return PostCollectionsCollectionIDFoldersResponse.from_dict(s)


def post_collections_collection_id_folders_response_to_dict(x: PostCollectionsCollectionIDFoldersResponse) -> Any:
    return to_class(PostCollectionsCollectionIDFoldersResponse, x)


def post_collections_collection_id_folders_response400_from_dict(s: Any) -> PostCollectionsCollectionIDFoldersResponse400:
    return PostCollectionsCollectionIDFoldersResponse400.from_dict(s)


def post_collections_collection_id_folders_response400_to_dict(x: PostCollectionsCollectionIDFoldersResponse400) -> Any:
    return to_class(PostCollectionsCollectionIDFoldersResponse400, x)


def post_collections_collection_id_folders_response401_from_dict(s: Any) -> PostCollectionsCollectionIDFoldersResponse401:
    return PostCollectionsCollectionIDFoldersResponse401.from_dict(s)


def post_collections_collection_id_folders_response401_to_dict(x: PostCollectionsCollectionIDFoldersResponse401) -> Any:
    return to_class(PostCollectionsCollectionIDFoldersResponse401, x)


def post_collections_collection_id_folders_response500_from_dict(s: Any) -> PostCollectionsCollectionIDFoldersResponse500:
    return PostCollectionsCollectionIDFoldersResponse500.from_dict(s)


def post_collections_collection_id_folders_response500_to_dict(x: PostCollectionsCollectionIDFoldersResponse500) -> Any:
    return to_class(PostCollectionsCollectionIDFoldersResponse500, x)


def post_collections_collection_id_requests_body_from_dict(s: Any) -> PostCollectionsCollectionIDRequestsBody:
    return PostCollectionsCollectionIDRequestsBody.from_dict(s)


def post_collections_collection_id_requests_body_to_dict(x: PostCollectionsCollectionIDRequestsBody) -> Any:
    return to_class(PostCollectionsCollectionIDRequestsBody, x)


def post_collections_collection_id_requests_response_from_dict(s: Any) -> PostCollectionsCollectionIDRequestsResponse:
    return PostCollectionsCollectionIDRequestsResponse.from_dict(s)


def post_collections_collection_id_requests_response_to_dict(x: PostCollectionsCollectionIDRequestsResponse) -> Any:
    return to_class(PostCollectionsCollectionIDRequestsResponse, x)


def post_collections_collection_id_requests_response400_from_dict(s: Any) -> PostCollectionsCollectionIDRequestsResponse400:
    return PostCollectionsCollectionIDRequestsResponse400.from_dict(s)


def post_collections_collection_id_requests_response400_to_dict(x: PostCollectionsCollectionIDRequestsResponse400) -> Any:
    return to_class(PostCollectionsCollectionIDRequestsResponse400, x)


def post_collections_collection_id_requests_response401_from_dict(s: Any) -> PostCollectionsCollectionIDRequestsResponse401:
    return PostCollectionsCollectionIDRequestsResponse401.from_dict(s)


def post_collections_collection_id_requests_response401_to_dict(x: PostCollectionsCollectionIDRequestsResponse401) -> Any:
    return to_class(PostCollectionsCollectionIDRequestsResponse401, x)


def post_collections_collection_id_requests_response500_from_dict(s: Any) -> PostCollectionsCollectionIDRequestsResponse500:
    return PostCollectionsCollectionIDRequestsResponse500.from_dict(s)


def post_collections_collection_id_requests_response500_to_dict(x: PostCollectionsCollectionIDRequestsResponse500) -> Any:
    return to_class(PostCollectionsCollectionIDRequestsResponse500, x)


def post_collections_collection_id_responses_body_from_dict(s: Any) -> PostCollectionsCollectionIDResponsesBody:
    return PostCollectionsCollectionIDResponsesBody.from_dict(s)


def post_collections_collection_id_responses_body_to_dict(x: PostCollectionsCollectionIDResponsesBody) -> Any:
    return to_class(PostCollectionsCollectionIDResponsesBody, x)


def post_collections_collection_id_responses_response_from_dict(s: Any) -> PostCollectionsCollectionIDResponsesResponse:
    return PostCollectionsCollectionIDResponsesResponse.from_dict(s)


def post_collections_collection_id_responses_response_to_dict(x: PostCollectionsCollectionIDResponsesResponse) -> Any:
    return to_class(PostCollectionsCollectionIDResponsesResponse, x)


def post_collections_collection_id_responses_response400_from_dict(s: Any) -> PostCollectionsCollectionIDResponsesResponse400:
    return PostCollectionsCollectionIDResponsesResponse400.from_dict(s)


def post_collections_collection_id_responses_response400_to_dict(x: PostCollectionsCollectionIDResponsesResponse400) -> Any:
    return to_class(PostCollectionsCollectionIDResponsesResponse400, x)


def post_collections_collection_id_responses_response401_from_dict(s: Any) -> PostCollectionsCollectionIDResponsesResponse401:
    return PostCollectionsCollectionIDResponsesResponse401.from_dict(s)


def post_collections_collection_id_responses_response401_to_dict(x: PostCollectionsCollectionIDResponsesResponse401) -> Any:
    return to_class(PostCollectionsCollectionIDResponsesResponse401, x)


def post_collections_collection_id_responses_response500_from_dict(s: Any) -> PostCollectionsCollectionIDResponsesResponse500:
    return PostCollectionsCollectionIDResponsesResponse500.from_dict(s)


def post_collections_collection_id_responses_response500_to_dict(x: PostCollectionsCollectionIDResponsesResponse500) -> Any:
    return to_class(PostCollectionsCollectionIDResponsesResponse500, x)


def post_collections_fork_collection_id_body_from_dict(s: Any) -> PostCollectionsForkCollectionIDBody:
    return PostCollectionsForkCollectionIDBody.from_dict(s)


def post_collections_fork_collection_id_body_to_dict(x: PostCollectionsForkCollectionIDBody) -> Any:
    return to_class(PostCollectionsForkCollectionIDBody, x)


def post_collections_fork_collection_id_response_from_dict(s: Any) -> PostCollectionsForkCollectionIDResponse:
    return PostCollectionsForkCollectionIDResponse.from_dict(s)


def post_collections_fork_collection_id_response_to_dict(x: PostCollectionsForkCollectionIDResponse) -> Any:
    return to_class(PostCollectionsForkCollectionIDResponse, x)


def post_collections_fork_collection_id_response401_from_dict(s: Any) -> PostCollectionsForkCollectionIDResponse401:
    return PostCollectionsForkCollectionIDResponse401.from_dict(s)


def post_collections_fork_collection_id_response401_to_dict(x: PostCollectionsForkCollectionIDResponse401) -> Any:
    return to_class(PostCollectionsForkCollectionIDResponse401, x)


def post_collections_fork_collection_id_response404_from_dict(s: Any) -> PostCollectionsForkCollectionIDResponse404:
    return PostCollectionsForkCollectionIDResponse404.from_dict(s)


def post_collections_fork_collection_id_response404_to_dict(x: PostCollectionsForkCollectionIDResponse404) -> Any:
    return to_class(PostCollectionsForkCollectionIDResponse404, x)


def post_collections_fork_collection_id_response429_from_dict(s: Any) -> PostCollectionsForkCollectionIDResponse429:
    return PostCollectionsForkCollectionIDResponse429.from_dict(s)


def post_collections_fork_collection_id_response429_to_dict(x: PostCollectionsForkCollectionIDResponse429) -> Any:
    return to_class(PostCollectionsForkCollectionIDResponse429, x)


def post_collections_fork_collection_id_response500_from_dict(s: Any) -> PostCollectionsForkCollectionIDResponse500:
    return PostCollectionsForkCollectionIDResponse500.from_dict(s)


def post_collections_fork_collection_id_response500_to_dict(x: PostCollectionsForkCollectionIDResponse500) -> Any:
    return to_class(PostCollectionsForkCollectionIDResponse500, x)


def post_collections_merge_body_from_dict(s: Any) -> PostCollectionsMergeBody:
    return PostCollectionsMergeBody.from_dict(s)


def post_collections_merge_body_to_dict(x: PostCollectionsMergeBody) -> Any:
    return to_class(PostCollectionsMergeBody, x)


def post_collections_merge_response_from_dict(s: Any) -> PostCollectionsMergeResponse:
    return PostCollectionsMergeResponse.from_dict(s)


def post_collections_merge_response_to_dict(x: PostCollectionsMergeResponse) -> Any:
    return to_class(PostCollectionsMergeResponse, x)


def post_collections_merge_response401_from_dict(s: Any) -> PostCollectionsMergeResponse401:
    return PostCollectionsMergeResponse401.from_dict(s)


def post_collections_merge_response401_to_dict(x: PostCollectionsMergeResponse401) -> Any:
    return to_class(PostCollectionsMergeResponse401, x)


def post_collections_merge_response404_from_dict(s: Any) -> PostCollectionsMergeResponse404:
    return PostCollectionsMergeResponse404.from_dict(s)


def post_collections_merge_response404_to_dict(x: PostCollectionsMergeResponse404) -> Any:
    return to_class(PostCollectionsMergeResponse404, x)


def post_collections_merge_response429_from_dict(s: Any) -> PostCollectionsMergeResponse429:
    return PostCollectionsMergeResponse429.from_dict(s)


def post_collections_merge_response429_to_dict(x: PostCollectionsMergeResponse429) -> Any:
    return to_class(PostCollectionsMergeResponse429, x)


def post_collections_merge_response500_from_dict(s: Any) -> PostCollectionsMergeResponse500:
    return PostCollectionsMergeResponse500.from_dict(s)


def post_collections_merge_response500_to_dict(x: PostCollectionsMergeResponse500) -> Any:
    return to_class(PostCollectionsMergeResponse500, x)


def post_collections_response_from_dict(s: Any) -> PostCollectionsResponse:
    return PostCollectionsResponse.from_dict(s)


def post_collections_response_to_dict(x: PostCollectionsResponse) -> Any:
    return to_class(PostCollectionsResponse, x)


def post_collections_response400_from_dict(s: Any) -> PostCollectionsResponse400:
    return PostCollectionsResponse400.from_dict(s)


def post_collections_response400_to_dict(x: PostCollectionsResponse400) -> Any:
    return to_class(PostCollectionsResponse400, x)


def post_collections_response401_from_dict(s: Any) -> PostCollectionsResponse401:
    return PostCollectionsResponse401.from_dict(s)


def post_collections_response401_to_dict(x: PostCollectionsResponse401) -> Any:
    return to_class(PostCollectionsResponse401, x)


def post_collections_response429_from_dict(s: Any) -> PostCollectionsResponse429:
    return PostCollectionsResponse429.from_dict(s)


def post_collections_response429_to_dict(x: PostCollectionsResponse429) -> Any:
    return to_class(PostCollectionsResponse429, x)


def post_collections_response500_from_dict(s: Any) -> PostCollectionsResponse500:
    return PostCollectionsResponse500.from_dict(s)


def post_collections_response500_to_dict(x: PostCollectionsResponse500) -> Any:
    return to_class(PostCollectionsResponse500, x)


def post_detected_secrets_queries_body_from_dict(s: Any) -> PostDetectedSecretsQueriesBody:
    return PostDetectedSecretsQueriesBody.from_dict(s)


def post_detected_secrets_queries_body_to_dict(x: PostDetectedSecretsQueriesBody) -> Any:
    return to_class(PostDetectedSecretsQueriesBody, x)


def post_detected_secrets_queries_response_from_dict(s: Any) -> PostDetectedSecretsQueriesResponse:
    return PostDetectedSecretsQueriesResponse.from_dict(s)


def post_detected_secrets_queries_response_to_dict(x: PostDetectedSecretsQueriesResponse) -> Any:
    return to_class(PostDetectedSecretsQueriesResponse, x)


def post_detected_secrets_queries_response400_from_dict(s: Any) -> PostDetectedSecretsQueriesResponse400:
    return PostDetectedSecretsQueriesResponse400.from_dict(s)


def post_detected_secrets_queries_response400_to_dict(x: PostDetectedSecretsQueriesResponse400) -> Any:
    return to_class(PostDetectedSecretsQueriesResponse400, x)


def post_detected_secrets_queries_response401_from_dict(s: Any) -> PostDetectedSecretsQueriesResponse401:
    return PostDetectedSecretsQueriesResponse401.from_dict(s)


def post_detected_secrets_queries_response401_to_dict(x: PostDetectedSecretsQueriesResponse401) -> Any:
    return to_class(PostDetectedSecretsQueriesResponse401, x)


def post_detected_secrets_queries_response403_from_dict(s: Any) -> PostDetectedSecretsQueriesResponse403:
    return PostDetectedSecretsQueriesResponse403.from_dict(s)


def post_detected_secrets_queries_response403_to_dict(x: PostDetectedSecretsQueriesResponse403) -> Any:
    return to_class(PostDetectedSecretsQueriesResponse403, x)


def post_detected_secrets_queries_response500_from_dict(s: Any) -> PostDetectedSecretsQueriesResponse500:
    return PostDetectedSecretsQueriesResponse500.from_dict(s)


def post_detected_secrets_queries_response500_to_dict(x: PostDetectedSecretsQueriesResponse500) -> Any:
    return to_class(PostDetectedSecretsQueriesResponse500, x)


def post_environments_body_from_dict(s: Any) -> PostEnvironmentsBody:
    return PostEnvironmentsBody.from_dict(s)


def post_environments_body_to_dict(x: PostEnvironmentsBody) -> Any:
    return to_class(PostEnvironmentsBody, x)


def post_environments_response_from_dict(s: Any) -> PostEnvironmentsResponse:
    return PostEnvironmentsResponse.from_dict(s)


def post_environments_response_to_dict(x: PostEnvironmentsResponse) -> Any:
    return to_class(PostEnvironmentsResponse, x)


def post_environments_response400_from_dict(s: Any) -> PostEnvironmentsResponse400:
    return PostEnvironmentsResponse400.from_dict(s)


def post_environments_response400_to_dict(x: PostEnvironmentsResponse400) -> Any:
    return to_class(PostEnvironmentsResponse400, x)


def post_environments_response401_from_dict(s: Any) -> PostEnvironmentsResponse401:
    return PostEnvironmentsResponse401.from_dict(s)


def post_environments_response401_to_dict(x: PostEnvironmentsResponse401) -> Any:
    return to_class(PostEnvironmentsResponse401, x)


def post_environments_response403_from_dict(s: Any) -> PostEnvironmentsResponse403:
    return PostEnvironmentsResponse403.from_dict(s)


def post_environments_response403_to_dict(x: PostEnvironmentsResponse403) -> Any:
    return to_class(PostEnvironmentsResponse403, x)


def post_environments_response429_from_dict(s: Any) -> PostEnvironmentsResponse429:
    return PostEnvironmentsResponse429.from_dict(s)


def post_environments_response429_to_dict(x: PostEnvironmentsResponse429) -> Any:
    return to_class(PostEnvironmentsResponse429, x)


def post_environments_response500_from_dict(s: Any) -> PostEnvironmentsResponse500:
    return PostEnvironmentsResponse500.from_dict(s)


def post_environments_response500_to_dict(x: PostEnvironmentsResponse500) -> Any:
    return to_class(PostEnvironmentsResponse500, x)


def post_import_openapi_response_from_dict(s: Any) -> PostImportOpenapiResponse:
    return PostImportOpenapiResponse.from_dict(s)


def post_import_openapi_response_to_dict(x: PostImportOpenapiResponse) -> Any:
    return to_class(PostImportOpenapiResponse, x)


def post_import_openapi_response400_from_dict(s: Any) -> PostImportOpenapiResponse400:
    return PostImportOpenapiResponse400.from_dict(s)


def post_import_openapi_response400_to_dict(x: PostImportOpenapiResponse400) -> Any:
    return to_class(PostImportOpenapiResponse400, x)


def post_import_openapi_response401_from_dict(s: Any) -> PostImportOpenapiResponse401:
    return PostImportOpenapiResponse401.from_dict(s)


def post_import_openapi_response401_to_dict(x: PostImportOpenapiResponse401) -> Any:
    return to_class(PostImportOpenapiResponse401, x)


def post_import_openapi_response429_from_dict(s: Any) -> PostImportOpenapiResponse429:
    return PostImportOpenapiResponse429.from_dict(s)


def post_import_openapi_response429_to_dict(x: PostImportOpenapiResponse429) -> Any:
    return to_class(PostImportOpenapiResponse429, x)


def post_import_openapi_response500_from_dict(s: Any) -> PostImportOpenapiResponse500:
    return PostImportOpenapiResponse500.from_dict(s)


def post_import_openapi_response500_to_dict(x: PostImportOpenapiResponse500) -> Any:
    return to_class(PostImportOpenapiResponse500, x)


def post_mocks_body_from_dict(s: Any) -> PostMocksBody:
    return PostMocksBody.from_dict(s)


def post_mocks_body_to_dict(x: PostMocksBody) -> Any:
    return to_class(PostMocksBody, x)


def post_mocks_mock_id_publish_response_from_dict(s: Any) -> PostMocksMockIDPublishResponse:
    return PostMocksMockIDPublishResponse.from_dict(s)


def post_mocks_mock_id_publish_response_to_dict(x: PostMocksMockIDPublishResponse) -> Any:
    return to_class(PostMocksMockIDPublishResponse, x)


def post_mocks_mock_id_publish_response400_from_dict(s: Any) -> PostMocksMockIDPublishResponse400:
    return PostMocksMockIDPublishResponse400.from_dict(s)


def post_mocks_mock_id_publish_response400_to_dict(x: PostMocksMockIDPublishResponse400) -> Any:
    return to_class(PostMocksMockIDPublishResponse400, x)


def post_mocks_mock_id_publish_response401_from_dict(s: Any) -> PostMocksMockIDPublishResponse401:
    return PostMocksMockIDPublishResponse401.from_dict(s)


def post_mocks_mock_id_publish_response401_to_dict(x: PostMocksMockIDPublishResponse401) -> Any:
    return to_class(PostMocksMockIDPublishResponse401, x)


def post_mocks_mock_id_publish_response404_from_dict(s: Any) -> PostMocksMockIDPublishResponse404:
    return PostMocksMockIDPublishResponse404.from_dict(s)


def post_mocks_mock_id_publish_response404_to_dict(x: PostMocksMockIDPublishResponse404) -> Any:
    return to_class(PostMocksMockIDPublishResponse404, x)


def post_mocks_mock_id_publish_response429_from_dict(s: Any) -> PostMocksMockIDPublishResponse429:
    return PostMocksMockIDPublishResponse429.from_dict(s)


def post_mocks_mock_id_publish_response429_to_dict(x: PostMocksMockIDPublishResponse429) -> Any:
    return to_class(PostMocksMockIDPublishResponse429, x)


def post_mocks_mock_id_publish_response500_from_dict(s: Any) -> PostMocksMockIDPublishResponse500:
    return PostMocksMockIDPublishResponse500.from_dict(s)


def post_mocks_mock_id_publish_response500_to_dict(x: PostMocksMockIDPublishResponse500) -> Any:
    return to_class(PostMocksMockIDPublishResponse500, x)


def post_mocks_mock_id_server_responses_body_from_dict(s: Any) -> PostMocksMockIDServerResponsesBody:
    return PostMocksMockIDServerResponsesBody.from_dict(s)


def post_mocks_mock_id_server_responses_body_to_dict(x: PostMocksMockIDServerResponsesBody) -> Any:
    return to_class(PostMocksMockIDServerResponsesBody, x)


def post_mocks_mock_id_server_responses_response400_from_dict(s: Any) -> PostMocksMockIDServerResponsesResponse400:
    return PostMocksMockIDServerResponsesResponse400.from_dict(s)


def post_mocks_mock_id_server_responses_response400_to_dict(x: PostMocksMockIDServerResponsesResponse400) -> Any:
    return to_class(PostMocksMockIDServerResponsesResponse400, x)


def post_mocks_mock_id_server_responses_response401_from_dict(s: Any) -> PostMocksMockIDServerResponsesResponse401:
    return PostMocksMockIDServerResponsesResponse401.from_dict(s)


def post_mocks_mock_id_server_responses_response401_to_dict(x: PostMocksMockIDServerResponsesResponse401) -> Any:
    return to_class(PostMocksMockIDServerResponsesResponse401, x)


def post_mocks_mock_id_server_responses_response429_from_dict(s: Any) -> PostMocksMockIDServerResponsesResponse429:
    return PostMocksMockIDServerResponsesResponse429.from_dict(s)


def post_mocks_mock_id_server_responses_response429_to_dict(x: PostMocksMockIDServerResponsesResponse429) -> Any:
    return to_class(PostMocksMockIDServerResponsesResponse429, x)


def post_mocks_mock_id_server_responses_response500_from_dict(s: Any) -> PostMocksMockIDServerResponsesResponse500:
    return PostMocksMockIDServerResponsesResponse500.from_dict(s)


def post_mocks_mock_id_server_responses_response500_to_dict(x: PostMocksMockIDServerResponsesResponse500) -> Any:
    return to_class(PostMocksMockIDServerResponsesResponse500, x)


def post_mocks_mock_id_server_responses_response_item_from_dict(s: Any) -> PostMocksMockIDServerResponsesResponseItem:
    return PostMocksMockIDServerResponsesResponseItem.from_dict(s)


def post_mocks_mock_id_server_responses_response_item_to_dict(x: PostMocksMockIDServerResponsesResponseItem) -> Any:
    return to_class(PostMocksMockIDServerResponsesResponseItem, x)


def post_mocks_response_from_dict(s: Any) -> PostMocksResponse:
    return PostMocksResponse.from_dict(s)


def post_mocks_response_to_dict(x: PostMocksResponse) -> Any:
    return to_class(PostMocksResponse, x)


def post_mocks_response400_from_dict(s: Any) -> PostMocksResponse400:
    return PostMocksResponse400.from_dict(s)


def post_mocks_response400_to_dict(x: PostMocksResponse400) -> Any:
    return to_class(PostMocksResponse400, x)


def post_mocks_response401_from_dict(s: Any) -> PostMocksResponse401:
    return PostMocksResponse401.from_dict(s)


def post_mocks_response401_to_dict(x: PostMocksResponse401) -> Any:
    return to_class(PostMocksResponse401, x)


def post_mocks_response429_from_dict(s: Any) -> PostMocksResponse429:
    return PostMocksResponse429.from_dict(s)


def post_mocks_response429_to_dict(x: PostMocksResponse429) -> Any:
    return to_class(PostMocksResponse429, x)


def post_mocks_response500_from_dict(s: Any) -> PostMocksResponse500:
    return PostMocksResponse500.from_dict(s)


def post_mocks_response500_to_dict(x: PostMocksResponse500) -> Any:
    return to_class(PostMocksResponse500, x)


def post_monitors_body_from_dict(s: Any) -> PostMonitorsBody:
    return PostMonitorsBody.from_dict(s)


def post_monitors_body_to_dict(x: PostMonitorsBody) -> Any:
    return to_class(PostMonitorsBody, x)


def post_monitors_monitor_id_run_response_from_dict(s: Any) -> PostMonitorsMonitorIDRunResponse:
    return PostMonitorsMonitorIDRunResponse.from_dict(s)


def post_monitors_monitor_id_run_response_to_dict(x: PostMonitorsMonitorIDRunResponse) -> Any:
    return to_class(PostMonitorsMonitorIDRunResponse, x)


def post_monitors_monitor_id_run_response401_from_dict(s: Any) -> PostMonitorsMonitorIDRunResponse401:
    return PostMonitorsMonitorIDRunResponse401.from_dict(s)


def post_monitors_monitor_id_run_response401_to_dict(x: PostMonitorsMonitorIDRunResponse401) -> Any:
    return to_class(PostMonitorsMonitorIDRunResponse401, x)


def post_monitors_monitor_id_run_response429_from_dict(s: Any) -> PostMonitorsMonitorIDRunResponse429:
    return PostMonitorsMonitorIDRunResponse429.from_dict(s)


def post_monitors_monitor_id_run_response429_to_dict(x: PostMonitorsMonitorIDRunResponse429) -> Any:
    return to_class(PostMonitorsMonitorIDRunResponse429, x)


def post_monitors_monitor_id_run_response500_from_dict(s: Any) -> PostMonitorsMonitorIDRunResponse500:
    return PostMonitorsMonitorIDRunResponse500.from_dict(s)


def post_monitors_monitor_id_run_response500_to_dict(x: PostMonitorsMonitorIDRunResponse500) -> Any:
    return to_class(PostMonitorsMonitorIDRunResponse500, x)


def post_monitors_response_from_dict(s: Any) -> PostMonitorsResponse:
    return PostMonitorsResponse.from_dict(s)


def post_monitors_response_to_dict(x: PostMonitorsResponse) -> Any:
    return to_class(PostMonitorsResponse, x)


def post_monitors_response400_from_dict(s: Any) -> PostMonitorsResponse400:
    return PostMonitorsResponse400.from_dict(s)


def post_monitors_response400_to_dict(x: PostMonitorsResponse400) -> Any:
    return to_class(PostMonitorsResponse400, x)


def post_monitors_response401_from_dict(s: Any) -> PostMonitorsResponse401:
    return PostMonitorsResponse401.from_dict(s)


def post_monitors_response401_to_dict(x: PostMonitorsResponse401) -> Any:
    return to_class(PostMonitorsResponse401, x)


def post_monitors_response403_from_dict(s: Any) -> PostMonitorsResponse403:
    return PostMonitorsResponse403.from_dict(s)


def post_monitors_response403_to_dict(x: PostMonitorsResponse403) -> Any:
    return to_class(PostMonitorsResponse403, x)


def post_monitors_response429_from_dict(s: Any) -> PostMonitorsResponse429:
    return PostMonitorsResponse429.from_dict(s)


def post_monitors_response429_to_dict(x: PostMonitorsResponse429) -> Any:
    return to_class(PostMonitorsResponse429, x)


def post_monitors_response500_from_dict(s: Any) -> PostMonitorsResponse500:
    return PostMonitorsResponse500.from_dict(s)


def post_monitors_response500_to_dict(x: PostMonitorsResponse500) -> Any:
    return to_class(PostMonitorsResponse500, x)


def post_network_private_response401_from_dict(s: Any) -> PostNetworkPrivateResponse401:
    return PostNetworkPrivateResponse401.from_dict(s)


def post_network_private_response401_to_dict(x: PostNetworkPrivateResponse401) -> Any:
    return to_class(PostNetworkPrivateResponse401, x)


def post_network_private_response403_from_dict(s: Any) -> PostNetworkPrivateResponse403:
    return PostNetworkPrivateResponse403.from_dict(s)


def post_network_private_response403_to_dict(x: PostNetworkPrivateResponse403) -> Any:
    return to_class(PostNetworkPrivateResponse403, x)


def post_network_private_response404_from_dict(s: Any) -> PostNetworkPrivateResponse404:
    return PostNetworkPrivateResponse404.from_dict(s)


def post_network_private_response404_to_dict(x: PostNetworkPrivateResponse404) -> Any:
    return to_class(PostNetworkPrivateResponse404, x)


def post_network_private_response429_from_dict(s: Any) -> PostNetworkPrivateResponse429:
    return PostNetworkPrivateResponse429.from_dict(s)


def post_network_private_response429_to_dict(x: PostNetworkPrivateResponse429) -> Any:
    return to_class(PostNetworkPrivateResponse429, x)


def post_network_private_response500_from_dict(s: Any) -> PostNetworkPrivateResponse500:
    return PostNetworkPrivateResponse500.from_dict(s)


def post_network_private_response500_to_dict(x: PostNetworkPrivateResponse500) -> Any:
    return to_class(PostNetworkPrivateResponse500, x)


def post_scim_v2_groups_body_from_dict(s: Any) -> PostScimV2GroupsBody:
    return PostScimV2GroupsBody.from_dict(s)


def post_scim_v2_groups_body_to_dict(x: PostScimV2GroupsBody) -> Any:
    return to_class(PostScimV2GroupsBody, x)


def post_scim_v2_groups_response_from_dict(s: Any) -> PostScimV2GroupsResponse:
    return PostScimV2GroupsResponse.from_dict(s)


def post_scim_v2_groups_response_to_dict(x: PostScimV2GroupsResponse) -> Any:
    return to_class(PostScimV2GroupsResponse, x)


def post_scim_v2_groups_response400_from_dict(s: Any) -> PostScimV2GroupsResponse400:
    return PostScimV2GroupsResponse400.from_dict(s)


def post_scim_v2_groups_response400_to_dict(x: PostScimV2GroupsResponse400) -> Any:
    return to_class(PostScimV2GroupsResponse400, x)


def post_scim_v2_groups_response401_from_dict(s: Any) -> PostScimV2GroupsResponse401:
    return PostScimV2GroupsResponse401.from_dict(s)


def post_scim_v2_groups_response401_to_dict(x: PostScimV2GroupsResponse401) -> Any:
    return to_class(PostScimV2GroupsResponse401, x)


def post_scim_v2_groups_response403_from_dict(s: Any) -> PostScimV2GroupsResponse403:
    return PostScimV2GroupsResponse403.from_dict(s)


def post_scim_v2_groups_response403_to_dict(x: PostScimV2GroupsResponse403) -> Any:
    return to_class(PostScimV2GroupsResponse403, x)


def post_scim_v2_groups_response409_from_dict(s: Any) -> PostScimV2GroupsResponse409:
    return PostScimV2GroupsResponse409.from_dict(s)


def post_scim_v2_groups_response409_to_dict(x: PostScimV2GroupsResponse409) -> Any:
    return to_class(PostScimV2GroupsResponse409, x)


def post_scim_v2_groups_response429_from_dict(s: Any) -> PostScimV2GroupsResponse429:
    return PostScimV2GroupsResponse429.from_dict(s)


def post_scim_v2_groups_response429_to_dict(x: PostScimV2GroupsResponse429) -> Any:
    return to_class(PostScimV2GroupsResponse429, x)


def post_scim_v2_groups_response500_from_dict(s: Any) -> PostScimV2GroupsResponse500:
    return PostScimV2GroupsResponse500.from_dict(s)


def post_scim_v2_groups_response500_to_dict(x: PostScimV2GroupsResponse500) -> Any:
    return to_class(PostScimV2GroupsResponse500, x)


def post_scim_v2_users_body_from_dict(s: Any) -> PostScimV2UsersBody:
    return PostScimV2UsersBody.from_dict(s)


def post_scim_v2_users_body_to_dict(x: PostScimV2UsersBody) -> Any:
    return to_class(PostScimV2UsersBody, x)


def post_scim_v2_users_response_from_dict(s: Any) -> PostScimV2UsersResponse:
    return PostScimV2UsersResponse.from_dict(s)


def post_scim_v2_users_response_to_dict(x: PostScimV2UsersResponse) -> Any:
    return to_class(PostScimV2UsersResponse, x)


def post_scim_v2_users_response400_from_dict(s: Any) -> PostScimV2UsersResponse400:
    return PostScimV2UsersResponse400.from_dict(s)


def post_scim_v2_users_response400_to_dict(x: PostScimV2UsersResponse400) -> Any:
    return to_class(PostScimV2UsersResponse400, x)


def post_scim_v2_users_response401_from_dict(s: Any) -> PostScimV2UsersResponse401:
    return PostScimV2UsersResponse401.from_dict(s)


def post_scim_v2_users_response401_to_dict(x: PostScimV2UsersResponse401) -> Any:
    return to_class(PostScimV2UsersResponse401, x)


def post_scim_v2_users_response403_from_dict(s: Any) -> PostScimV2UsersResponse403:
    return PostScimV2UsersResponse403.from_dict(s)


def post_scim_v2_users_response403_to_dict(x: PostScimV2UsersResponse403) -> Any:
    return to_class(PostScimV2UsersResponse403, x)


def post_scim_v2_users_response409_from_dict(s: Any) -> PostScimV2UsersResponse409:
    return PostScimV2UsersResponse409.from_dict(s)


def post_scim_v2_users_response409_to_dict(x: PostScimV2UsersResponse409) -> Any:
    return to_class(PostScimV2UsersResponse409, x)


def post_scim_v2_users_response429_from_dict(s: Any) -> PostScimV2UsersResponse429:
    return PostScimV2UsersResponse429.from_dict(s)


def post_scim_v2_users_response429_to_dict(x: PostScimV2UsersResponse429) -> Any:
    return to_class(PostScimV2UsersResponse429, x)


def post_scim_v2_users_response500_from_dict(s: Any) -> PostScimV2UsersResponse500:
    return PostScimV2UsersResponse500.from_dict(s)


def post_scim_v2_users_response500_to_dict(x: PostScimV2UsersResponse500) -> Any:
    return to_class(PostScimV2UsersResponse500, x)


def post_security_api_validation_body_from_dict(s: Any) -> PostSecurityAPIValidationBody:
    return PostSecurityAPIValidationBody.from_dict(s)


def post_security_api_validation_body_to_dict(x: PostSecurityAPIValidationBody) -> Any:
    return to_class(PostSecurityAPIValidationBody, x)


def post_security_api_validation_response_from_dict(s: Any) -> PostSecurityAPIValidationResponse:
    return PostSecurityAPIValidationResponse.from_dict(s)


def post_security_api_validation_response_to_dict(x: PostSecurityAPIValidationResponse) -> Any:
    return to_class(PostSecurityAPIValidationResponse, x)


def post_security_api_validation_response400_from_dict(s: Any) -> PostSecurityAPIValidationResponse400:
    return PostSecurityAPIValidationResponse400.from_dict(s)


def post_security_api_validation_response400_to_dict(x: PostSecurityAPIValidationResponse400) -> Any:
    return to_class(PostSecurityAPIValidationResponse400, x)


def post_security_api_validation_response401_from_dict(s: Any) -> PostSecurityAPIValidationResponse401:
    return PostSecurityAPIValidationResponse401.from_dict(s)


def post_security_api_validation_response401_to_dict(x: PostSecurityAPIValidationResponse401) -> Any:
    return to_class(PostSecurityAPIValidationResponse401, x)


def post_security_api_validation_response429_from_dict(s: Any) -> PostSecurityAPIValidationResponse429:
    return PostSecurityAPIValidationResponse429.from_dict(s)


def post_security_api_validation_response429_to_dict(x: PostSecurityAPIValidationResponse429) -> Any:
    return to_class(PostSecurityAPIValidationResponse429, x)


def post_security_api_validation_response500_from_dict(s: Any) -> PostSecurityAPIValidationResponse500:
    return PostSecurityAPIValidationResponse500.from_dict(s)


def post_security_api_validation_response500_to_dict(x: PostSecurityAPIValidationResponse500) -> Any:
    return to_class(PostSecurityAPIValidationResponse500, x)


def post_webhooks_body_from_dict(s: Any) -> PostWebhooksBody:
    return PostWebhooksBody.from_dict(s)


def post_webhooks_body_to_dict(x: PostWebhooksBody) -> Any:
    return to_class(PostWebhooksBody, x)


def post_webhooks_response_from_dict(s: Any) -> PostWebhooksResponse:
    return PostWebhooksResponse.from_dict(s)


def post_webhooks_response_to_dict(x: PostWebhooksResponse) -> Any:
    return to_class(PostWebhooksResponse, x)


def post_webhooks_response401_from_dict(s: Any) -> PostWebhooksResponse401:
    return PostWebhooksResponse401.from_dict(s)


def post_webhooks_response401_to_dict(x: PostWebhooksResponse401) -> Any:
    return to_class(PostWebhooksResponse401, x)


def post_webhooks_response429_from_dict(s: Any) -> PostWebhooksResponse429:
    return PostWebhooksResponse429.from_dict(s)


def post_webhooks_response429_to_dict(x: PostWebhooksResponse429) -> Any:
    return to_class(PostWebhooksResponse429, x)


def post_webhooks_response500_from_dict(s: Any) -> PostWebhooksResponse500:
    return PostWebhooksResponse500.from_dict(s)


def post_webhooks_response500_to_dict(x: PostWebhooksResponse500) -> Any:
    return to_class(PostWebhooksResponse500, x)


def post_workspaces_body_from_dict(s: Any) -> PostWorkspacesBody:
    return PostWorkspacesBody.from_dict(s)


def post_workspaces_body_to_dict(x: PostWorkspacesBody) -> Any:
    return to_class(PostWorkspacesBody, x)


def post_workspaces_response_from_dict(s: Any) -> PostWorkspacesResponse:
    return PostWorkspacesResponse.from_dict(s)


def post_workspaces_response_to_dict(x: PostWorkspacesResponse) -> Any:
    return to_class(PostWorkspacesResponse, x)


def post_workspaces_response400_from_dict(s: Any) -> PostWorkspacesResponse400:
    return PostWorkspacesResponse400.from_dict(s)


def post_workspaces_response400_to_dict(x: PostWorkspacesResponse400) -> Any:
    return to_class(PostWorkspacesResponse400, x)


def post_workspaces_response401_from_dict(s: Any) -> PostWorkspacesResponse401:
    return PostWorkspacesResponse401.from_dict(s)


def post_workspaces_response401_to_dict(x: PostWorkspacesResponse401) -> Any:
    return to_class(PostWorkspacesResponse401, x)


def post_workspaces_response404_from_dict(s: Any) -> PostWorkspacesResponse404:
    return PostWorkspacesResponse404.from_dict(s)


def post_workspaces_response404_to_dict(x: PostWorkspacesResponse404) -> Any:
    return to_class(PostWorkspacesResponse404, x)


def post_workspaces_response429_from_dict(s: Any) -> PostWorkspacesResponse429:
    return PostWorkspacesResponse429.from_dict(s)


def post_workspaces_response429_to_dict(x: PostWorkspacesResponse429) -> Any:
    return to_class(PostWorkspacesResponse429, x)


def post_workspaces_response500_from_dict(s: Any) -> PostWorkspacesResponse500:
    return PostWorkspacesResponse500.from_dict(s)


def post_workspaces_response500_to_dict(x: PostWorkspacesResponse500) -> Any:
    return to_class(PostWorkspacesResponse500, x)


def put_apis_apiid_body_from_dict(s: Any) -> PutApisAPIIDBody:
    return PutApisAPIIDBody.from_dict(s)


def put_apis_apiid_body_to_dict(x: PutApisAPIIDBody) -> Any:
    return to_class(PutApisAPIIDBody, x)


def put_apis_apiid_collections_collection_id_sync_with_schema_tasks_response_from_dict(s: Any) -> PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse:
    return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse.from_dict(s)


def put_apis_apiid_collections_collection_id_sync_with_schema_tasks_response_to_dict(x: PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse) -> Any:
    return to_class(PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse, x)


def put_apis_apiid_collections_collection_id_sync_with_schema_tasks_response400_from_dict(s: Any) -> PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse400:
    return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse400.from_dict(s)


def put_apis_apiid_collections_collection_id_sync_with_schema_tasks_response400_to_dict(x: PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse400) -> Any:
    return to_class(PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse400, x)


def put_apis_apiid_collections_collection_id_sync_with_schema_tasks_response401_from_dict(s: Any) -> PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse401:
    return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse401.from_dict(s)


def put_apis_apiid_collections_collection_id_sync_with_schema_tasks_response401_to_dict(x: PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse401) -> Any:
    return to_class(PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse401, x)


def put_apis_apiid_collections_collection_id_sync_with_schema_tasks_response403_from_dict(s: Any) -> PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse403:
    return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse403.from_dict(s)


def put_apis_apiid_collections_collection_id_sync_with_schema_tasks_response403_to_dict(x: PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse403) -> Any:
    return to_class(PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse403, x)


def put_apis_apiid_collections_collection_id_sync_with_schema_tasks_response404_from_dict(s: Any) -> PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse404:
    return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse404.from_dict(s)


def put_apis_apiid_collections_collection_id_sync_with_schema_tasks_response404_to_dict(x: PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse404) -> Any:
    return to_class(PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse404, x)


def put_apis_apiid_collections_collection_id_sync_with_schema_tasks_response422_from_dict(s: Any) -> PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse422:
    return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse422.from_dict(s)


def put_apis_apiid_collections_collection_id_sync_with_schema_tasks_response422_to_dict(x: PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse422) -> Any:
    return to_class(PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse422, x)


def put_apis_apiid_response_from_dict(s: Any) -> PutApisAPIIDResponse:
    return PutApisAPIIDResponse.from_dict(s)


def put_apis_apiid_response_to_dict(x: PutApisAPIIDResponse) -> Any:
    return to_class(PutApisAPIIDResponse, x)


def put_apis_apiid_response401_from_dict(s: Any) -> PutApisAPIIDResponse401:
    return PutApisAPIIDResponse401.from_dict(s)


def put_apis_apiid_response401_to_dict(x: PutApisAPIIDResponse401) -> Any:
    return to_class(PutApisAPIIDResponse401, x)


def put_apis_apiid_response403_from_dict(s: Any) -> PutApisAPIIDResponse403:
    return PutApisAPIIDResponse403.from_dict(s)


def put_apis_apiid_response403_to_dict(x: PutApisAPIIDResponse403) -> Any:
    return to_class(PutApisAPIIDResponse403, x)


def put_apis_apiid_response404_from_dict(s: Any) -> PutApisAPIIDResponse404:
    return PutApisAPIIDResponse404.from_dict(s)


def put_apis_apiid_response404_to_dict(x: PutApisAPIIDResponse404) -> Any:
    return to_class(PutApisAPIIDResponse404, x)


def put_apis_apiid_response422_from_dict(s: Any) -> PutApisAPIIDResponse422:
    return PutApisAPIIDResponse422.from_dict(s)


def put_apis_apiid_response422_to_dict(x: PutApisAPIIDResponse422) -> Any:
    return to_class(PutApisAPIIDResponse422, x)


def put_apis_apiid_response500_from_dict(s: Any) -> PutApisAPIIDResponse500:
    return PutApisAPIIDResponse500.from_dict(s)


def put_apis_apiid_response500_to_dict(x: PutApisAPIIDResponse500) -> Any:
    return to_class(PutApisAPIIDResponse500, x)


def put_apis_apiid_schemas_schema_id_files_file_path_body_from_dict(s: Any) -> PutApisAPIIDSchemasSchemaIDFilesFilePathBody:
    return PutApisAPIIDSchemasSchemaIDFilesFilePathBody.from_dict(s)


def put_apis_apiid_schemas_schema_id_files_file_path_body_to_dict(x: PutApisAPIIDSchemasSchemaIDFilesFilePathBody) -> Any:
    return to_class(PutApisAPIIDSchemasSchemaIDFilesFilePathBody, x)


def put_apis_apiid_schemas_schema_id_files_file_path_response_from_dict(s: Any) -> PutApisAPIIDSchemasSchemaIDFilesFilePathResponse:
    return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse.from_dict(s)


def put_apis_apiid_schemas_schema_id_files_file_path_response_to_dict(x: PutApisAPIIDSchemasSchemaIDFilesFilePathResponse) -> Any:
    return to_class(PutApisAPIIDSchemasSchemaIDFilesFilePathResponse, x)


def put_apis_apiid_schemas_schema_id_files_file_path_response400_from_dict(s: Any) -> PutApisAPIIDSchemasSchemaIDFilesFilePathResponse400:
    return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse400.from_dict(s)


def put_apis_apiid_schemas_schema_id_files_file_path_response400_to_dict(x: PutApisAPIIDSchemasSchemaIDFilesFilePathResponse400) -> Any:
    return to_class(PutApisAPIIDSchemasSchemaIDFilesFilePathResponse400, x)


def put_apis_apiid_schemas_schema_id_files_file_path_response401_from_dict(s: Any) -> PutApisAPIIDSchemasSchemaIDFilesFilePathResponse401:
    return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse401.from_dict(s)


def put_apis_apiid_schemas_schema_id_files_file_path_response401_to_dict(x: PutApisAPIIDSchemasSchemaIDFilesFilePathResponse401) -> Any:
    return to_class(PutApisAPIIDSchemasSchemaIDFilesFilePathResponse401, x)


def put_apis_apiid_schemas_schema_id_files_file_path_response403_from_dict(s: Any) -> PutApisAPIIDSchemasSchemaIDFilesFilePathResponse403:
    return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse403.from_dict(s)


def put_apis_apiid_schemas_schema_id_files_file_path_response403_to_dict(x: PutApisAPIIDSchemasSchemaIDFilesFilePathResponse403) -> Any:
    return to_class(PutApisAPIIDSchemasSchemaIDFilesFilePathResponse403, x)


def put_apis_apiid_schemas_schema_id_files_file_path_response404_from_dict(s: Any) -> PutApisAPIIDSchemasSchemaIDFilesFilePathResponse404:
    return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse404.from_dict(s)


def put_apis_apiid_schemas_schema_id_files_file_path_response404_to_dict(x: PutApisAPIIDSchemasSchemaIDFilesFilePathResponse404) -> Any:
    return to_class(PutApisAPIIDSchemasSchemaIDFilesFilePathResponse404, x)


def put_apis_apiid_schemas_schema_id_files_file_path_response422_from_dict(s: Any) -> PutApisAPIIDSchemasSchemaIDFilesFilePathResponse422:
    return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse422.from_dict(s)


def put_apis_apiid_schemas_schema_id_files_file_path_response422_to_dict(x: PutApisAPIIDSchemasSchemaIDFilesFilePathResponse422) -> Any:
    return to_class(PutApisAPIIDSchemasSchemaIDFilesFilePathResponse422, x)


def put_apis_apiid_schemas_schema_id_files_file_path_response500_from_dict(s: Any) -> PutApisAPIIDSchemasSchemaIDFilesFilePathResponse500:
    return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse500.from_dict(s)


def put_apis_apiid_schemas_schema_id_files_file_path_response500_to_dict(x: PutApisAPIIDSchemasSchemaIDFilesFilePathResponse500) -> Any:
    return to_class(PutApisAPIIDSchemasSchemaIDFilesFilePathResponse500, x)


def put_apis_apiid_tags_body_from_dict(s: Any) -> PutApisAPIIDTagsBody:
    return PutApisAPIIDTagsBody.from_dict(s)


def put_apis_apiid_tags_body_to_dict(x: PutApisAPIIDTagsBody) -> Any:
    return to_class(PutApisAPIIDTagsBody, x)


def put_apis_apiid_tags_response_from_dict(s: Any) -> PutApisAPIIDTagsResponse:
    return PutApisAPIIDTagsResponse.from_dict(s)


def put_apis_apiid_tags_response_to_dict(x: PutApisAPIIDTagsResponse) -> Any:
    return to_class(PutApisAPIIDTagsResponse, x)


def put_apis_apiid_tags_response400_from_dict(s: Any) -> PutApisAPIIDTagsResponse400:
    return PutApisAPIIDTagsResponse400.from_dict(s)


def put_apis_apiid_tags_response400_to_dict(x: PutApisAPIIDTagsResponse400) -> Any:
    return to_class(PutApisAPIIDTagsResponse400, x)


def put_apis_apiid_tags_response401_from_dict(s: Any) -> PutApisAPIIDTagsResponse401:
    return PutApisAPIIDTagsResponse401.from_dict(s)


def put_apis_apiid_tags_response401_to_dict(x: PutApisAPIIDTagsResponse401) -> Any:
    return to_class(PutApisAPIIDTagsResponse401, x)


def put_apis_apiid_tags_response403_from_dict(s: Any) -> PutApisAPIIDTagsResponse403:
    return PutApisAPIIDTagsResponse403.from_dict(s)


def put_apis_apiid_tags_response403_to_dict(x: PutApisAPIIDTagsResponse403) -> Any:
    return to_class(PutApisAPIIDTagsResponse403, x)


def put_apis_apiid_tags_response500_from_dict(s: Any) -> PutApisAPIIDTagsResponse500:
    return PutApisAPIIDTagsResponse500.from_dict(s)


def put_apis_apiid_tags_response500_to_dict(x: PutApisAPIIDTagsResponse500) -> Any:
    return to_class(PutApisAPIIDTagsResponse500, x)


def put_apis_apiid_versions_version_id_body_from_dict(s: Any) -> PutApisAPIIDVersionsVersionIDBody:
    return PutApisAPIIDVersionsVersionIDBody.from_dict(s)


def put_apis_apiid_versions_version_id_body_to_dict(x: PutApisAPIIDVersionsVersionIDBody) -> Any:
    return to_class(PutApisAPIIDVersionsVersionIDBody, x)


def put_apis_apiid_versions_version_id_response_from_dict(s: Any) -> PutApisAPIIDVersionsVersionIDResponse:
    return PutApisAPIIDVersionsVersionIDResponse.from_dict(s)


def put_apis_apiid_versions_version_id_response_to_dict(x: PutApisAPIIDVersionsVersionIDResponse) -> Any:
    return to_class(PutApisAPIIDVersionsVersionIDResponse, x)


def put_apis_apiid_versions_version_id_response401_from_dict(s: Any) -> PutApisAPIIDVersionsVersionIDResponse401:
    return PutApisAPIIDVersionsVersionIDResponse401.from_dict(s)


def put_apis_apiid_versions_version_id_response401_to_dict(x: PutApisAPIIDVersionsVersionIDResponse401) -> Any:
    return to_class(PutApisAPIIDVersionsVersionIDResponse401, x)


def put_apis_apiid_versions_version_id_response403_from_dict(s: Any) -> PutApisAPIIDVersionsVersionIDResponse403:
    return PutApisAPIIDVersionsVersionIDResponse403.from_dict(s)


def put_apis_apiid_versions_version_id_response403_to_dict(x: PutApisAPIIDVersionsVersionIDResponse403) -> Any:
    return to_class(PutApisAPIIDVersionsVersionIDResponse403, x)


def put_apis_apiid_versions_version_id_response404_from_dict(s: Any) -> PutApisAPIIDVersionsVersionIDResponse404:
    return PutApisAPIIDVersionsVersionIDResponse404.from_dict(s)


def put_apis_apiid_versions_version_id_response404_to_dict(x: PutApisAPIIDVersionsVersionIDResponse404) -> Any:
    return to_class(PutApisAPIIDVersionsVersionIDResponse404, x)


def put_apis_apiid_versions_version_id_response500_from_dict(s: Any) -> PutApisAPIIDVersionsVersionIDResponse500:
    return PutApisAPIIDVersionsVersionIDResponse500.from_dict(s)


def put_apis_apiid_versions_version_id_response500_to_dict(x: PutApisAPIIDVersionsVersionIDResponse500) -> Any:
    return to_class(PutApisAPIIDVersionsVersionIDResponse500, x)


def put_collections_collection_id_body_from_dict(s: Any) -> PutCollectionsCollectionIDBody:
    return PutCollectionsCollectionIDBody.from_dict(s)


def put_collections_collection_id_body_to_dict(x: PutCollectionsCollectionIDBody) -> Any:
    return to_class(PutCollectionsCollectionIDBody, x)


def put_collections_collection_id_folders_folder_id_body_from_dict(s: Any) -> PutCollectionsCollectionIDFoldersFolderIDBody:
    return PutCollectionsCollectionIDFoldersFolderIDBody.from_dict(s)


def put_collections_collection_id_folders_folder_id_body_to_dict(x: PutCollectionsCollectionIDFoldersFolderIDBody) -> Any:
    return to_class(PutCollectionsCollectionIDFoldersFolderIDBody, x)


def put_collections_collection_id_folders_folder_id_response_from_dict(s: Any) -> PutCollectionsCollectionIDFoldersFolderIDResponse:
    return PutCollectionsCollectionIDFoldersFolderIDResponse.from_dict(s)


def put_collections_collection_id_folders_folder_id_response_to_dict(x: PutCollectionsCollectionIDFoldersFolderIDResponse) -> Any:
    return to_class(PutCollectionsCollectionIDFoldersFolderIDResponse, x)


def put_collections_collection_id_folders_folder_id_response400_from_dict(s: Any) -> PutCollectionsCollectionIDFoldersFolderIDResponse400:
    return PutCollectionsCollectionIDFoldersFolderIDResponse400.from_dict(s)


def put_collections_collection_id_folders_folder_id_response400_to_dict(x: PutCollectionsCollectionIDFoldersFolderIDResponse400) -> Any:
    return to_class(PutCollectionsCollectionIDFoldersFolderIDResponse400, x)


def put_collections_collection_id_folders_folder_id_response401_from_dict(s: Any) -> PutCollectionsCollectionIDFoldersFolderIDResponse401:
    return PutCollectionsCollectionIDFoldersFolderIDResponse401.from_dict(s)


def put_collections_collection_id_folders_folder_id_response401_to_dict(x: PutCollectionsCollectionIDFoldersFolderIDResponse401) -> Any:
    return to_class(PutCollectionsCollectionIDFoldersFolderIDResponse401, x)


def put_collections_collection_id_folders_folder_id_response404_from_dict(s: Any) -> PutCollectionsCollectionIDFoldersFolderIDResponse404:
    return PutCollectionsCollectionIDFoldersFolderIDResponse404.from_dict(s)


def put_collections_collection_id_folders_folder_id_response404_to_dict(x: PutCollectionsCollectionIDFoldersFolderIDResponse404) -> Any:
    return to_class(PutCollectionsCollectionIDFoldersFolderIDResponse404, x)


def put_collections_collection_id_folders_folder_id_response500_from_dict(s: Any) -> PutCollectionsCollectionIDFoldersFolderIDResponse500:
    return PutCollectionsCollectionIDFoldersFolderIDResponse500.from_dict(s)


def put_collections_collection_id_folders_folder_id_response500_to_dict(x: PutCollectionsCollectionIDFoldersFolderIDResponse500) -> Any:
    return to_class(PutCollectionsCollectionIDFoldersFolderIDResponse500, x)


def put_collections_collection_id_requests_request_id_body_from_dict(s: Any) -> PutCollectionsCollectionIDRequestsRequestIDBody:
    return PutCollectionsCollectionIDRequestsRequestIDBody.from_dict(s)


def put_collections_collection_id_requests_request_id_body_to_dict(x: PutCollectionsCollectionIDRequestsRequestIDBody) -> Any:
    return to_class(PutCollectionsCollectionIDRequestsRequestIDBody, x)


def put_collections_collection_id_requests_request_id_response_from_dict(s: Any) -> PutCollectionsCollectionIDRequestsRequestIDResponse:
    return PutCollectionsCollectionIDRequestsRequestIDResponse.from_dict(s)


def put_collections_collection_id_requests_request_id_response_to_dict(x: PutCollectionsCollectionIDRequestsRequestIDResponse) -> Any:
    return to_class(PutCollectionsCollectionIDRequestsRequestIDResponse, x)


def put_collections_collection_id_requests_request_id_response400_from_dict(s: Any) -> PutCollectionsCollectionIDRequestsRequestIDResponse400:
    return PutCollectionsCollectionIDRequestsRequestIDResponse400.from_dict(s)


def put_collections_collection_id_requests_request_id_response400_to_dict(x: PutCollectionsCollectionIDRequestsRequestIDResponse400) -> Any:
    return to_class(PutCollectionsCollectionIDRequestsRequestIDResponse400, x)


def put_collections_collection_id_requests_request_id_response401_from_dict(s: Any) -> PutCollectionsCollectionIDRequestsRequestIDResponse401:
    return PutCollectionsCollectionIDRequestsRequestIDResponse401.from_dict(s)


def put_collections_collection_id_requests_request_id_response401_to_dict(x: PutCollectionsCollectionIDRequestsRequestIDResponse401) -> Any:
    return to_class(PutCollectionsCollectionIDRequestsRequestIDResponse401, x)


def put_collections_collection_id_requests_request_id_response404_from_dict(s: Any) -> PutCollectionsCollectionIDRequestsRequestIDResponse404:
    return PutCollectionsCollectionIDRequestsRequestIDResponse404.from_dict(s)


def put_collections_collection_id_requests_request_id_response404_to_dict(x: PutCollectionsCollectionIDRequestsRequestIDResponse404) -> Any:
    return to_class(PutCollectionsCollectionIDRequestsRequestIDResponse404, x)


def put_collections_collection_id_requests_request_id_response500_from_dict(s: Any) -> PutCollectionsCollectionIDRequestsRequestIDResponse500:
    return PutCollectionsCollectionIDRequestsRequestIDResponse500.from_dict(s)


def put_collections_collection_id_requests_request_id_response500_to_dict(x: PutCollectionsCollectionIDRequestsRequestIDResponse500) -> Any:
    return to_class(PutCollectionsCollectionIDRequestsRequestIDResponse500, x)


def put_collections_collection_id_response_from_dict(s: Any) -> PutCollectionsCollectionIDResponse:
    return PutCollectionsCollectionIDResponse.from_dict(s)


def put_collections_collection_id_response_to_dict(x: PutCollectionsCollectionIDResponse) -> Any:
    return to_class(PutCollectionsCollectionIDResponse, x)


def put_collections_collection_id_response400_from_dict(s: Any) -> PutCollectionsCollectionIDResponse400:
    return PutCollectionsCollectionIDResponse400.from_dict(s)


def put_collections_collection_id_response400_to_dict(x: PutCollectionsCollectionIDResponse400) -> Any:
    return to_class(PutCollectionsCollectionIDResponse400, x)


def put_collections_collection_id_response401_from_dict(s: Any) -> PutCollectionsCollectionIDResponse401:
    return PutCollectionsCollectionIDResponse401.from_dict(s)


def put_collections_collection_id_response401_to_dict(x: PutCollectionsCollectionIDResponse401) -> Any:
    return to_class(PutCollectionsCollectionIDResponse401, x)


def put_collections_collection_id_response403_from_dict(s: Any) -> PutCollectionsCollectionIDResponse403:
    return PutCollectionsCollectionIDResponse403.from_dict(s)


def put_collections_collection_id_response403_to_dict(x: PutCollectionsCollectionIDResponse403) -> Any:
    return to_class(PutCollectionsCollectionIDResponse403, x)


def put_collections_collection_id_response404_from_dict(s: Any) -> PutCollectionsCollectionIDResponse404:
    return PutCollectionsCollectionIDResponse404.from_dict(s)


def put_collections_collection_id_response404_to_dict(x: PutCollectionsCollectionIDResponse404) -> Any:
    return to_class(PutCollectionsCollectionIDResponse404, x)


def put_collections_collection_id_response429_from_dict(s: Any) -> PutCollectionsCollectionIDResponse429:
    return PutCollectionsCollectionIDResponse429.from_dict(s)


def put_collections_collection_id_response429_to_dict(x: PutCollectionsCollectionIDResponse429) -> Any:
    return to_class(PutCollectionsCollectionIDResponse429, x)


def put_collections_collection_id_response500_from_dict(s: Any) -> PutCollectionsCollectionIDResponse500:
    return PutCollectionsCollectionIDResponse500.from_dict(s)


def put_collections_collection_id_response500_to_dict(x: PutCollectionsCollectionIDResponse500) -> Any:
    return to_class(PutCollectionsCollectionIDResponse500, x)


def put_collections_collection_id_responses_response_id_body_from_dict(s: Any) -> PutCollectionsCollectionIDResponsesResponseIDBody:
    return PutCollectionsCollectionIDResponsesResponseIDBody.from_dict(s)


def put_collections_collection_id_responses_response_id_body_to_dict(x: PutCollectionsCollectionIDResponsesResponseIDBody) -> Any:
    return to_class(PutCollectionsCollectionIDResponsesResponseIDBody, x)


def put_collections_collection_id_responses_response_id_response_from_dict(s: Any) -> PutCollectionsCollectionIDResponsesResponseIDResponse:
    return PutCollectionsCollectionIDResponsesResponseIDResponse.from_dict(s)


def put_collections_collection_id_responses_response_id_response_to_dict(x: PutCollectionsCollectionIDResponsesResponseIDResponse) -> Any:
    return to_class(PutCollectionsCollectionIDResponsesResponseIDResponse, x)


def put_collections_collection_id_responses_response_id_response400_from_dict(s: Any) -> PutCollectionsCollectionIDResponsesResponseIDResponse400:
    return PutCollectionsCollectionIDResponsesResponseIDResponse400.from_dict(s)


def put_collections_collection_id_responses_response_id_response400_to_dict(x: PutCollectionsCollectionIDResponsesResponseIDResponse400) -> Any:
    return to_class(PutCollectionsCollectionIDResponsesResponseIDResponse400, x)


def put_collections_collection_id_responses_response_id_response401_from_dict(s: Any) -> PutCollectionsCollectionIDResponsesResponseIDResponse401:
    return PutCollectionsCollectionIDResponsesResponseIDResponse401.from_dict(s)


def put_collections_collection_id_responses_response_id_response401_to_dict(x: PutCollectionsCollectionIDResponsesResponseIDResponse401) -> Any:
    return to_class(PutCollectionsCollectionIDResponsesResponseIDResponse401, x)


def put_collections_collection_id_responses_response_id_response404_from_dict(s: Any) -> PutCollectionsCollectionIDResponsesResponseIDResponse404:
    return PutCollectionsCollectionIDResponsesResponseIDResponse404.from_dict(s)


def put_collections_collection_id_responses_response_id_response404_to_dict(x: PutCollectionsCollectionIDResponsesResponseIDResponse404) -> Any:
    return to_class(PutCollectionsCollectionIDResponsesResponseIDResponse404, x)


def put_collections_collection_id_responses_response_id_response500_from_dict(s: Any) -> PutCollectionsCollectionIDResponsesResponseIDResponse500:
    return PutCollectionsCollectionIDResponsesResponseIDResponse500.from_dict(s)


def put_collections_collection_id_responses_response_id_response500_to_dict(x: PutCollectionsCollectionIDResponsesResponseIDResponse500) -> Any:
    return to_class(PutCollectionsCollectionIDResponsesResponseIDResponse500, x)


def put_collections_collection_id_tags_body_from_dict(s: Any) -> PutCollectionsCollectionIDTagsBody:
    return PutCollectionsCollectionIDTagsBody.from_dict(s)


def put_collections_collection_id_tags_body_to_dict(x: PutCollectionsCollectionIDTagsBody) -> Any:
    return to_class(PutCollectionsCollectionIDTagsBody, x)


def put_collections_collection_id_tags_response_from_dict(s: Any) -> PutCollectionsCollectionIDTagsResponse:
    return PutCollectionsCollectionIDTagsResponse.from_dict(s)


def put_collections_collection_id_tags_response_to_dict(x: PutCollectionsCollectionIDTagsResponse) -> Any:
    return to_class(PutCollectionsCollectionIDTagsResponse, x)


def put_collections_collection_id_tags_response400_from_dict(s: Any) -> PutCollectionsCollectionIDTagsResponse400:
    return PutCollectionsCollectionIDTagsResponse400.from_dict(s)


def put_collections_collection_id_tags_response400_to_dict(x: PutCollectionsCollectionIDTagsResponse400) -> Any:
    return to_class(PutCollectionsCollectionIDTagsResponse400, x)


def put_collections_collection_id_tags_response401_from_dict(s: Any) -> PutCollectionsCollectionIDTagsResponse401:
    return PutCollectionsCollectionIDTagsResponse401.from_dict(s)


def put_collections_collection_id_tags_response401_to_dict(x: PutCollectionsCollectionIDTagsResponse401) -> Any:
    return to_class(PutCollectionsCollectionIDTagsResponse401, x)


def put_collections_collection_id_tags_response403_from_dict(s: Any) -> PutCollectionsCollectionIDTagsResponse403:
    return PutCollectionsCollectionIDTagsResponse403.from_dict(s)


def put_collections_collection_id_tags_response403_to_dict(x: PutCollectionsCollectionIDTagsResponse403) -> Any:
    return to_class(PutCollectionsCollectionIDTagsResponse403, x)


def put_collections_collection_id_tags_response404_from_dict(s: Any) -> PutCollectionsCollectionIDTagsResponse404:
    return PutCollectionsCollectionIDTagsResponse404.from_dict(s)


def put_collections_collection_id_tags_response404_to_dict(x: PutCollectionsCollectionIDTagsResponse404) -> Any:
    return to_class(PutCollectionsCollectionIDTagsResponse404, x)


def put_collections_collection_id_tags_response500_from_dict(s: Any) -> PutCollectionsCollectionIDTagsResponse500:
    return PutCollectionsCollectionIDTagsResponse500.from_dict(s)


def put_collections_collection_id_tags_response500_to_dict(x: PutCollectionsCollectionIDTagsResponse500) -> Any:
    return to_class(PutCollectionsCollectionIDTagsResponse500, x)


def put_detected_secrets_secret_id_body_from_dict(s: Any) -> PutDetectedSecretsSecretIDBody:
    return PutDetectedSecretsSecretIDBody.from_dict(s)


def put_detected_secrets_secret_id_body_to_dict(x: PutDetectedSecretsSecretIDBody) -> Any:
    return to_class(PutDetectedSecretsSecretIDBody, x)


def put_detected_secrets_secret_id_response_from_dict(s: Any) -> PutDetectedSecretsSecretIDResponse:
    return PutDetectedSecretsSecretIDResponse.from_dict(s)


def put_detected_secrets_secret_id_response_to_dict(x: PutDetectedSecretsSecretIDResponse) -> Any:
    return to_class(PutDetectedSecretsSecretIDResponse, x)


def put_detected_secrets_secret_id_response401_from_dict(s: Any) -> PutDetectedSecretsSecretIDResponse401:
    return PutDetectedSecretsSecretIDResponse401.from_dict(s)


def put_detected_secrets_secret_id_response401_to_dict(x: PutDetectedSecretsSecretIDResponse401) -> Any:
    return to_class(PutDetectedSecretsSecretIDResponse401, x)


def put_detected_secrets_secret_id_response403_from_dict(s: Any) -> PutDetectedSecretsSecretIDResponse403:
    return PutDetectedSecretsSecretIDResponse403.from_dict(s)


def put_detected_secrets_secret_id_response403_to_dict(x: PutDetectedSecretsSecretIDResponse403) -> Any:
    return to_class(PutDetectedSecretsSecretIDResponse403, x)


def put_detected_secrets_secret_id_response500_from_dict(s: Any) -> PutDetectedSecretsSecretIDResponse500:
    return PutDetectedSecretsSecretIDResponse500.from_dict(s)


def put_detected_secrets_secret_id_response500_to_dict(x: PutDetectedSecretsSecretIDResponse500) -> Any:
    return to_class(PutDetectedSecretsSecretIDResponse500, x)


def put_environments_environment_id_body_from_dict(s: Any) -> PutEnvironmentsEnvironmentIDBody:
    return PutEnvironmentsEnvironmentIDBody.from_dict(s)


def put_environments_environment_id_body_to_dict(x: PutEnvironmentsEnvironmentIDBody) -> Any:
    return to_class(PutEnvironmentsEnvironmentIDBody, x)


def put_environments_environment_id_response_from_dict(s: Any) -> PutEnvironmentsEnvironmentIDResponse:
    return PutEnvironmentsEnvironmentIDResponse.from_dict(s)


def put_environments_environment_id_response_to_dict(x: PutEnvironmentsEnvironmentIDResponse) -> Any:
    return to_class(PutEnvironmentsEnvironmentIDResponse, x)


def put_environments_environment_id_response400_from_dict(s: Any) -> PutEnvironmentsEnvironmentIDResponse400:
    return PutEnvironmentsEnvironmentIDResponse400.from_dict(s)


def put_environments_environment_id_response400_to_dict(x: PutEnvironmentsEnvironmentIDResponse400) -> Any:
    return to_class(PutEnvironmentsEnvironmentIDResponse400, x)


def put_environments_environment_id_response401_from_dict(s: Any) -> PutEnvironmentsEnvironmentIDResponse401:
    return PutEnvironmentsEnvironmentIDResponse401.from_dict(s)


def put_environments_environment_id_response401_to_dict(x: PutEnvironmentsEnvironmentIDResponse401) -> Any:
    return to_class(PutEnvironmentsEnvironmentIDResponse401, x)


def put_environments_environment_id_response429_from_dict(s: Any) -> PutEnvironmentsEnvironmentIDResponse429:
    return PutEnvironmentsEnvironmentIDResponse429.from_dict(s)


def put_environments_environment_id_response429_to_dict(x: PutEnvironmentsEnvironmentIDResponse429) -> Any:
    return to_class(PutEnvironmentsEnvironmentIDResponse429, x)


def put_environments_environment_id_response500_from_dict(s: Any) -> PutEnvironmentsEnvironmentIDResponse500:
    return PutEnvironmentsEnvironmentIDResponse500.from_dict(s)


def put_environments_environment_id_response500_to_dict(x: PutEnvironmentsEnvironmentIDResponse500) -> Any:
    return to_class(PutEnvironmentsEnvironmentIDResponse500, x)


def put_mocks_mock_id_body_from_dict(s: Any) -> PutMocksMockIDBody:
    return PutMocksMockIDBody.from_dict(s)


def put_mocks_mock_id_body_to_dict(x: PutMocksMockIDBody) -> Any:
    return to_class(PutMocksMockIDBody, x)


def put_mocks_mock_id_response_from_dict(s: Any) -> PutMocksMockIDResponse:
    return PutMocksMockIDResponse.from_dict(s)


def put_mocks_mock_id_response_to_dict(x: PutMocksMockIDResponse) -> Any:
    return to_class(PutMocksMockIDResponse, x)


def put_mocks_mock_id_response401_from_dict(s: Any) -> PutMocksMockIDResponse401:
    return PutMocksMockIDResponse401.from_dict(s)


def put_mocks_mock_id_response401_to_dict(x: PutMocksMockIDResponse401) -> Any:
    return to_class(PutMocksMockIDResponse401, x)


def put_mocks_mock_id_response404_from_dict(s: Any) -> PutMocksMockIDResponse404:
    return PutMocksMockIDResponse404.from_dict(s)


def put_mocks_mock_id_response404_to_dict(x: PutMocksMockIDResponse404) -> Any:
    return to_class(PutMocksMockIDResponse404, x)


def put_mocks_mock_id_response429_from_dict(s: Any) -> PutMocksMockIDResponse429:
    return PutMocksMockIDResponse429.from_dict(s)


def put_mocks_mock_id_response429_to_dict(x: PutMocksMockIDResponse429) -> Any:
    return to_class(PutMocksMockIDResponse429, x)


def put_mocks_mock_id_response500_from_dict(s: Any) -> PutMocksMockIDResponse500:
    return PutMocksMockIDResponse500.from_dict(s)


def put_mocks_mock_id_response500_to_dict(x: PutMocksMockIDResponse500) -> Any:
    return to_class(PutMocksMockIDResponse500, x)


def put_mocks_mock_id_server_responses_server_response_id_body_from_dict(s: Any) -> PutMocksMockIDServerResponsesServerResponseIDBody:
    return PutMocksMockIDServerResponsesServerResponseIDBody.from_dict(s)


def put_mocks_mock_id_server_responses_server_response_id_body_to_dict(x: PutMocksMockIDServerResponsesServerResponseIDBody) -> Any:
    return to_class(PutMocksMockIDServerResponsesServerResponseIDBody, x)


def put_mocks_mock_id_server_responses_server_response_id_response400_from_dict(s: Any) -> PutMocksMockIDServerResponsesServerResponseIDResponse400:
    return PutMocksMockIDServerResponsesServerResponseIDResponse400.from_dict(s)


def put_mocks_mock_id_server_responses_server_response_id_response400_to_dict(x: PutMocksMockIDServerResponsesServerResponseIDResponse400) -> Any:
    return to_class(PutMocksMockIDServerResponsesServerResponseIDResponse400, x)


def put_mocks_mock_id_server_responses_server_response_id_response401_from_dict(s: Any) -> PutMocksMockIDServerResponsesServerResponseIDResponse401:
    return PutMocksMockIDServerResponsesServerResponseIDResponse401.from_dict(s)


def put_mocks_mock_id_server_responses_server_response_id_response401_to_dict(x: PutMocksMockIDServerResponsesServerResponseIDResponse401) -> Any:
    return to_class(PutMocksMockIDServerResponsesServerResponseIDResponse401, x)


def put_mocks_mock_id_server_responses_server_response_id_response429_from_dict(s: Any) -> PutMocksMockIDServerResponsesServerResponseIDResponse429:
    return PutMocksMockIDServerResponsesServerResponseIDResponse429.from_dict(s)


def put_mocks_mock_id_server_responses_server_response_id_response429_to_dict(x: PutMocksMockIDServerResponsesServerResponseIDResponse429) -> Any:
    return to_class(PutMocksMockIDServerResponsesServerResponseIDResponse429, x)


def put_mocks_mock_id_server_responses_server_response_id_response500_from_dict(s: Any) -> PutMocksMockIDServerResponsesServerResponseIDResponse500:
    return PutMocksMockIDServerResponsesServerResponseIDResponse500.from_dict(s)


def put_mocks_mock_id_server_responses_server_response_id_response500_to_dict(x: PutMocksMockIDServerResponsesServerResponseIDResponse500) -> Any:
    return to_class(PutMocksMockIDServerResponsesServerResponseIDResponse500, x)


def put_mocks_mock_id_server_responses_server_response_id_response_item_from_dict(s: Any) -> PutMocksMockIDServerResponsesServerResponseIDResponseItem:
    return PutMocksMockIDServerResponsesServerResponseIDResponseItem.from_dict(s)


def put_mocks_mock_id_server_responses_server_response_id_response_item_to_dict(x: PutMocksMockIDServerResponsesServerResponseIDResponseItem) -> Any:
    return to_class(PutMocksMockIDServerResponsesServerResponseIDResponseItem, x)


def put_monitors_monitor_id_body_from_dict(s: Any) -> PutMonitorsMonitorIDBody:
    return PutMonitorsMonitorIDBody.from_dict(s)


def put_monitors_monitor_id_body_to_dict(x: PutMonitorsMonitorIDBody) -> Any:
    return to_class(PutMonitorsMonitorIDBody, x)


def put_monitors_monitor_id_response_from_dict(s: Any) -> PutMonitorsMonitorIDResponse:
    return PutMonitorsMonitorIDResponse.from_dict(s)


def put_monitors_monitor_id_response_to_dict(x: PutMonitorsMonitorIDResponse) -> Any:
    return to_class(PutMonitorsMonitorIDResponse, x)


def put_monitors_monitor_id_response401_from_dict(s: Any) -> PutMonitorsMonitorIDResponse401:
    return PutMonitorsMonitorIDResponse401.from_dict(s)


def put_monitors_monitor_id_response401_to_dict(x: PutMonitorsMonitorIDResponse401) -> Any:
    return to_class(PutMonitorsMonitorIDResponse401, x)


def put_monitors_monitor_id_response404_from_dict(s: Any) -> PutMonitorsMonitorIDResponse404:
    return PutMonitorsMonitorIDResponse404.from_dict(s)


def put_monitors_monitor_id_response404_to_dict(x: PutMonitorsMonitorIDResponse404) -> Any:
    return to_class(PutMonitorsMonitorIDResponse404, x)


def put_monitors_monitor_id_response429_from_dict(s: Any) -> PutMonitorsMonitorIDResponse429:
    return PutMonitorsMonitorIDResponse429.from_dict(s)


def put_monitors_monitor_id_response429_to_dict(x: PutMonitorsMonitorIDResponse429) -> Any:
    return to_class(PutMonitorsMonitorIDResponse429, x)


def put_monitors_monitor_id_response500_from_dict(s: Any) -> PutMonitorsMonitorIDResponse500:
    return PutMonitorsMonitorIDResponse500.from_dict(s)


def put_monitors_monitor_id_response500_to_dict(x: PutMonitorsMonitorIDResponse500) -> Any:
    return to_class(PutMonitorsMonitorIDResponse500, x)


def put_network_private_element_type_element_id_response401_from_dict(s: Any) -> PutNetworkPrivateElementTypeElementIDResponse401:
    return PutNetworkPrivateElementTypeElementIDResponse401.from_dict(s)


def put_network_private_element_type_element_id_response401_to_dict(x: PutNetworkPrivateElementTypeElementIDResponse401) -> Any:
    return to_class(PutNetworkPrivateElementTypeElementIDResponse401, x)


def put_network_private_element_type_element_id_response403_from_dict(s: Any) -> PutNetworkPrivateElementTypeElementIDResponse403:
    return PutNetworkPrivateElementTypeElementIDResponse403.from_dict(s)


def put_network_private_element_type_element_id_response403_to_dict(x: PutNetworkPrivateElementTypeElementIDResponse403) -> Any:
    return to_class(PutNetworkPrivateElementTypeElementIDResponse403, x)


def put_network_private_element_type_element_id_response404_from_dict(s: Any) -> PutNetworkPrivateElementTypeElementIDResponse404:
    return PutNetworkPrivateElementTypeElementIDResponse404.from_dict(s)


def put_network_private_element_type_element_id_response404_to_dict(x: PutNetworkPrivateElementTypeElementIDResponse404) -> Any:
    return to_class(PutNetworkPrivateElementTypeElementIDResponse404, x)


def put_network_private_element_type_element_id_response429_from_dict(s: Any) -> PutNetworkPrivateElementTypeElementIDResponse429:
    return PutNetworkPrivateElementTypeElementIDResponse429.from_dict(s)


def put_network_private_element_type_element_id_response429_to_dict(x: PutNetworkPrivateElementTypeElementIDResponse429) -> Any:
    return to_class(PutNetworkPrivateElementTypeElementIDResponse429, x)


def put_network_private_element_type_element_id_response500_from_dict(s: Any) -> PutNetworkPrivateElementTypeElementIDResponse500:
    return PutNetworkPrivateElementTypeElementIDResponse500.from_dict(s)


def put_network_private_element_type_element_id_response500_to_dict(x: PutNetworkPrivateElementTypeElementIDResponse500) -> Any:
    return to_class(PutNetworkPrivateElementTypeElementIDResponse500, x)


def put_network_private_network_entity_request_request_id_body_from_dict(s: Any) -> PutNetworkPrivateNetworkEntityRequestRequestIDBody:
    return PutNetworkPrivateNetworkEntityRequestRequestIDBody.from_dict(s)


def put_network_private_network_entity_request_request_id_body_to_dict(x: PutNetworkPrivateNetworkEntityRequestRequestIDBody) -> Any:
    return to_class(PutNetworkPrivateNetworkEntityRequestRequestIDBody, x)


def put_network_private_network_entity_request_request_id_response_from_dict(s: Any) -> PutNetworkPrivateNetworkEntityRequestRequestIDResponse:
    return PutNetworkPrivateNetworkEntityRequestRequestIDResponse.from_dict(s)


def put_network_private_network_entity_request_request_id_response_to_dict(x: PutNetworkPrivateNetworkEntityRequestRequestIDResponse) -> Any:
    return to_class(PutNetworkPrivateNetworkEntityRequestRequestIDResponse, x)


def put_network_private_network_entity_request_request_id_response400_from_dict(s: Any) -> PutNetworkPrivateNetworkEntityRequestRequestIDResponse400:
    return PutNetworkPrivateNetworkEntityRequestRequestIDResponse400.from_dict(s)


def put_network_private_network_entity_request_request_id_response400_to_dict(x: PutNetworkPrivateNetworkEntityRequestRequestIDResponse400) -> Any:
    return to_class(PutNetworkPrivateNetworkEntityRequestRequestIDResponse400, x)


def put_network_private_network_entity_request_request_id_response401_from_dict(s: Any) -> PutNetworkPrivateNetworkEntityRequestRequestIDResponse401:
    return PutNetworkPrivateNetworkEntityRequestRequestIDResponse401.from_dict(s)


def put_network_private_network_entity_request_request_id_response401_to_dict(x: PutNetworkPrivateNetworkEntityRequestRequestIDResponse401) -> Any:
    return to_class(PutNetworkPrivateNetworkEntityRequestRequestIDResponse401, x)


def put_network_private_network_entity_request_request_id_response403_from_dict(s: Any) -> PutNetworkPrivateNetworkEntityRequestRequestIDResponse403:
    return PutNetworkPrivateNetworkEntityRequestRequestIDResponse403.from_dict(s)


def put_network_private_network_entity_request_request_id_response403_to_dict(x: PutNetworkPrivateNetworkEntityRequestRequestIDResponse403) -> Any:
    return to_class(PutNetworkPrivateNetworkEntityRequestRequestIDResponse403, x)


def put_network_private_network_entity_request_request_id_response429_from_dict(s: Any) -> PutNetworkPrivateNetworkEntityRequestRequestIDResponse429:
    return PutNetworkPrivateNetworkEntityRequestRequestIDResponse429.from_dict(s)


def put_network_private_network_entity_request_request_id_response429_to_dict(x: PutNetworkPrivateNetworkEntityRequestRequestIDResponse429) -> Any:
    return to_class(PutNetworkPrivateNetworkEntityRequestRequestIDResponse429, x)


def put_network_private_network_entity_request_request_id_response500_from_dict(s: Any) -> PutNetworkPrivateNetworkEntityRequestRequestIDResponse500:
    return PutNetworkPrivateNetworkEntityRequestRequestIDResponse500.from_dict(s)


def put_network_private_network_entity_request_request_id_response500_to_dict(x: PutNetworkPrivateNetworkEntityRequestRequestIDResponse500) -> Any:
    return to_class(PutNetworkPrivateNetworkEntityRequestRequestIDResponse500, x)


def put_scim_v2_users_user_id_body_from_dict(s: Any) -> PutScimV2UsersUserIDBody:
    return PutScimV2UsersUserIDBody.from_dict(s)


def put_scim_v2_users_user_id_body_to_dict(x: PutScimV2UsersUserIDBody) -> Any:
    return to_class(PutScimV2UsersUserIDBody, x)


def put_scim_v2_users_user_id_response_from_dict(s: Any) -> PutScimV2UsersUserIDResponse:
    return PutScimV2UsersUserIDResponse.from_dict(s)


def put_scim_v2_users_user_id_response_to_dict(x: PutScimV2UsersUserIDResponse) -> Any:
    return to_class(PutScimV2UsersUserIDResponse, x)


def put_scim_v2_users_user_id_response400_from_dict(s: Any) -> PutScimV2UsersUserIDResponse400:
    return PutScimV2UsersUserIDResponse400.from_dict(s)


def put_scim_v2_users_user_id_response400_to_dict(x: PutScimV2UsersUserIDResponse400) -> Any:
    return to_class(PutScimV2UsersUserIDResponse400, x)


def put_scim_v2_users_user_id_response401_from_dict(s: Any) -> PutScimV2UsersUserIDResponse401:
    return PutScimV2UsersUserIDResponse401.from_dict(s)


def put_scim_v2_users_user_id_response401_to_dict(x: PutScimV2UsersUserIDResponse401) -> Any:
    return to_class(PutScimV2UsersUserIDResponse401, x)


def put_scim_v2_users_user_id_response403_from_dict(s: Any) -> PutScimV2UsersUserIDResponse403:
    return PutScimV2UsersUserIDResponse403.from_dict(s)


def put_scim_v2_users_user_id_response403_to_dict(x: PutScimV2UsersUserIDResponse403) -> Any:
    return to_class(PutScimV2UsersUserIDResponse403, x)


def put_scim_v2_users_user_id_response404_from_dict(s: Any) -> PutScimV2UsersUserIDResponse404:
    return PutScimV2UsersUserIDResponse404.from_dict(s)


def put_scim_v2_users_user_id_response404_to_dict(x: PutScimV2UsersUserIDResponse404) -> Any:
    return to_class(PutScimV2UsersUserIDResponse404, x)


def put_scim_v2_users_user_id_response429_from_dict(s: Any) -> PutScimV2UsersUserIDResponse429:
    return PutScimV2UsersUserIDResponse429.from_dict(s)


def put_scim_v2_users_user_id_response429_to_dict(x: PutScimV2UsersUserIDResponse429) -> Any:
    return to_class(PutScimV2UsersUserIDResponse429, x)


def put_scim_v2_users_user_id_response500_from_dict(s: Any) -> PutScimV2UsersUserIDResponse500:
    return PutScimV2UsersUserIDResponse500.from_dict(s)


def put_scim_v2_users_user_id_response500_to_dict(x: PutScimV2UsersUserIDResponse500) -> Any:
    return to_class(PutScimV2UsersUserIDResponse500, x)


def put_workspaces_workspace_id_body_from_dict(s: Any) -> PutWorkspacesWorkspaceIDBody:
    return PutWorkspacesWorkspaceIDBody.from_dict(s)


def put_workspaces_workspace_id_body_to_dict(x: PutWorkspacesWorkspaceIDBody) -> Any:
    return to_class(PutWorkspacesWorkspaceIDBody, x)


def put_workspaces_workspace_id_global_variables_body_from_dict(s: Any) -> PutWorkspacesWorkspaceIDGlobalVariablesBody:
    return PutWorkspacesWorkspaceIDGlobalVariablesBody.from_dict(s)


def put_workspaces_workspace_id_global_variables_body_to_dict(x: PutWorkspacesWorkspaceIDGlobalVariablesBody) -> Any:
    return to_class(PutWorkspacesWorkspaceIDGlobalVariablesBody, x)


def put_workspaces_workspace_id_global_variables_response_from_dict(s: Any) -> PutWorkspacesWorkspaceIDGlobalVariablesResponse:
    return PutWorkspacesWorkspaceIDGlobalVariablesResponse.from_dict(s)


def put_workspaces_workspace_id_global_variables_response_to_dict(x: PutWorkspacesWorkspaceIDGlobalVariablesResponse) -> Any:
    return to_class(PutWorkspacesWorkspaceIDGlobalVariablesResponse, x)


def put_workspaces_workspace_id_global_variables_response500_from_dict(s: Any) -> PutWorkspacesWorkspaceIDGlobalVariablesResponse500:
    return PutWorkspacesWorkspaceIDGlobalVariablesResponse500.from_dict(s)


def put_workspaces_workspace_id_global_variables_response500_to_dict(x: PutWorkspacesWorkspaceIDGlobalVariablesResponse500) -> Any:
    return to_class(PutWorkspacesWorkspaceIDGlobalVariablesResponse500, x)


def put_workspaces_workspace_id_response_from_dict(s: Any) -> PutWorkspacesWorkspaceIDResponse:
    return PutWorkspacesWorkspaceIDResponse.from_dict(s)


def put_workspaces_workspace_id_response_to_dict(x: PutWorkspacesWorkspaceIDResponse) -> Any:
    return to_class(PutWorkspacesWorkspaceIDResponse, x)


def put_workspaces_workspace_id_response400_from_dict(s: Any) -> PutWorkspacesWorkspaceIDResponse400:
    return PutWorkspacesWorkspaceIDResponse400.from_dict(s)


def put_workspaces_workspace_id_response400_to_dict(x: PutWorkspacesWorkspaceIDResponse400) -> Any:
    return to_class(PutWorkspacesWorkspaceIDResponse400, x)


def put_workspaces_workspace_id_response403_from_dict(s: Any) -> PutWorkspacesWorkspaceIDResponse403:
    return PutWorkspacesWorkspaceIDResponse403.from_dict(s)


def put_workspaces_workspace_id_response403_to_dict(x: PutWorkspacesWorkspaceIDResponse403) -> Any:
    return to_class(PutWorkspacesWorkspaceIDResponse403, x)


def put_workspaces_workspace_id_response404_from_dict(s: Any) -> PutWorkspacesWorkspaceIDResponse404:
    return PutWorkspacesWorkspaceIDResponse404.from_dict(s)


def put_workspaces_workspace_id_response404_to_dict(x: PutWorkspacesWorkspaceIDResponse404) -> Any:
    return to_class(PutWorkspacesWorkspaceIDResponse404, x)


def put_workspaces_workspace_id_response429_from_dict(s: Any) -> PutWorkspacesWorkspaceIDResponse429:
    return PutWorkspacesWorkspaceIDResponse429.from_dict(s)


def put_workspaces_workspace_id_response429_to_dict(x: PutWorkspacesWorkspaceIDResponse429) -> Any:
    return to_class(PutWorkspacesWorkspaceIDResponse429, x)


def put_workspaces_workspace_id_response500_from_dict(s: Any) -> PutWorkspacesWorkspaceIDResponse500:
    return PutWorkspacesWorkspaceIDResponse500.from_dict(s)


def put_workspaces_workspace_id_response500_to_dict(x: PutWorkspacesWorkspaceIDResponse500) -> Any:
    return to_class(PutWorkspacesWorkspaceIDResponse500, x)


def put_workspaces_workspace_id_tags_body_from_dict(s: Any) -> PutWorkspacesWorkspaceIDTagsBody:
    return PutWorkspacesWorkspaceIDTagsBody.from_dict(s)


def put_workspaces_workspace_id_tags_body_to_dict(x: PutWorkspacesWorkspaceIDTagsBody) -> Any:
    return to_class(PutWorkspacesWorkspaceIDTagsBody, x)


def put_workspaces_workspace_id_tags_response_from_dict(s: Any) -> PutWorkspacesWorkspaceIDTagsResponse:
    return PutWorkspacesWorkspaceIDTagsResponse.from_dict(s)


def put_workspaces_workspace_id_tags_response_to_dict(x: PutWorkspacesWorkspaceIDTagsResponse) -> Any:
    return to_class(PutWorkspacesWorkspaceIDTagsResponse, x)


def put_workspaces_workspace_id_tags_response400_from_dict(s: Any) -> PutWorkspacesWorkspaceIDTagsResponse400:
    return PutWorkspacesWorkspaceIDTagsResponse400.from_dict(s)


def put_workspaces_workspace_id_tags_response400_to_dict(x: PutWorkspacesWorkspaceIDTagsResponse400) -> Any:
    return to_class(PutWorkspacesWorkspaceIDTagsResponse400, x)


def put_workspaces_workspace_id_tags_response401_from_dict(s: Any) -> PutWorkspacesWorkspaceIDTagsResponse401:
    return PutWorkspacesWorkspaceIDTagsResponse401.from_dict(s)


def put_workspaces_workspace_id_tags_response401_to_dict(x: PutWorkspacesWorkspaceIDTagsResponse401) -> Any:
    return to_class(PutWorkspacesWorkspaceIDTagsResponse401, x)


def put_workspaces_workspace_id_tags_response403_from_dict(s: Any) -> PutWorkspacesWorkspaceIDTagsResponse403:
    return PutWorkspacesWorkspaceIDTagsResponse403.from_dict(s)


def put_workspaces_workspace_id_tags_response403_to_dict(x: PutWorkspacesWorkspaceIDTagsResponse403) -> Any:
    return to_class(PutWorkspacesWorkspaceIDTagsResponse403, x)


def put_workspaces_workspace_id_tags_response404_from_dict(s: Any) -> PutWorkspacesWorkspaceIDTagsResponse404:
    return PutWorkspacesWorkspaceIDTagsResponse404.from_dict(s)


def put_workspaces_workspace_id_tags_response404_to_dict(x: PutWorkspacesWorkspaceIDTagsResponse404) -> Any:
    return to_class(PutWorkspacesWorkspaceIDTagsResponse404, x)


def put_workspaces_workspace_id_tags_response500_from_dict(s: Any) -> PutWorkspacesWorkspaceIDTagsResponse500:
    return PutWorkspacesWorkspaceIDTagsResponse500.from_dict(s)


def put_workspaces_workspace_id_tags_response500_to_dict(x: PutWorkspacesWorkspaceIDTagsResponse500) -> Any:
    return to_class(PutWorkspacesWorkspaceIDTagsResponse500, x)


def api_base_from_dict(s: Any) -> APIBase:
    return APIBase.from_dict(s)


def api_base_to_dict(x: APIBase) -> Any:
    return to_class(APIBase, x)


def api_details_from_dict(s: Any) -> APIDetails:
    return APIDetails.from_dict(s)


def api_details_to_dict(x: APIDetails) -> Any:
    return to_class(APIDetails, x)


def create_api_version_git_linked_from_dict(s: Any) -> CreateAPIVersionGitLinked:
    return CreateAPIVersionGitLinked.from_dict(s)


def create_api_version_git_linked_to_dict(x: CreateAPIVersionGitLinked) -> Any:
    return to_class(CreateAPIVersionGitLinked, x)


def create_api_version_non_git_linked_from_dict(s: Any) -> CreateAPIVersionNonGitLinked:
    return CreateAPIVersionNonGitLinked.from_dict(s)


def create_api_version_non_git_linked_to_dict(x: CreateAPIVersionNonGitLinked) -> Any:
    return to_class(CreateAPIVersionNonGitLinked, x)


def create_api_schema_from_dict(s: Any) -> CreateAPISchema:
    return CreateAPISchema.from_dict(s)


def create_api_schema_to_dict(x: CreateAPISchema) -> Any:
    return to_class(CreateAPISchema, x)


def create_panapi_from_dict(s: Any) -> CreatePANAPI:
    return CreatePANAPI.from_dict(s)


def create_panapi_to_dict(x: CreatePANAPI) -> Any:
    return to_class(CreatePANAPI, x)


def create_pan_collection_from_dict(s: Any) -> CreatePANCollection:
    return CreatePANCollection.from_dict(s)


def create_pan_collection_to_dict(x: CreatePANCollection) -> Any:
    return to_class(CreatePANCollection, x)


def create_pan_folder_from_dict(s: Any) -> CreatePANFolder:
    return CreatePANFolder.from_dict(s)


def create_pan_folder_to_dict(x: CreatePANFolder) -> Any:
    return to_class(CreatePANFolder, x)


def create_pan_workspace_from_dict(s: Any) -> CreatePANWorkspace:
    return CreatePANWorkspace.from_dict(s)


def create_pan_workspace_to_dict(x: CreatePANWorkspace) -> Any:
    return to_class(CreatePANWorkspace, x)


def create_update_api_from_dict(s: Any) -> CreateUpdateAPI:
    return CreateUpdateAPI.from_dict(s)


def create_update_api_to_dict(x: CreateUpdateAPI) -> Any:
    return to_class(CreateUpdateAPI, x)


def git_info_from_dict(s: Any) -> GitInfo:
    return GitInfo.from_dict(s)


def git_info_to_dict(x: GitInfo) -> Any:
    return to_class(GitInfo, x)


def global_variable_from_dict(s: Any) -> GlobalVariable:
    return GlobalVariable.from_dict(s)


def global_variable_to_dict(x: GlobalVariable) -> Any:
    return to_class(GlobalVariable, x)


def import_export_file_from_dict(s: Any) -> ImportExportFile:
    return ImportExportFile.from_dict(s)


def import_export_file_to_dict(x: ImportExportFile) -> Any:
    return to_class(ImportExportFile, x)


def json_schema_from_dict(s: Any) -> JSONSchema:
    return JSONSchema.from_dict(s)


def json_schema_to_dict(x: JSONSchema) -> Any:
    return to_class(JSONSchema, x)


def json_stringified_from_dict(s: Any) -> JSONStringified:
    return JSONStringified.from_dict(s)


def json_stringified_to_dict(x: JSONStringified) -> Any:
    return to_class(JSONStringified, x)


def meta_from_dict(s: Any) -> Meta:
    return Meta.from_dict(s)


def meta_to_dict(x: Meta) -> Any:
    return to_class(Meta, x)


def schema_file_base_from_dict(s: Any) -> SchemaFileBase:
    return SchemaFileBase.from_dict(s)


def schema_file_base_to_dict(x: SchemaFileBase) -> Any:
    return to_class(SchemaFileBase, x)


def schema_file_contents_from_dict(s: Any) -> SchemaFileContents:
    return SchemaFileContents.from_dict(s)


def schema_file_contents_to_dict(x: SchemaFileContents) -> Any:
    return to_class(SchemaFileContents, x)


def scim_group_resource_from_dict(s: Any) -> ScimGroupResource:
    return ScimGroupResource.from_dict(s)


def scim_group_resource_to_dict(x: ScimGroupResource) -> Any:
    return to_class(ScimGroupResource, x)


def scim_user_resource_from_dict(s: Any) -> ScimUserResource:
    return ScimUserResource.from_dict(s)


def scim_user_resource_to_dict(x: ScimUserResource) -> Any:
    return to_class(ScimUserResource, x)


def task_error_from_dict(s: Any) -> TaskError:
    return TaskError.from_dict(s)


def task_error_to_dict(x: TaskError) -> Any:
    return to_class(TaskError, x)


def task_resource_from_dict(s: Any) -> TaskResource:
    return TaskResource.from_dict(s)


def task_resource_to_dict(x: TaskResource) -> Any:
    return to_class(TaskResource, x)


def update_panapi_from_dict(s: Any) -> UpdatePANAPI:
    return UpdatePANAPI.from_dict(s)


def update_panapi_to_dict(x: UpdatePANAPI) -> Any:
    return to_class(UpdatePANAPI, x)


def update_pan_collection_from_dict(s: Any) -> UpdatePANCollection:
    return UpdatePANCollection.from_dict(s)


def update_pan_collection_to_dict(x: UpdatePANCollection) -> Any:
    return to_class(UpdatePANCollection, x)


def update_pan_folder_from_dict(s: Any) -> UpdatePANFolder:
    return UpdatePANFolder.from_dict(s)


def update_pan_folder_to_dict(x: UpdatePANFolder) -> Any:
    return to_class(UpdatePANFolder, x)


def update_pan_workspace_from_dict(s: Any) -> UpdatePANWorkspace:
    return UpdatePANWorkspace.from_dict(s)


def update_pan_workspace_to_dict(x: UpdatePANWorkspace) -> Any:
    return to_class(UpdatePANWorkspace, x)


def version_base_from_dict(s: Any) -> VersionBase:
    return VersionBase.from_dict(s)


def version_base_to_dict(x: VersionBase) -> Any:
    return to_class(VersionBase, x)


def version_extended_from_dict(s: Any) -> VersionExtended:
    return VersionExtended.from_dict(s)


def version_extended_to_dict(x: VersionExtended) -> Any:
    return to_class(VersionExtended, x)
