"""Generated by Sideko (sideko.dev)"""
import typing
import json
import requests

from .schemas import *

JSONType = typing.Union[str, int, float, bool, None, typing.Dict[str, typing.Any], typing.List[typing.Any]]

class RequestError(Exception):
    def __init__(self, status_code: int, method: str, url: str, message: str):
        super().__init__(f"received {status_code} from {method.upper()} {url}")
        self.status_code = status_code
        self.method = method
        self.url = url
        try:
            self.data = json.loads(message)
        except:
            self.data = message

class SidekoClient:
    def __init__(self, api_key: str, base_url: typing.Optional[str] = None):
        url = base_url or "https://api.getpostman.com"
        self.base_url = url        
        self.session = requests.Session()
        # add key auth header
        self.session.headers.update({"x-api-key": api_key})

    def _cast_list(self, input_list, target_class):
        casted = []
        for el in input_list:
            if isinstance(el, list):
                casted.append(self._cast_list(el, target_class))
            else:
                casted.append(target_class.from_dict(el))
        return casted

    def _raise_exception(self, response: requests.models.Response) -> typing.Any:
        method = response.request.method or "unknown"
        raise RequestError(response.status_code, method, response.url, response.text)

    def _to_json_encodable(self, target: typing.Any) -> JSONType:
        if isinstance(target, list):
            return [self._to_json_encodable(el) for el in target]

        to_dict_method = getattr(target, "to_dict", None)
        if callable(to_dict_method):
            return target.to_dict()

        return target


    def delete_api(self, *, api_id: str) -> typing.Any:
        """ Deletes an API. """
        endpoint = f"/apis/{api_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        return response

    def delete_schema_file(self, *, api_id: str, schema_id: str, file_path: str) -> typing.Any:
        """ Deletes a file in an API schema. """
        endpoint = f"/apis/{api_id}/schemas/{schema_id}/files/{file_path}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        return response

    def delete_api_version(self, *, api_id: str, version_id: str) -> typing.Any:
        """ Deletes an API version. -  - **Note:** -  - This endpoint returns an HTTP &#x60;404 Not Found&#x60; response when an API version is pending publication. -  """
        endpoint = f"/apis/{api_id}/versions/{version_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        return response

    def delete_collection(self, *, collection_id: str) -> DeleteCollectionsCollectionIDResponse:
        """ Deletes a collection. """
        endpoint = f"/collections/{collection_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = DeleteCollectionsCollectionIDResponse.from_dict(response)
        return response

    def delete_collection_folder(self, *, collection_id: str, folder_id: str) -> DeleteCollectionsCollectionIDFoldersFolderIDResponse:
        """ Deletes a folder in a collection. """
        endpoint = f"/collections/{collection_id}/folders/{folder_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = DeleteCollectionsCollectionIDFoldersFolderIDResponse.from_dict(response)
        return response

    def delete_collection_request(self, *, collection_id: str, request_id: str) -> DeleteCollectionsCollectionIDRequestsRequestIDResponse:
        """ Deletes a request in a collection. """
        endpoint = f"/collections/{collection_id}/requests/{request_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = DeleteCollectionsCollectionIDRequestsRequestIDResponse.from_dict(response)
        return response

    def delete_collection_response(self, *, collection_id: str, response_id: str) -> DeleteCollectionsCollectionIDResponsesResponseIDResponse:
        """ Deletes a response in a collection. """
        endpoint = f"/collections/{collection_id}/responses/{response_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = DeleteCollectionsCollectionIDResponsesResponseIDResponse.from_dict(response)
        return response

    def delete_environment(self, *, environment_id: str) -> DeleteEnvironmentsEnvironmentIDResponse:
        """ Deletes an environment. """
        endpoint = f"/environments/{environment_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = DeleteEnvironmentsEnvironmentIDResponse.from_dict(response)
        return response

    def delete_mock(self, *, mock_id: str) -> DeleteMocksMockIDResponse:
        """ Deletes a mock server. """
        endpoint = f"/mocks/{mock_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = DeleteMocksMockIDResponse.from_dict(response)
        return response

    def delete_mock_server_response(self, *, mock_id: str, server_response_id: str) -> DeleteMocksMockIDServerResponsesServerResponseIDResponse:
        """ Deletes a mock server&#x27;s server response. """
        endpoint = f"/mocks/{mock_id}/server-responses/{server_response_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = DeleteMocksMockIDServerResponsesServerResponseIDResponse.from_dict(response)
        return response

    def unpublish_mock(self, *, mock_id: str) -> DeleteMocksMockIDUnpublishResponse:
        """ Unpublishes a mock server. Unpublishing a mock server sets its **Access Control** configuration setting to private. """
        endpoint = f"/mocks/{mock_id}/unpublish"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = DeleteMocksMockIDUnpublishResponse.from_dict(response)
        return response

    def delete_monitor(self, *, monitor_id: str) -> DeleteMonitorsMonitorIDResponse:
        """ Deletes a monitor. """
        endpoint = f"/monitors/{monitor_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = DeleteMonitorsMonitorIDResponse.from_dict(response)
        return response

    def remove_element_or_folder(self, *, element_type: str, element_id: str) -> DeleteNetworkPrivateElementTypeElementIDResponse:
        """ Removes an element or delete a folder from your [Private API Network](https://learning.postman.com/docs/collaborating-in-postman/adding-private-network/). -  - **Note:** -  - Removing an API, collection, or workspace element does **not** delete it. It only removes it from the Private API Network folder. """
        endpoint = f"/network/private/{element_type}/{element_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = DeleteNetworkPrivateElementTypeElementIDResponse.from_dict(response)
        return response

    def delete_group(self, *, group_id: str) -> typing.Any:
        """ Deletes a group in Postman. -  - User accounts that were in the deleted group are deactivated in Postman if the app is assigned to the user only with the deleted group. -  - User accounts and the data corresponding to them are **not** deleted. To permanently delete user accounts and their data, [contact Postman support](https://www.postman.com/support/). -  """
        endpoint = f"/scim/v2/Groups/{group_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        return response

    def delete_workspace(self, *, workspace_id: str) -> DeleteWorkspacesWorkspaceIDResponse:
        """ Deletes an existing workspace. -  - ### Important -  - If you delete a workspace that has a linked collection or environment with another workspace, this will delete the collection and environment in **all** workspaces. -  """
        endpoint = f"/workspaces/{workspace_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.delete(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = DeleteWorkspacesWorkspaceIDResponse.from_dict(response)
        return response

    def get_all_apis(self, *, workspace_id: str, created_by: typing.Optional[int] = None, cursor: typing.Optional[str] = None, description: typing.Optional[str] = None, limit: typing.Optional[int] = None) -> GetApisResponse:
        """ Gets information about all APIs in a workspace. -  - **Note:** -  - This endpoint only returns APIs created or migrated in Postman v10 and higher. -  """
        endpoint = f"/apis"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        params["workspace_id"] = workspace_id
        if created_by is not None:
            params["created_by"] = created_by
        if cursor is not None:
            params["cursor"] = cursor
        if description is not None:
            params["description"] = description
        if limit is not None:
            params["limit"] = limit

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetApisResponse.from_dict(response)
        return response

    def get_an_api(self, *, api_id: str, include: typing.Optional[typing.List[str]] = None) -> typing.Any:
        """ Gets information about an API. -  - **Note:** -  - - Git-connected APIs will **only** return the &#x60;versions&#x60; and &#x60;gitInfo&#x60; query responses. This is because schema and collection information is stored in the connected Git repository. The &#x60;gitInfo&#x60; object only lists the repository and folder locations of the files. - - API viewers can only use the &#x60;versions&#x60; option in the &#x60;include&#x60; query parameter. -  """
        endpoint = f"/apis/{api_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if include is not None:
            params["include"] = include

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        return response

    def get_collection(self, *, api_id: str, collection_id: str, version_id: typing.Optional[str] = None) -> GetApisAPIIDCollectionsCollectionIDResponse:
        """ Gets a collection attached to an API. You can use the &#x60;versionId&#x60; query parameter to get a collection published in a version. -  - **Note:** -  - The &#x60;versionId&#x60; query parameter is a required parameter for API viewers. -  """
        endpoint = f"/apis/{api_id}/collections/{collection_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if version_id is not None:
            params["version_id"] = version_id

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetApisAPIIDCollectionsCollectionIDResponse.from_dict(response)
        return response

    def get_schema(self, *, api_id: str, schema_id: str, bundled: typing.Optional[bool] = None, version_id: typing.Optional[str] = None) -> typing.Any:
        """ Gets information about API schema. You can use the &#x60;versionId&#x60; query parameter to get a schema published in an API version. -  - You can use this API to do the following: -  - - Get a schema&#x27;s metadata. - - Get all the files in a schema. This only returns the first file in the schema. The endpoint response contains a link to the next set of response results. - - Get a schema&#x27;s contents in multi-file or bundled format. -  - **Note:** -  - The &#x60;versionId&#x60; query parameter is a **required** parameter for API viewers. -  """
        endpoint = f"/apis/{api_id}/schemas/{schema_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if bundled is not None:
            params["bundled"] = bundled
        if version_id is not None:
            params["version_id"] = version_id

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        return response

    def get_schema_files(self, *, api_id: str, schema_id: str, cursor: typing.Optional[str] = None, limit: typing.Optional[int] = None, version_id: typing.Optional[str] = None) -> GetApisAPIIDSchemasSchemaIDFilesResponse:
        """ Gets the files in an API schema. You can use the &#x60;versionId&#x60; query parameter to get schema files published in an API version. -  - **Note:** -  - The &#x60;versionId&#x60; query parameter is a required parameter for API viewers. -  """
        endpoint = f"/apis/{api_id}/schemas/{schema_id}/files"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if cursor is not None:
            params["cursor"] = cursor
        if limit is not None:
            params["limit"] = limit
        if version_id is not None:
            params["version_id"] = version_id

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetApisAPIIDSchemasSchemaIDFilesResponse.from_dict(response)
        return response

    def get_schema_file_contents(self, *, api_id: str, schema_id: str, file_path: str, version_id: typing.Optional[str] = None) -> GetApisAPIIDSchemasSchemaIDFilesFilePathResponse:
        """ Gets an API schema file contents at the defined path. You can use the &#x60;versionId&#x60; query parameter to get schema file contents published in an API version. -  - **Note:** -  - The &#x60;versionId&#x60; query parameter is a required parameter for API viewers. -  """
        endpoint = f"/apis/{api_id}/schemas/{schema_id}/files/{file_path}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if version_id is not None:
            params["version_id"] = version_id

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetApisAPIIDSchemasSchemaIDFilesFilePathResponse.from_dict(response)
        return response

    def get_api_tags(self, *, api_id: str) -> GetApisAPIIDTagsResponse:
        """ Gets all the tags associated with an API. """
        endpoint = f"/apis/{api_id}/tags"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetApisAPIIDTagsResponse.from_dict(response)
        return response

    def get_status_of_an_async_task(self, *, api_id: str, task_id: str) -> GetApisAPIIDTasksTaskIDResponse:
        """ Gets the status of an asynchronous task. """
        endpoint = f"/apis/{api_id}/tasks/{task_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetApisAPIIDTasksTaskIDResponse.from_dict(response)
        return response

    def get_all_versions(self, *, api_id: str, cursor: typing.Optional[str] = None, limit: typing.Optional[int] = None) -> GetApisAPIIDVersionsResponse:
        """ Gets all the published versions of an API. """
        endpoint = f"/apis/{api_id}/versions"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if cursor is not None:
            params["cursor"] = cursor
        if limit is not None:
            params["limit"] = limit

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetApisAPIIDVersionsResponse.from_dict(response)
        return response

    def get_api_version(self, *, api_id: str, version_id: str) -> GetApisAPIIDVersionsVersionIDResponse:
        """ Gets information about an API version. -  - **Note:** -  - - For API editors, this endpoint returns an HTTP &#x60;302 Found&#x60; status code when the version status is pending. It also returns the &#x60;/apis/{apiId}/tasks/{taskId}&#x60; task status response header. - - For API viewers, this endpoint returns an HTTP &#x60;404 Not Found&#x60; when the version status is pending. -  """
        endpoint = f"/apis/{api_id}/versions/{version_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetApisAPIIDVersionsVersionIDResponse.from_dict(response)
        return response

    def get_audit_logs(self, *, cursor: typing.Optional[str] = None, limit: typing.Optional[int] = None, order_by: typing.Optional[str] = None, since: typing.Optional[str] = None, until: typing.Optional[str] = None) -> GetAuditLogsResponse:
        """ Gets a list of your team&#x27;s generated audit events. For a complete list of all audit events, read our [Utilizing audit logs](https://learning.postman.com/docs/administration/audit-logs/) documentation. """
        endpoint = f"/audit/logs"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if cursor is not None:
            params["cursor"] = cursor
        if limit is not None:
            params["limit"] = limit
        if order_by is not None:
            params["order_by"] = order_by
        if since is not None:
            params["since"] = since
        if until is not None:
            params["until"] = until

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetAuditLogsResponse.from_dict(response)
        return response

    def all_collections(self, *, name: typing.Optional[str] = None, workspace_id: typing.Optional[str] = None) -> GetCollectionsResponse:
        """ Gets all of your [collections](https://www.getpostman.com/docs/collections). The response includes all of your subscribed collections. """
        endpoint = f"/collections"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if name is not None:
            params["name"] = name
        if workspace_id is not None:
            params["workspace_id"] = workspace_id

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetCollectionsResponse.from_dict(response)
        return response

    def single_collection(self, *, collection_id: str, access_key: typing.Optional[str] = None) -> GetCollectionsCollectionIDResponse:
        """ Gets information about a collection. For a complete list of this endpoint&#x27;s possible values, use the [collection.json schema file](https://schema.postman.com/json/collection/v2.1.0/collection.json). """
        endpoint = f"/collections/{collection_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if access_key is not None:
            params["access_key"] = access_key

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetCollectionsCollectionIDResponse.from_dict(response)
        return response

    def get_collection_folder(self, *, collection_id: str, folder_id: str, ids: typing.Optional[bool] = None, populate: typing.Optional[bool] = None, uid: typing.Optional[bool] = None) -> GetCollectionsCollectionIDFoldersFolderIDResponse:
        """ Gets information about a folder in a collection. """
        endpoint = f"/collections/{collection_id}/folders/{folder_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if ids is not None:
            params["ids"] = ids
        if populate is not None:
            params["populate"] = populate
        if uid is not None:
            params["uid"] = uid

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetCollectionsCollectionIDFoldersFolderIDResponse.from_dict(response)
        return response

    def get_collection_request(self, *, collection_id: str, request_id: str, ids: typing.Optional[str] = None, populate: typing.Optional[bool] = None, uid: typing.Optional[bool] = None) -> GetCollectionsCollectionIDRequestsRequestIDResponse:
        """ Gets information about a request in a collection. """
        endpoint = f"/collections/{collection_id}/requests/{request_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if ids is not None:
            params["ids"] = ids
        if populate is not None:
            params["populate"] = populate
        if uid is not None:
            params["uid"] = uid

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetCollectionsCollectionIDRequestsRequestIDResponse.from_dict(response)
        return response

    def get_collection_response(self, *, collection_id: str, response_id: str, ids: typing.Optional[bool] = None, populate: typing.Optional[bool] = None, uid: typing.Optional[bool] = None) -> GetCollectionsCollectionIDResponsesResponseIDResponse:
        """ Gets information about a response in a collection. """
        endpoint = f"/collections/{collection_id}/responses/{response_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if ids is not None:
            params["ids"] = ids
        if populate is not None:
            params["populate"] = populate
        if uid is not None:
            params["uid"] = uid

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetCollectionsCollectionIDResponsesResponseIDResponse.from_dict(response)
        return response

    def get_collection_tags(self, *, collection_id: str) -> GetCollectionsCollectionIDTagsResponse:
        """ Gets all the tags associated with a collection. """
        endpoint = f"/collections/{collection_id}/tags"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetCollectionsCollectionIDTagsResponse.from_dict(response)
        return response

    def transform_collection_to_open_api(self, *, collection_id: str) -> GetCollectionsCollectionIDTransformationsResponse:
        """ Transforms an existing Postman Collection into a stringified OpenAPI definition. -  - **Note:** -  - This does **not** create an API. -  """
        endpoint = f"/collections/{collection_id}/transformations"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetCollectionsCollectionIDTransformationsResponse.from_dict(response)
        return response

    def get_detected_secrets_locations(self, *, secret_id: str, workspace_id: str, cursor: typing.Optional[str] = None, limit: typing.Optional[int] = None) -> GetDetectedSecretsSecretIDLocationsResponse:
        """ Gets the locations of secrets detected by Postman&#x27;s [Secret Scanner](https://learning.postman.com/docs/administration/secret-scanner/). """
        endpoint = f"/detected-secrets/{secret_id}/locations"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        params["workspace_id"] = workspace_id
        if cursor is not None:
            params["cursor"] = cursor
        if limit is not None:
            params["limit"] = limit

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetDetectedSecretsSecretIDLocationsResponse.from_dict(response)
        return response

    def all_environments(self, *, workspace_id: typing.Optional[str] = None) -> GetEnvironmentsResponse:
        """ Gets information about all of your [environments](https://learning.postman.com/docs/sending-requests/managing-environments/). """
        endpoint = f"/environments"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if workspace_id is not None:
            params["workspace_id"] = workspace_id

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetEnvironmentsResponse.from_dict(response)
        return response

    def single_environment(self, *, environment_id: str) -> GetEnvironmentsEnvironmentIDResponse:
        """ Gets information about an environment. """
        endpoint = f"/environments/{environment_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetEnvironmentsEnvironmentIDResponse.from_dict(response)
        return response

    def api_key_owner(self) -> GetMeResponse:
        """ Gets information about the authenticated user. -  - **Note:** -  - This API returns a different response for users with the [Guest role](https://learning.postman.com/docs/collaborating-in-postman/roles-and-permissions/#team-roles). -  """
        endpoint = f"/me"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetMeResponse.from_dict(response)
        return response

    def get_mocks(self, *, team_id: typing.Optional[str] = None, workspace: typing.Optional[str] = None) -> GetMocksResponse:
        """ Gets all mock servers. By default, this endpoint returns only mock servers you created across all workspaces. -  - **Note:** -  - If you pass both the &#x60;teamId&#x60; and &#x60;workspace&#x60; query parameters, this endpoint only accepts the &#x60;workspace&#x60; query. -  """
        endpoint = f"/mocks"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if team_id is not None:
            params["team_id"] = team_id
        if workspace is not None:
            params["workspace"] = workspace

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetMocksResponse.from_dict(response)
        return response

    def get_mock(self, *, mock_id: str) -> GetMocksMockIDResponse:
        """ Gets information about a mock server. """
        endpoint = f"/mocks/{mock_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetMocksMockIDResponse.from_dict(response)
        return response

    def get_mock_call_logs(self, *, mock_id: str, cursor: typing.Optional[str] = None, direction: typing.Optional[str] = None, include: typing.Optional[str] = None, limit: typing.Optional[float] = None, request_method: typing.Optional[str] = None, request_path: typing.Optional[str] = None, response_status_code: typing.Optional[float] = None, response_type: typing.Optional[str] = None, since: typing.Optional[str] = None, sort: typing.Optional[str] = None, until: typing.Optional[str] = None) -> GetMocksMockIDCallLogsResponse:
        """ Gets a mock server&#x27;s call logs. You can get a maximum of 6.5MB of call logs or a total of 100 call logs, whichever limit is met first in one API call. -  - Call logs contain exchanged request and response data made to mock servers. The logs provide visibility into how the mock servers are being used. You can log data to debug, test, analyze, and more, depending upon the use case. -  """
        endpoint = f"/mocks/{mock_id}/call-logs"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if cursor is not None:
            params["cursor"] = cursor
        if direction is not None:
            params["direction"] = direction
        if include is not None:
            params["include"] = include
        if limit is not None:
            params["limit"] = limit
        if request_method is not None:
            params["request_method"] = request_method
        if request_path is not None:
            params["request_path"] = request_path
        if response_status_code is not None:
            params["response_status_code"] = response_status_code
        if response_type is not None:
            params["response_type"] = response_type
        if since is not None:
            params["since"] = since
        if sort is not None:
            params["sort"] = sort
        if until is not None:
            params["until"] = until

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetMocksMockIDCallLogsResponse.from_dict(response)
        return response

    def get_mock_server_responses(self, *, mock_id: str) -> typing.List[GetMocksMockIDServerResponsesResponseItem]:
        """ Gets all of a mock server&#x27;s server responses. """
        endpoint = f"/mocks/{mock_id}/server-responses"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = self._cast_list(response, GetMocksMockIDServerResponsesResponseItem)
        return response

    def get_mock_server_response(self, *, mock_id: str, server_response_id: str) -> typing.List[GetMocksMockIDServerResponsesServerResponseIDResponseItem]:
        """ Gets information about a server response. """
        endpoint = f"/mocks/{mock_id}/server-responses/{server_response_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = self._cast_list(response, GetMocksMockIDServerResponsesServerResponseIDResponseItem)
        return response

    def all_monitors(self, *, workspace: typing.Optional[str] = None) -> GetMonitorsResponse:
        """ Gets all monitors. """
        endpoint = f"/monitors"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if workspace is not None:
            params["workspace"] = workspace

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetMonitorsResponse.from_dict(response)
        return response

    def single_monitor(self, *, monitor_id: str) -> GetMonitorsMonitorIDResponse:
        """ Gets information about a monitor. """
        endpoint = f"/monitors/{monitor_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetMonitorsMonitorIDResponse.from_dict(response)
        return response

    def get_all_elements_and_folders(self, *, added_by: typing.Optional[int] = None, created_by: typing.Optional[int] = None, description: typing.Optional[str] = None, direction: typing.Optional[str] = None, limit: typing.Optional[int] = None, name: typing.Optional[str] = None, offset: typing.Optional[int] = None, parent_folder_id: typing.Optional[int] = None, since: typing.Optional[str] = None, sort: typing.Optional[str] = None, summary: typing.Optional[str] = None, type: typing.Optional[str] = None, until: typing.Optional[str] = None) -> GetNetworkPrivateResponse:
        """ Gets information about the folders and their elements added to your [Private API Network](https://learning.postman.com/docs/collaborating-in-postman/adding-private-network/). -  - **Note:** -  - The &#x60;limit&#x60; and &#x60;offset&#x60; parameters are separately applied to elements and folders. For example, if you query a &#x60;limit&#x60; value of &#x60;10&#x60; and an &#x60;offset&#x60; value &#x60;0&#x60;, the endpoint returns 10 elements and 10 folders for a total of 20 items. The &#x60;totalCount&#x60; property in the &#x60;meta&#x60; response is the total count of **both** elements and folders. """
        endpoint = f"/network/private"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if added_by is not None:
            params["added_by"] = added_by
        if created_by is not None:
            params["created_by"] = created_by
        if description is not None:
            params["description"] = description
        if direction is not None:
            params["direction"] = direction
        if limit is not None:
            params["limit"] = limit
        if name is not None:
            params["name"] = name
        if offset is not None:
            params["offset"] = offset
        if parent_folder_id is not None:
            params["parent_folder_id"] = parent_folder_id
        if since is not None:
            params["since"] = since
        if sort is not None:
            params["sort"] = sort
        if summary is not None:
            params["summary"] = summary
        if type is not None:
            params["type"] = type
        if until is not None:
            params["until"] = until

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetNetworkPrivateResponse.from_dict(response)
        return response

    def get_all_add_element_requests(self, *, direction: typing.Optional[str] = None, limit: typing.Optional[int] = None, name: typing.Optional[str] = None, offset: typing.Optional[int] = None, requested_by: typing.Optional[int] = None, since: typing.Optional[str] = None, sort: typing.Optional[str] = None, status: typing.Optional[str] = None, type: typing.Optional[str] = None, until: typing.Optional[str] = None) -> GetNetworkPrivateNetworkEntityRequestAllResponse:
        """ Gets a list requests to add elements to the [Private API Network](https://learning.postman.com/docs/collaborating-in-postman/adding-private-network/). """
        endpoint = f"/network/private/network-entity/request/all"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if direction is not None:
            params["direction"] = direction
        if limit is not None:
            params["limit"] = limit
        if name is not None:
            params["name"] = name
        if offset is not None:
            params["offset"] = offset
        if requested_by is not None:
            params["requested_by"] = requested_by
        if since is not None:
            params["since"] = since
        if sort is not None:
            params["sort"] = sort
        if status is not None:
            params["status"] = status
        if type is not None:
            params["type"] = type
        if until is not None:
            params["until"] = until

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetNetworkPrivateNetworkEntityRequestAllResponse.from_dict(response)
        return response

    def fetch_all_group_resources(self, *, count: typing.Optional[float] = None, filter: typing.Optional[str] = None, start_index: typing.Optional[float] = None) -> GetScimV2GroupsResponse:
        """ Gets information about all Postman team members. """
        endpoint = f"/scim/v2/Groups"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if count is not None:
            params["count"] = count
        if filter is not None:
            params["filter"] = filter
        if start_index is not None:
            params["start_index"] = start_index

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetScimV2GroupsResponse.from_dict(response)
        return response

    def fetch_group_resource(self, *, group_id: str) -> GetScimV2GroupsGroupIDResponse:
        """ Gets information about a Postman group within the team. """
        endpoint = f"/scim/v2/Groups/{group_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetScimV2GroupsGroupIDResponse.from_dict(response)
        return response

    def get_resource_types(self) -> typing.List[GetScimV2ResourceTypesResponseItem]:
        """ Gets all the resource types supported by Postman&#x27;s SCIM API. """
        endpoint = f"/scim/v2/ResourceTypes"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = self._cast_list(response, GetScimV2ResourceTypesResponseItem)
        return response

    def service_provider_config(self) -> GetScimV2ServiceProviderConfigResponse:
        """ Gets the Postman SCIM API configuration information. This includes a list of supported operations. """
        endpoint = f"/scim/v2/ServiceProviderConfig"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetScimV2ServiceProviderConfigResponse.from_dict(response)
        return response

    def fetch_all_user_resources(self, *, count: typing.Optional[float] = None, filter: typing.Optional[str] = None, start_index: typing.Optional[float] = None) -> GetScimV2UsersResponse:
        """ Gets information about all Postman team members. """
        endpoint = f"/scim/v2/Users"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if count is not None:
            params["count"] = count
        if filter is not None:
            params["filter"] = filter
        if start_index is not None:
            params["start_index"] = start_index

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetScimV2UsersResponse.from_dict(response)
        return response

    def fetch_user_resource(self, *, user_id: str) -> GetScimV2UsersUserIDResponse:
        """ Gets information about a Postman team member. """
        endpoint = f"/scim/v2/Users/{user_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetScimV2UsersUserIDResponse.from_dict(response)
        return response

    def get_secret_types(self) -> GetSecretTypesResponse:
        """ Gets the metadata of the secret types supported by Postman&#x27;s [Secret Scanner](https://learning.postman.com/docs/administration/secret-scanner/). You can use a secret type&#x27;s ID in the response to query data with the POST &#x60;/detected-secrets/{secretId}&#x60; endpoint. """
        endpoint = f"/secret-types"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetSecretTypesResponse.from_dict(response)
        return response

    def get_tagged_entities(self, *, slug: str, cursor: typing.Optional[str] = None, direction: typing.Optional[str] = None, entity_type: typing.Optional[str] = None, limit: typing.Optional[int] = None) -> GetTagsSlugEntitiesResponse:
        """ Gets Postman elements (entities) by a given tag. Tags enable you to organize and search [workspaces](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/managing-workspaces/#tagging-a-workspace), [APIs](https://learning.postman.com/docs/designing-and-developing-your-api/managing-apis/#tagging-apis), and [collections](https://learning.postman.com/docs/collections/using-collections/#tagging-a-collection) that contain shared tags. -  - **Note:** -  - Tagging is available on [Postman Enterprise plans](https://www.postman.com/pricing/). """
        endpoint = f"/tags/{slug}/entities"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if cursor is not None:
            params["cursor"] = cursor
        if direction is not None:
            params["direction"] = direction
        if entity_type is not None:
            params["entity_type"] = entity_type
        if limit is not None:
            params["limit"] = limit

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetTagsSlugEntitiesResponse.from_dict(response)
        return response

    def all_workspaces(self, *, type: typing.Optional[str] = None) -> GetWorkspacesResponse:
        """ Gets all [workspaces](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/creating-workspaces/). The response includes your workspaces and any workspaces that you have access to. -  - **Note:** -  - This endpoint&#x27;s response contains the visibility field. Visibility determines who can access the workspace: -  - - &#x60;personal&#x60; — Only you can access the workspace. - - &#x60;team&#x60; — All team members can access the workspace. - - &#x60;private&#x60; — Only invited team members can access the workspace ([Professional and Enterprise plans only](https://www.postman.com/pricing)). - - &#x60;public&#x60; — Everyone can access the workspace. - - &#x60;partner&#x60; — Only invited team members and [partners](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/partner-workspaces/) can access the workspace ([Enterprise Ultimate plans](https://www.postman.com/pricing) only). -  """
        endpoint = f"/workspaces"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if type is not None:
            params["type"] = type

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetWorkspacesResponse.from_dict(response)
        return response

    def single_workspace(self, *, workspace_id: str) -> GetWorkspacesWorkspaceIDResponse:
        """ Gets information about a workspace. -  - **Note:** -  - This endpoint&#x27;s response contains the &#x60;visibility&#x60; field. [Visibility](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/managing-workspaces/#changing-workspace-visibility) determines who can access the workspace: -  - - &#x60;personal&#x60; — Only you can access the workspace. - - &#x60;team&#x60; — All team members can access the workspace. - - &#x60;private&#x60; — Only invited team members can access the workspace ([Professional and Enterprise plans only](https://www.postman.com/pricing)). - - &#x60;public&#x60; — Everyone can access the workspace. - - &#x60;partner&#x60; — Only invited team members and [partners](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/partner-workspaces/) can access the workspace ([Enterprise Ultimate plans](https://www.postman.com/pricing) only). -  - ### Important -  - We have **deprecated** the &#x60;name&#x60; and &#x60;uid&#x60; responses in the following array of objects: -  - - &#x60;collections&#x60; - - &#x60;environments&#x60; - - &#x60;mocks&#x60; - - &#x60;monitors&#x60; - - &#x60;apis&#x60; -  """
        endpoint = f"/workspaces/{workspace_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetWorkspacesWorkspaceIDResponse.from_dict(response)
        return response

    def get_workspace_global_variables(self, *, workspace_id: str) -> GetWorkspacesWorkspaceIDGlobalVariablesResponse:
        """ Gets a workspace&#x27;s global [variables](https://learning.postman.com/docs/sending-requests/variables/#variable-scopes). """
        endpoint = f"/workspaces/{workspace_id}/global-variables"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetWorkspacesWorkspaceIDGlobalVariablesResponse.from_dict(response)
        return response

    def get_workspace_tags(self, *, workspace_id: str) -> GetWorkspacesWorkspaceIDTagsResponse:
        """ Gets all the tags associated with a workspace. """
        endpoint = f"/workspaces/{workspace_id}/tags"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.get(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = GetWorkspacesWorkspaceIDTagsResponse.from_dict(response)
        return response

    def patch_collection(self, *, data: PatchCollectionsCollectionIDBody, collection_id: str) -> PatchCollectionsCollectionIDResponse:
        """ Updates specific collection information, such as its name, events, or its variables. For more information about the &#x60;auth&#x60;, &#x60;variables&#x60;, and &#x60;events&#x60; properties, refer to the [collection.json schema file](https://schema.postman.com/json/collection/v2.1.0/collection.json): -  - - For &#x60;variables&#x60;, refer to &#x60;&quot;#/definitions/variable&quot;&#x60;. - - For &#x60;auth&#x60;, refer to &#x60;&quot;#/definitions/auth-attribute&quot;&#x60;. - - For &#x60;events&#x60;, refer to &#x60;&quot;#/definitions/event&quot;&#x60;. -  - For more information about the Collection Format, see the [Postman Collection Format documentation](https://learning.postman.com/collection-format/getting-started/overview/). -  """
        endpoint = f"/collections/{collection_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.patch(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PatchCollectionsCollectionIDResponse.from_dict(response)
        return response

    def patch_scim_v2_groups_group_id(self, *, data: PatchScimV2GroupsGroupIDBody, group_id: str) -> PatchScimV2GroupsGroupIDResponse:
        """ Updates a group&#x27;s information. Using this endpoint you can: -  - - Update a group&#x27;s name. - - Add or remove members from a Postman group. -  """
        endpoint = f"/scim/v2/Groups/{group_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.patch(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PatchScimV2GroupsGroupIDResponse.from_dict(response)
        return response

    def update_user_state(self, *, data: PatchScimV2UsersUserIDBody, user_id: str) -> PatchScimV2UsersUserIDResponse:
        """ Updates a user&#x27;s active state in Postman. -  - ### Reactivating users -  - By setting the &#x60;active&#x60; property from &#x60;false&#x60; to &#x60;true&#x60;, this reactivates an account. This allows the account to authenticate in to Postman and adds the account back on to your Postman team. -  """
        endpoint = f"/scim/v2/Users/{user_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.patch(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PatchScimV2UsersUserIDResponse.from_dict(response)
        return response

    def create_api(self, *, data: PostApisBody, workspace_id: str) -> PostApisResponse:
        """ Creates an API. """
        endpoint = f"/apis"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        params["workspace_id"] = workspace_id

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostApisResponse.from_dict(response)
        return response

    def add_collection(self, *, data: typing.Any, api_id: str) -> PostApisAPIIDCollectionsResponse:
        """ Adds a collection to an API. To do this, use the following &#x60;operationType&#x60; values: -  - - &#x60;COPY_COLLECTION&#x60; — Copies a collection from the workspace and adds it to an API. - - &#x60;CREATE_NEW&#x60; — Creates a new collection by providing the new collection&#x27;s content. - - &#x60;GENERATE_FROM_SCHEMA&#x60; — Generates the collection from an API schema. -     - &#x60;options&#x60; — An object that contains advanced creation options and their values. You can find a complete list of properties and their values in Postman&#x27;s OpenAPI 3.0 to Postman Collection v2.1.0 Converter OPTIONS documentation. These properties are case-sensitive. -  """
        endpoint = f"/apis/{api_id}/collections"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostApisAPIIDCollectionsResponse.from_dict(response)
        return response

    def create_api_schema(self, *, data: PostApisAPIIDSchemasBody, api_id: str) -> PostApisAPIIDSchemasResponse:
        """ Creates a schema for an API. """
        endpoint = f"/apis/{api_id}/schemas"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostApisAPIIDSchemasResponse.from_dict(response)
        return response

    def create_api_version(self, *, data: typing.Any, api_id: str) -> PostApisAPIIDVersionsResponse:
        """ Creates a new API version asynchronously and immediately returns an HTTP &#x60;202 Accepted&#x60; response. The response contains a polling link to the task status API in the &#x60;Location&#x60; header. -  - This endpoint is equivalent to publishing a version in Postman app, which is the snapshot of API collections and schema at a given point in time. -  """
        endpoint = f"/apis/{api_id}/versions"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostApisAPIIDVersionsResponse.from_dict(response)
        return response

    def create_collection(self, *, data: PostCollectionsBody, workspace_id: typing.Optional[str] = None) -> PostCollectionsResponse:
        """ Creates a collection using the [Postman Collection v2 schema format](https://schema.postman.com/json/collection/v2.1.0/docs/index.html). -  - For more information about the Collection Format, see the [Postman Collection Format documentation](https://learning.postman.com/collection-format/getting-started/overview/). -  - **Note:** -  - - For a complete list of available property values for this endpoint, use the following references available in the [collection.json schema file](https://schema.postman.com/json/collection/v2.1.0/collection.json): -     - &#x60;info&#x60; object — Use the &#x60;definitions.info&#x60; entry. -     - &#x60;item&#x60; object — Use the &#x60;definitions.items&#x60; entry. - - For all other possible values, refer to the [collection.json schema file](https://schema.postman.com/json/collection/v2.1.0/collection.json). -  """
        endpoint = f"/collections"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if workspace_id is not None:
            params["workspace_id"] = workspace_id

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostCollectionsResponse.from_dict(response)
        return response

    def create_a_fork(self, *, data: PostCollectionsForkCollectionIDBody, collection_id: str, workspace: str) -> PostCollectionsForkCollectionIDResponse:
        """ Creates a [fork](https://learning.postman.com/docs/collaborating-in-postman/version-control/#creating-a-fork) from an existing collection into a workspace. """
        endpoint = f"/collections/fork/{collection_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        params["workspace"] = workspace

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostCollectionsForkCollectionIDResponse.from_dict(response)
        return response

    def merge_a_fork(self, *, data: PostCollectionsMergeBody) -> PostCollectionsMergeResponse:
        """ Merges a forked collection back into its destination collection. """
        endpoint = f"/collections/merge"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostCollectionsMergeResponse.from_dict(response)
        return response

    def create_collection_folder(self, *, data: PostCollectionsCollectionIDFoldersBody, collection_id: str) -> PostCollectionsCollectionIDFoldersResponse:
        """ Creates a folder in a collection. For a complete list of properties, refer to &quot;Folder&quot; in the [collection.json schema file](https://schema.postman.com/collection/json/v2.1.0/draft-07/collection.json). -  - You can use this endpoint to to import requests and responses into a newly-created folder. To do this, include the &#x60;requests&#x60; field and the list of request objects in the request body. For more information, see the provided example. -  - **Note:** -  - It is recommended that you pass the &#x60;name&#x60; property in the request body. If you do not, the system uses a null value. As a result, this creates a folder with a blank name. -  """
        endpoint = f"/collections/{collection_id}/folders"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostCollectionsCollectionIDFoldersResponse.from_dict(response)
        return response

    def create_collection_request(self, *, data: PostCollectionsCollectionIDRequestsBody, collection_id: str, folder_id: typing.Optional[str] = None) -> PostCollectionsCollectionIDRequestsResponse:
        """ Creates a request in a collection. For a complete list of properties, see the [Collection Format Request documentation](https://learning.postman.com/collection-format/reference/request/). -  - **Note:** -  - It is recommended that you pass the &#x60;name&#x60; property in the request body. If you do not, the system uses a null value. As a result, this creates a request with a blank name. -  """
        endpoint = f"/collections/{collection_id}/requests"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if folder_id is not None:
            params["folder_id"] = folder_id

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostCollectionsCollectionIDRequestsResponse.from_dict(response)
        return response

    def create_collection_response(self, *, data: PostCollectionsCollectionIDResponsesBody, collection_id: str, request_id: str) -> PostCollectionsCollectionIDResponsesResponse:
        """ Creates a request response in a collection. For a complete list of properties, see the [Collection Format Response documentation](https://learning.postman.com/collection-format/reference/response/#reference-diagram). -  - **Note:** -  - It is recommended that you pass the &#x60;name&#x60; property in the request body. If you do not, the system uses a null value. As a result, this creates a response with a blank name. -  """
        endpoint = f"/collections/{collection_id}/responses"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        params["request_id"] = request_id

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostCollectionsCollectionIDResponsesResponse.from_dict(response)
        return response

    def detected_secrets_queries(self, *, data: PostDetectedSecretsQueriesBody, cursor: typing.Optional[str] = None, include: typing.Optional[str] = None, limit: typing.Optional[int] = None) -> PostDetectedSecretsQueriesResponse:
        """ Returns all secrets detected by Postman&#x27;s [Secret Scanner](https://learning.postman.com/docs/administration/secret-scanner/), grouped by workspace. If you pass an empty request body, this endpoint returns all results. """
        endpoint = f"/detected-secrets-queries"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if cursor is not None:
            params["cursor"] = cursor
        if include is not None:
            params["include"] = include
        if limit is not None:
            params["limit"] = limit

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostDetectedSecretsQueriesResponse.from_dict(response)
        return response

    def create_environment(self, *, data: PostEnvironmentsBody, workspace_id: typing.Optional[str] = None) -> PostEnvironmentsResponse:
        """ Creates an environment. """
        endpoint = f"/environments"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if workspace_id is not None:
            params["workspace_id"] = workspace_id

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostEnvironmentsResponse.from_dict(response)
        return response

    def import_external_api_specification(self, *, data: typing.Any, workspace_id: typing.Optional[str] = None) -> PostImportOpenapiResponse:
        """ Imports an OpenAPI definition into Postman as a new [Postman Collection](https://learning.postman.com/docs/getting-started/creating-the-first-collection/). """
        endpoint = f"/import/openapi"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if workspace_id is not None:
            params["workspace_id"] = workspace_id

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostImportOpenapiResponse.from_dict(response)
        return response

    def create_mock(self, *, data: PostMocksBody, workspace_id: typing.Optional[str] = None) -> PostMocksResponse:
        """ **In Postman v10 and higher you cannot create mocks for collections added to an API definition.** -  - Creates a mock server in a collection. -  """
        endpoint = f"/mocks"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if workspace_id is not None:
            params["workspace_id"] = workspace_id

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostMocksResponse.from_dict(response)
        return response

    def publish_mock(self, *, mock_id: str) -> PostMocksMockIDPublishResponse:
        """ Publishes a mock server. Publishing a mock server sets its **Access Control** configuration setting to public. """
        endpoint = f"/mocks/{mock_id}/publish"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.post(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostMocksMockIDPublishResponse.from_dict(response)
        return response

    def create_server_response(self, *, data: PostMocksMockIDServerResponsesBody, mock_id: str) -> typing.List[PostMocksMockIDServerResponsesResponseItem]:
        """ Creates a server response. Server responses let you simulate 5xx server-level responses, such as 500 or 503. -  - Server-level responses are agnostic to application-level logic. Server responses let you simulate this behavior on a mock server. You do not need to define each error for all exposed paths on the mock server. -  - If you set a server response as active, then all the calls to the mock server return with that active server response. -  - **Note:** -  - You can create multiple server responses for a mock server, but only one mock server can be set as active. -  """
        endpoint = f"/mocks/{mock_id}/server-responses"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = self._cast_list(response, PostMocksMockIDServerResponsesResponseItem)
        return response

    def create_monitor(self, *, data: PostMonitorsBody, workspace_id: typing.Optional[str] = None) -> PostMonitorsResponse:
        """ **In Postman v10 and higher you cannot create monitors for collections added to an API definition.** -  - Creates a monitor. -  """
        endpoint = f"/monitors"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if workspace_id is not None:
            params["workspace_id"] = workspace_id

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostMonitorsResponse.from_dict(response)
        return response

    def run_a_monitor(self, *, monitor_id: str) -> PostMonitorsMonitorIDRunResponse:
        """ Runs a monitor and returns its run results. """
        endpoint = f"/monitors/{monitor_id}/run"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.post(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostMonitorsMonitorIDRunResponse.from_dict(response)
        return response

    def post_element_or_folder(self, *, data: typing.Any) -> typing.Any:
        """ Publishes a element or creates a folder in your [Private API Network](https://learning.postman.com/docs/collaborating-in-postman/adding-private-network/). An element is a Postman API, collection, or workspace. """
        endpoint = f"/network/private"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        return response

    def create_group(self, *, data: PostScimV2GroupsBody) -> PostScimV2GroupsResponse:
        """ Creates a new user group in Postman and creates a new account for each group member. -  - Each account is added to your Postman team and authentication is activated for each user. If an existing Postman account uses an email that matches a group member&#x27;s email ID, an [email invite](https://postman.postman.co/docs/administration/managing-your-team/managing-your-team/#invites) to join your Postman team is sent to that user. Once the user accepts the invite, they&#x27;ll be added to your team. -  - By default, the system assigns new users the developer role. You can [update user roles in Postman](https://learning.postman.com/docs/administration/managing-your-team/managing-your-team/#managing-team-roles). -  """
        endpoint = f"/scim/v2/Groups"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostScimV2GroupsResponse.from_dict(response)
        return response

    def create_user(self, *, data: PostScimV2UsersBody) -> PostScimV2UsersResponse:
        """ Creates a new user account in Postman and adds the user to your organization&#x27;s Postman team. If the account does not already exist, this also activates the user so they can authenticate in to your Postman team. -  - If the account already exists, the system sends the user an [email invite](https://learning.postman.com/docs/administration/managing-your-team/managing-your-team/#inviting-users) to join the Postman team. The user joins the team once they accept the invite. -  - By default, the system assigns new users the developer role. You can [update user roles in Postman](https://learning.postman.com/docs/administration/managing-your-team/managing-your-team/#managing-team-roles). -  """
        endpoint = f"/scim/v2/Users"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostScimV2UsersResponse.from_dict(response)
        return response

    def schema_security_validation(self, *, data: PostSecurityAPIValidationBody) -> PostSecurityAPIValidationResponse:
        """ Performs an analysis on the given definition and returns any issues based on your [predefined rulesets](https://learning.postman.com/docs/api-governance/configurable-rules/configurable-rules-overview/). This endpoint can help you understand the violations&#x27; impact and offers solutions to help you resolve any errors. You can include this endpoint to your CI/CD process to automate schema validation. -  - For more information, see our [Rule violations in the API definition](https://learning.postman.com/docs/api-governance/api-definition/api-definition-warnings/) documentation. -  - **Note:** -  - - The maximum allowed size of the definition is 10 MB. - - You must [import and enable](https://learning.postman.com/docs/api-governance/configurable-rules/configuring-api-security-rules/) [Postman&#x27;s OWASP security rules](https://postman.postman.co/api-governance/libraries/postman_owasp/view) in Postman for this endpoint to return any security rule violations. -  """
        endpoint = f"/security/api-validation"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostSecurityAPIValidationResponse.from_dict(response)
        return response

    def create_webhook(self, *, data: PostWebhooksBody, workspace_id: typing.Optional[str] = None) -> PostWebhooksResponse:
        """ Creates a webhook that triggers a collection with a custom payload. You can get the webhook&#x27;s URL from the &#x60;webhookUrl&#x60; property in the endpoint&#x27;s response. """
        endpoint = f"/webhooks"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]
        if workspace_id is not None:
            params["workspace_id"] = workspace_id

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostWebhooksResponse.from_dict(response)
        return response

    def create_workspace(self, *, data: PostWorkspacesBody) -> PostWorkspacesResponse:
        """ Creates a new [workspace](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/creating-workspaces/). -  - ### Important -  - We **deprecated** linking collections or environments between workspaces. We do **not** recommend that you do this. -  - If you have a linked collection or environment, note the following: -  - - The endpoint does **not** create a clone of a collection or environment. - - Any changes you make to a linked collection or environment changes them in **all** workspaces. - - If you delete a collection or environment linked between workspaces, the system deletes it in **all** the workspaces. -  """
        endpoint = f"/workspaces"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.post(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PostWorkspacesResponse.from_dict(response)
        return response

    def update_an_api(self, *, data: PutApisAPIIDBody, api_id: str) -> PutApisAPIIDResponse:
        """ Updates an API. """
        endpoint = f"/apis/{api_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutApisAPIIDResponse.from_dict(response)
        return response

    def sync_collection_with_schema(self, *, api_id: str, collection_id: str) -> PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse:
        """ Syncs a collection attached to an API with the API schema. -  - This is an asynchronous endpoint that returns an HTTP &#x60;202 Accepted&#x60; response. The response contains a polling link to the &#x60;/apis/{apiId}/tasks/{taskId}&#x60; endpoint in the &#x60;Location&#x60; header. -  - **Note:** -  - This endpoint only supports the OpenAPI 3 schema type. -  """
        endpoint = f"/apis/{api_id}/collections/{collection_id}/sync-with-schema-tasks"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        raw_response = self.session.put(url, params=params)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse.from_dict(response)
        return response

    def create_or_update_schema_file(self, *, data: PutApisAPIIDSchemasSchemaIDFilesFilePathBody, api_id: str, schema_id: str, file_path: str) -> PutApisAPIIDSchemasSchemaIDFilesFilePathResponse:
        """ Creates or updates an API schema file. -  - **Note:** -  - - If the provided file path exists, the file will be updated with the new contents. - - If the provided file path does **not** exist, then a new schema file will be created. - - If the file path contains a &#x60;/&#x60; (forward slash) character, then a folder is created. For example, if the file path is the &#x60;dir/schema.json&#x60; value, then a &#x60;dir&#x60; folder is created with the &#x60;schema.json&#x60; file inside. -  """
        endpoint = f"/apis/{api_id}/schemas/{schema_id}/files/{file_path}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutApisAPIIDSchemasSchemaIDFilesFilePathResponse.from_dict(response)
        return response

    def update_api_tags(self, *, data: PutApisAPIIDTagsBody, api_id: str) -> PutApisAPIIDTagsResponse:
        """ Updates an API&#x27;s associated tags. This endpoint replaces all existing tags with those you pass in the request body. """
        endpoint = f"/apis/{api_id}/tags"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutApisAPIIDTagsResponse.from_dict(response)
        return response

    def update_api_version(self, *, data: PutApisAPIIDVersionsVersionIDBody, api_id: str, version_id: str) -> PutApisAPIIDVersionsVersionIDResponse:
        """ Updates an API version. -  - **Note:** -  - This endpoint returns an HTTP &#x60;404 Not Found&#x60; response when an API version is pending publication. -  """
        endpoint = f"/apis/{api_id}/versions/{version_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutApisAPIIDVersionsVersionIDResponse.from_dict(response)
        return response

    def put_collection(self, *, data: PutCollectionsCollectionIDBody, collection_id: str) -> PutCollectionsCollectionIDResponse:
        """ Replaces the contents of a collection using the [Postman Collection v2 schema format](https://schema.postman.com/json/collection/v2.1.0/docs/index.html). Include the collection&#x27;s ID values in the request body. If you do not, the endpoint removes the existing items and creates new items. -  - For a complete list of available property values for this endpoint, use the following references available in the [collection.json schema file](https://schema.postman.com/json/collection/v2.1.0/collection.json): - - &#x60;info&#x60; object — Use &#x60;&quot;#/definitions/info&quot;&#x60;. - - &#x60;item&#x60; object — Use &#x60;&quot;#/definitions/item&quot;&#x60;. -  - For all other possible values, refer to the [collection.json schema file](https://schema.postman.com/json/collection/v2.1.0/collection.json). For more information about the Collection Format, see the [Postman Collection Format documentation](https://learning.postman.com/collection-format/getting-started/overview/). -  - **Note** -  - To copy another collection&#x27;s contents to the given collection, **remove** all ID values before you pass it in this endpoint. If you do not, this endpoint returns an error. These values include the &#x60;id&#x60;, &#x60;uid&#x60;, and &#x60;postman_id&#x60; values. -  """
        endpoint = f"/collections/{collection_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutCollectionsCollectionIDResponse.from_dict(response)
        return response

    def update_collection_folder(self, *, data: PutCollectionsCollectionIDFoldersFolderIDBody, collection_id: str, folder_id: str) -> PutCollectionsCollectionIDFoldersFolderIDResponse:
        """ Updates a folder in a collection. For a complete list of properties, refer to &quot;Folder&quot; in the [collection.json schema file](https://schema.postman.com/collection/json/v2.1.0/draft-07/collection.json). -  - **Note:** -  - This endpoint acts like a PATCH method. It only updates the values that you pass in the request body (for example, the &#x60;name&#x60; property). The endpoint does **not** update the entire resource. -  """
        endpoint = f"/collections/{collection_id}/folders/{folder_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutCollectionsCollectionIDFoldersFolderIDResponse.from_dict(response)
        return response

    def update_collection_request(self, *, data: PutCollectionsCollectionIDRequestsRequestIDBody, collection_id: str, request_id: str) -> PutCollectionsCollectionIDRequestsRequestIDResponse:
        """ Updates a request in a collection. For a complete list of properties, see the [Collection Format Request documentation](https://learning.postman.com/collection-format/reference/request/). -  - **Note:** -  - - You must pass a collection ID (&#x60;12ece9e1-2abf-4edc-8e34-de66e74114d2&#x60;), not a collection(&#x60;12345678-12ece9e1-2abf-4edc-8e34-de66e74114d2&#x60;), in this endpoint. - - This endpoint does not support changing the folder of a request. -  """
        endpoint = f"/collections/{collection_id}/requests/{request_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutCollectionsCollectionIDRequestsRequestIDResponse.from_dict(response)
        return response

    def update_collection_response(self, *, data: PutCollectionsCollectionIDResponsesResponseIDBody, collection_id: str, response_id: str) -> PutCollectionsCollectionIDResponsesResponseIDResponse:
        """ Updates a response in a collection. For a complete list of properties, see the [Collection Format Response documentation](https://learning.postman.com/collection-format/reference/response/#reference-diagram). -  - **Note:** -  - - You must pass a collection ID (&#x60;12ece9e1-2abf-4edc-8e34-de66e74114d2&#x60;), not a collection UID (&#x60;12345678-12ece9e1-2abf-4edc-8e34-de66e74114d2&#x60;), in this endpoint. - - This endpoint acts like a PATCH method. It only updates the values that you pass in the request body (for example, the &#x60;name&#x60; property). The endpoint does **not** update the entire resource. -  """
        endpoint = f"/collections/{collection_id}/responses/{response_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutCollectionsCollectionIDResponsesResponseIDResponse.from_dict(response)
        return response

    def update_collection_tags(self, *, data: PutCollectionsCollectionIDTagsBody, collection_id: str) -> PutCollectionsCollectionIDTagsResponse:
        """ Updates a collection&#x27;s associated tags. This endpoint replaces all existing tags with those you pass in the request body. """
        endpoint = f"/collections/{collection_id}/tags"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutCollectionsCollectionIDTagsResponse.from_dict(response)
        return response

    def update_detected_secret_resolutions(self, *, data: PutDetectedSecretsSecretIDBody, secret_id: str) -> PutDetectedSecretsSecretIDResponse:
        """ Updates the resolution status of a secret detected in a workspace. """
        endpoint = f"/detected-secrets/{secret_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutDetectedSecretsSecretIDResponse.from_dict(response)
        return response

    def update_environment(self, *, data: PutEnvironmentsEnvironmentIDBody, environment_id: str) -> PutEnvironmentsEnvironmentIDResponse:
        """ Updates an environment. """
        endpoint = f"/environments/{environment_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutEnvironmentsEnvironmentIDResponse.from_dict(response)
        return response

    def update_mock(self, *, data: PutMocksMockIDBody, mock_id: str) -> PutMocksMockIDResponse:
        """ Updates a mock server. """
        endpoint = f"/mocks/{mock_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutMocksMockIDResponse.from_dict(response)
        return response

    def update_server_response(self, *, data: PutMocksMockIDServerResponsesServerResponseIDBody, mock_id: str, server_response_id: str) -> typing.List[PutMocksMockIDServerResponsesServerResponseIDResponseItem]:
        """ Updates a server response. """
        endpoint = f"/mocks/{mock_id}/server-responses/{server_response_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = self._cast_list(response, PutMocksMockIDServerResponsesServerResponseIDResponseItem)
        return response

    def update_monitor(self, *, data: PutMonitorsMonitorIDBody, monitor_id: str) -> PutMonitorsMonitorIDResponse:
        """ Updates a monitor. """
        endpoint = f"/monitors/{monitor_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutMonitorsMonitorIDResponse.from_dict(response)
        return response

    def respond_element_add_request(self, *, data: PutNetworkPrivateNetworkEntityRequestRequestIDBody, request_id: int) -> PutNetworkPrivateNetworkEntityRequestRequestIDResponse:
        """ Responds to a request to add an element to the [Private API Network](https://learning.postman.com/docs/collaborating-in-postman/adding-private-network/). Only managers can approve or deny a request. Once approved, the element will appear in the team&#x27;s Private API Network. """
        endpoint = f"/network/private/network-entity/request/{request_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutNetworkPrivateNetworkEntityRequestRequestIDResponse.from_dict(response)
        return response

    def put_element_or_folder(self, *, data: typing.Any, element_type: str, element_id: str) -> typing.Any:
        """ Updates an element or folder in your [Private API Network](https://learning.postman.com/docs/collaborating-in-postman/adding-private-network/). """
        endpoint = f"/network/private/{element_type}/{element_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        return response

    def update_user_information(self, *, data: PutScimV2UsersUserIDBody, user_id: str) -> PutScimV2UsersUserIDResponse:
        """ Updates a user&#x27;s first and last name in Postman. -  - **Note:** -  - You can only use the SCIM API to update a user&#x27;s first and last name. You cannot update any other user attributes with the API. -  """
        endpoint = f"/scim/v2/Users/{user_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutScimV2UsersUserIDResponse.from_dict(response)
        return response

    def update_workspace(self, *, data: PutWorkspacesWorkspaceIDBody, workspace_id: str) -> PutWorkspacesWorkspaceIDResponse:
        """ Updates a workspace. -  - ### Important -  - We **deprecated** linking collections or environments between workspaces. We do **not** recommend that you do this. -  - If you have a linked collection or environment, note the following: -  - - The endpoint does **not** create a clone of a collection or environment. - - Any changes you make to a linked collection or environment changes them in **all** workspaces. - - If you delete a collection or environment linked between workspaces, the system deletes it in **all** the workspaces. -  """
        endpoint = f"/workspaces/{workspace_id}"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutWorkspacesWorkspaceIDResponse.from_dict(response)
        return response

    def put_workspace_global_variables(self, *, data: PutWorkspacesWorkspaceIDGlobalVariablesBody, workspace_id: str) -> PutWorkspacesWorkspaceIDGlobalVariablesResponse:
        """ Updates and replaces a workspace&#x27;s global [variables](https://learning.postman.com/docs/sending-requests/variables/#variable-scopes). This endpoint replaces all existing global variables with the variables you pass in the request body. """
        endpoint = f"/workspaces/{workspace_id}/global-variables"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutWorkspacesWorkspaceIDGlobalVariablesResponse.from_dict(response)
        return response

    def update_workspace_tags(self, *, data: PutWorkspacesWorkspaceIDTagsBody, workspace_id: str) -> PutWorkspacesWorkspaceIDTagsResponse:
        """ Updates a workspace&#x27;s associated tags. This endpoint replaces all existing tags with those you pass in the request body. """
        endpoint = f"/workspaces/{workspace_id}/tags"
        url = f"{self.base_url}{endpoint}"

        params = {} #type: dict[str, typing.Any]

        json_data = self._to_json_encodable(data)
        raw_response = self.session.put(url, params=params, json=json_data)
        
        response = raw_response.json() if raw_response.ok else self._raise_exception(raw_response)
        response = PutWorkspacesWorkspaceIDTagsResponse.from_dict(response)
        return response


