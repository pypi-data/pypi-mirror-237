use std::collections::HashMap;
use std::fs::OpenOptions;
use std::io::{Error, Write};
use pyo3::{Python};
use crate::tree::game::Game;
use crate::tree::node::Decision;
use crate::tree::utility::*;

// Struct for hashing information sets
#[derive(Debug, Eq, PartialEq, Hash, Clone)]
struct SetKey(usize, String);

pub fn write_to_file(game: Game, scale: f32, file_path: &str, py: Python)
    -> Result<(), Error> {
    let latex = generate_latex(game, scale, py);

    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .open(file_path)?;
    file.write_all(latex.as_ref())?;
    Ok(())
}
pub fn generate_latex(game: Game, scale: f32, py: Python) -> String {
    // seperate style from nodes
    // leave style detailes for users in latex
    // idealy choose level distance based on average player, or action name lengths
    let root_name = game.root.borrow(py).clone().children[0].borrow(py).clone().player.name.clone();
    let mut information_sets= HashMap::new().to_owned();
    let node_string = traverse_tree(game.root.borrow(py).clone(), 0, &mut information_sets, true, py);

    let begin = format!(r#"%%       Generated by stratpy       %%
% remember to include \usepackage{{tikz}}
% and \usetikzlibrary{{calc}}
\begin{{figure}}[h]
\begin{{tikzpicture}}[scale={scale}]"#);

    let root = format!("\n% The Tree\n\\node(0)[solid,label=above:{{{root_name}}}]{{}}");
    let info_set = add_information_set(&mut information_sets);

    let end = format!("\n\\end{{tikzpicture}}\n\\end{{figure}}");


    begin + style() + &*root + &*node_string + ";" + &*info_set + &*end
}

fn style() -> &'static str{
    // TODO: auto adjust distancing
    "\n
% Style for nodes
\\tikzstyle{solid}=[circle,draw,inner sep=1.2,fill=black]
\\tikzstyle{hollow}=[circle,draw,inner sep=1.2]\
\n% Spacing for every level of the tree
\\tikzstyle{level 1}=[level distance=10mm,sibling distance=35mm]
\\tikzstyle{level 2}=[level distance=15mm,sibling distance=15mm]"
}

//Traverses tree adding nodes to string and the ids of nodes sharing
// information set to the information_set Vec.

// creating a list style iterative recursive function to traverse the tree
fn traverse_tree(node: Decision, i:usize, information_set: &mut HashMap<SetKey,Vec<usize>>, is_root: bool, py: Python) -> String {
    let dir = if i == 0 {"left"} else {"right"};
    let (node_id, edge_label) = (node.id, node.name);
    let (node_type, label) = match node.utility {
        Utility::Numeral(x) => {
            let utility = format!("({}, {})", x[0], x[1]);
            ("hollow", format!("label=below:{{${utility}$}}"))
        },
        Utility::Variable(x) => {
            let utility = format!("({}, {})", x[0].name, x[1].name);
            ("hollow", format!("label=below:{{${utility}$}}"))
        }
        Utility::None => {
            let player_name = if let Some(_) = node.information_set {
                "".to_string()
            } else {
                node.children[0].borrow(py).player.name.clone()
            };

            ("solid", format!("label=above {dir}:{{{player_name}}}"))
        }
    };
    // if the node is part of an information set, push that value to a hashmap, creating a vec,
    // if it doesn't already exist
    if let Some(set_id) = node.information_set {
        information_set.entry(
            SetKey(set_id, node.children[0].borrow(py).player.name.clone()))
            .or_insert(Vec::new()).push(node.id);
    }
    let mut child_s = String::new();
    for (i, child) in node.children.iter().enumerate(){
        child_s.push_str(&*traverse_tree(child.borrow(py).clone(), i, information_set, false, py))
    }
    if is_root {
        child_s
    } else {
        let node_s = format!(r#"child{{node({node_id})[{node_type}, {label}]{{}}
    {child_s}edge from parent node[{dir}]{{${edge_label}$}}}}"#);
        node_s
    }
}

// Add's information set to the exported latex with default style
fn add_information_set(information_set: &mut HashMap<SetKey,Vec<usize>>) -> String {
    if information_set.is_empty(){ return "".to_string() }
    let mut set_string = String::from("% information set\n");
    for key in information_set.keys() {
        let (_id, name) = (key.0, key.1.clone());
        if let Some(value) = information_set.get(key){
            let (node1, node2) = (value[0], value[1]);
            set_string.push_str(&*format!("\\draw[dashed,rounded corners=10]($({node1}) \
            + (-.1,.125)$)rectangle($({node2}) +(.1,-.125)$);\n\
            \\node at ($({node1})!.5!({node2})$) {{{name}}};"))
        }

    }
    set_string
}


#[cfg(test)]
mod tests {
    //use super::*;
    #[test]
    fn test_latex_string() {
        //println!("{}", latex_writer())
    }

}

