def help_():
    print('''
        Библиотека содержит решенные задания.
        Чтобы получить доступ к заданию используйте цифры 1-11.
        Вводите их в функцию task().

        Чтобы получить доступ к библиоткеам введите libs()
        ''')


def libs():
    print('''
        import numpy as np
        from scipy.stats import *
        from itertools import permutations, combinations, product
        import matplotlib.pyplot as plt
        import seaborn as sns
        import scipy.stats as scs
        import mpmath as mp
        from fractions import Fraction
    ''')


def task(num):
    dc = {
        1: '''
        Условие:
            В группе учится 29 студентов. 
            Ими были получены следующие 100-балльные оценки: 53, 34, 61, 58, 83, 74, 0, 87, 0, 79, 95, 58, 0, 60, 23, 58, 62, 60, 16, 76, 82, 91, 79, 51, 68, 30, 73, 71, 51. Найдите: 
            1) A – среднюю положительную оценку в группе; 
            2) M – медиану положительных оценок в группе; 
            3) H – среднее гармоническое и G – среднее геометрическое оценок, которые не менее M; 
            4) Q – медианную оценку в той части группы, в которой студенты набрали не менее M баллов; 
            5) N – количество студентов, оценки которых оказались между H и Q (включая границы).
        Код:
            marks = np.array([90, 79, 53, 62, 66, 68, 75, 0, 82, 29, 0, 29, 68, 90, 0, 60, 44, 44, 70, 68, 70, 89, 0, 68, 0, 66, 0, 59, 70])

            print(marks[marks>0].mean())

            M = np.median(marks[marks!=0])
            print(M)

            H = scs.hmean(marks[marks>=M])
            print(H)

            G = scs.gmean(marks[marks>=M])
            print(G)

            Q = np.median(marks[marks>=M])
            print(Q)

            print(len(marks[(marks >= min(H,Q)) & (marks <= max(H,Q))]))
        ''',
        2: '''
        Условие:
             Следующие 28 чисел – это умноженные на 10000 и округленные до ближайшего целого дневные логарифмические доходности акции компании АВС: -431, 491, -82, -48, -195, 120, -361, -53, -20, -550, 44, 64, -11, 98, -457, 135, -394, 163, 407, -62, -137, 198, 88, 151, 265, -137, -346, -466. 
             Будем называть их преобразованными доходностями (ПД). Финансовый аналитик Глеб предполагает, что преобразованные доходности (как и исходные) приближенно распределены по нормальному закону. 
             Чтобы проверить свое предположение Глеб нашел нижнюю квартиль L и верхнюю квартиль H нормального распределения N(μ,σ2), для которого μ – это среднее арифметическое ПД, 
             а σ – эмпирическое стандартное отклонение ПД. 
             Затем Глеб подсчитал количество ПД, попавших в интервал от L до H (надеясь, что в этот интервал попадет половина ПД). Результат этого вычисления показался ему недостаточно убедительным. Чтобы окончательно развеять сомнения относительно нормальности ПД, Глеб построил на одном рисунке графики функций: F^(x) и F(x)
            , где F^(x) – эмпирическая функция распределения ПД, а F(x) – функция распределения N(μ,σ2).
            В качестве меры совпадения двух графиков Глеб решил использовать расстояние d между функциями F^(x) и F(x), которое он вычислил, исходя из определения: d=sup|F^(x)−F(x)|.
            В ответе укажите результаты вычислений Глеба: 1) среднее арифметическое ПД; 2) эмпирическое стандартное отклонение ПД; 3) квартили L и H; 4) количество ПД, попавших в интервал от L до H; 5) расстояние между функциями F^(x) и F(x).

        Код:
        vals = np.array([-9, 9, -138, -145, 186, 78, 34, -37, -19, -68, -82, 158, 96, -189, 24, 84, -99, 125, -39, 26, 62, -91, 239, -211, 2, 129, 2, -16])
        v_mean = vals.mean()
        v_std = vals.std()
        v_mean, v_std
        _________________________________________________________
        X = scs.norm(v_mean, v_std)
        L = X.ppf(0.25)
        H = X.ppf(0.75)
        L, H
        _________________________________________________________
        len(vals[(vals >= L) & (vals <= H)])
        _________________________________________________________
        xsort=sorted(vals)
        n=len(xsort)
        _________________________________________________________
        res_d = float('-inf')
        for i in range(len(xsort)):
            maxx=max(abs((i+1)/n-X.cdf(xsort[i])),abs((i)/n-X.cdf(xsort[i])))
            if maxx > res_d:
                res_d = maxx
                d_ind = i
        res_d, d_ind
        ''',
        3: '''
        Условие:
            В группе Ω чатся студенты: ω1,...,ω25. Пусть X и Y – 100-балльные экзаменационные оценки по математическому анализу и теории вероятностей. Оценки студента ωi обозначаются: xi=X(ωi)
             и yi=Y(ωi)
            , i=1,...,25
            . Все оценки известны: x1=46,y1=44
            , x2=55,y2=45
            , x3=56,y3=54
            , x4=76,y4=71
            , x5=82,y5=82
            , x6=49,y6=52
            , x7=41,y7=36
            , x8=58,y8=66
            , x9=88,y9=86
            , x10=82,y10=89
            , x11=35,y11=32
            , x12=79,y12=78
            , x13=75,y13=82
            , x14=36,y14=39
            , x15=68,y15=68
            , x16=40,y16=30
            , x17=52,y17=56
            , x18=49,y18=49
            , x19=77,y19=86
            , x20=32,y20=44
            , x21=89,y21=84
            , x22=43,y22=48
            , x23=89,y23=90
            , x24=95,y24=85
            , x25=89,y25=79
            . Требуется найти следующие условные эмпирические характеристики: 
            1) ковариацию X и Y при условии, что одновременно X⩾50и Y⩾50
            2) коэффициент корреляции X и Y при том же условии.

        Код:
            import re

            s = 'x1=71,y1=71
             , x2=52,y2=58
            , x3=72,y3=81
            , x4=87,y4=92
            , x5=81,y5=81
            , x6=100,y6=94
            , x7=90,y7=96
            , x8=54,y8=46
            , x9=54,y9=60
            , x10=58,y10=62
            , x11=56,y11=49
            , x12=70,y12=60
            , x13=93,y13=86
            , x14=46,y14=48
            , x15=56,y15=61
            , x16=59,y16=52
            , x17=42,y17=40
            , x18=60,y18=60
            , x19=33,y19=37
            , x20=83,y20=92
            , x21=50,y21=57
            , x22=93,y22=93
            , x23=41,y23=42
            , x24=55,y24=64
            , x25=60,y25=59
            , x26=37,y26=30
            , x27=71,y27=71
            , x28=42,y28=44
            , x29=85,y29=82
            , x30=39,y30=39
            '
            match = re.findall(r"=('здесь должен быть слэш' d+)", s)
            x_all = list(map(int, match[::2]))
            y_all = list(map(int, match[1::2]))
            _________________________________________________________
            x = []
            y = []

            for x_t, y_t in zip(x_all, y_all):
                if x_t >= 50 and y_t >= 50:
                    x.append(x_t)
                    y.append(y_t)

            x = np.array(x)
            y = np.array(y)
            _________________________________________________________
            cov = 0
            for x_t, y_t in zip(x, y):
                cov += (x_t - x.mean()) * (y_t - y.mean())
            cov /= len(x)
            cov
            _________________________________________________________
            cov/np.sqrt(x.var()*y.var())
        ''',
        4: '''
        Условие:
            Поток Ω состоит из k групп: Ω1,...,Ωk , k=3. На потоке учатся n=n1+...+nk студентов, где ni – число студентов в группе Ωi, i=1,...,k
            Пусть X(ω) – 100-балльная оценка студента ω∈Ω
            Далее используются следующие обозначения: x¯¯¯i– среднее значение, σi – (эмпирическое) стандартное отклонение признака X на группе Ωi
            Дано: n1=22
                , n2=20
                , n3=30
                , x¯¯¯1=70
                , x¯¯¯2=76
                , x¯¯¯3=72
                , σ1=7
                , σ2=9
                , σ3=5
            Требуется найти: 
                1) среднее значение X на потоке Ω
                2) (эмпирическое) стандартное отклонение X на потоке Ω
        Код:
            n1=24
            n2=26
            n3=30
            xm1=70
            xm2=76
            xm3=77
            si1=4
            si2=6
            si3=8
            _________________________________________________________
            M = (n1 * xm1 + n2 * xm2 + n3 * xm3)/(n1 + n2 + n3)
            print(M)
            _________________________________________________________
            var_all = (n1 * (xm1 - M)**2 + n2 * (xm2 - M)**2 + n3 * (xm3 - M)**2)/(n1 + n2 + n3)
            var_mean_all = (n1 * si1**2 + n2 * si2**2 + n3 * si3**2)/(n1 + n2 + n3)
            np.sqrt(var_all + var_mean_all)
        ''',
        5: '''
        Условие:
            В группе Ω учатся 27 студентов, Ω={1,2,...,27}
            Пусть X(i) – 100-балльная оценка студента i∈Ω
            Из группы Ω случайным образом 7 раз выбирается студент ω∈Ω
            Повторный выбор допускается. Пусть ωj – студент, полученный после выбора j=1,...,7, X(ωj)– его оценка. Среднюю оценку на случайной выборке обозначим X¯¯¯¯=1/7*∑X(ωj)
            Оценки в группе даны: 100, 86, 51, 100, 95, 100, 12, 61, 0, 0, 12, 86, 0, 52, 62, 76, 91, 91, 62, 91, 65, 91, 9, 83, 67, 58, 56. Требуется найти: 
            1) дисперсию Var(X¯¯¯¯)
            2) центральный момент μ3(X¯¯¯¯)
        Код:
            grades = [100, 86, 51, 100, 95, 100, 12, 61, 0, 0, 12, 86, 0, 52, 62, 76, 91, 91, 62, 91, 65, 91, 9, 83, 67, 58, 56]
            k = 7
            # grades = [83, 100, 100, 51, 94, 53, 17, 46, 53, 76, 88, 72, 57, 53, 70, 94, 0, 95, 0, 93, 25, 23, 87, 81, 43]
            # k = 9

            grades = np.array(grades)
            n = len(grades)
            _________________________________________________________
            var = grades.var() / k
            var
            _________________________________________________________
            mu3 = np.sum((grades - grades.mean()) ** 3) / n / k ** 2
            mu3
            _________________________________________________________
            moment(grades, 3) / k ** 2
        ''',
        6: '''
        Условие:
         В группе Ω учатся 27 студентов, Ω={1,2,...,27}
            Пусть X(i) – 100-балльная оценка студента i∈Ω
            Из группы Ω случайным образом 6 раз выбирается студент ω∈Ω
            Повторный выбор допускается. Пусть ωj – студент, полученный после выбора j=1,...,6, X(ωj)– его оценка. Среднюю оценку на случайной выборке обозначим X¯¯¯¯=1/6*∑X(ωj)
            Оценки в группе даны: 100, 78, 77, 51, 82, 100, 73, 53, 78, 55, 7, 0, 81, 15, 96, 12, 71, 70, 53, 0, 73, 100, 55, 100, 59, 89, 81. Требуется найти: 
            1) математическое ожидание E(X¯¯¯¯)
            2) дисперсию Var(X¯¯¯¯)
         Код:
            grades = [100, 78, 77, 51, 82, 100, 73, 53, 78, 55, 7, 0, 81, 15, 96, 12, 71, 70, 53, 0, 73, 100, 55, 100, 59, 89, 81]
            k = 6
            # grades = [46, 86, 82, 84, 70, 72, 83, 0, 0, 53, 98, 51, 66, 45, 92, 84, 92, 76, 76, 65, 88, 0, 66, 72, 70, 90]
            # k = 5

            grades = np.array(grades)
            n = len(grades)
            _________________________________________________________
            E = grades.mean()
            E
            _________________________________________________________
            Var = grades.var() / k * (n - k) / (n - 1)
            Var
        ''',
        7: '''
        Условие:
            Распределение баллов на экзамене до перепроверки задано таблицей

            Оценка работы: 2, 3, 4, 5
            Число работ: 7, 48, 8, 105

            Работы будут перепроверять 5 преподавателей, которые разделили все работы между собой поровну случайным образом. Пусть X¯¯¯¯
            – средний балл (до перепроверки) работ, попавших к одному из преподавателей. Требуется найти: 
            1) математическое ожидание E(X¯¯¯¯)
            2) стандартное отклонение σ(X¯¯¯¯)
        Код:
            vals = [2] * 7 + [3] * 48 + [4] * 8 + [5] * 105
            k = 6
            # vals = [2] * 90 + [3] * 46 + [4] * 39 + [5] * 21
            # k = 7

            vals = np.array(vals)
            n = len(vals)
            k = n / k
            _________________________________________________________
            E = vals.mean()
            E
            _________________________________________________________
            Var = vals.var() / k * (n - k) / (n - 1)
            std = np.sqrt(Var)
            std
        ''',
        8: '''
        Условия:
        Две игральные кости, красная и синяя, подбрасываются до тех пор, пока не выпадет 19 различных (с учетом цвета) комбинаций очков. 
        Пусть Ri – число очков на красной кости, а Bi – число очков на синей кости в комбинации с номером i
        Случайные величины Xi задаются соотношениями: Xi=11Ri−9Bi,i=1,...,19
        Среднее арифметическое этих величин обозначим X¯¯¯¯=1/19*∑Xi
        Требуется найти: 
        1) математическое ожидание E(X¯¯¯¯)
        2) стандартное отклонение σ(X¯¯¯¯)

        Код:
            k = 19
            n = 36

            combs = [(r, b) for r in range(1, 7) for b in range(1, 7)]
            combs = np.array(combs)
            mean, var = combs.mean(axis=0), combs.var(axis=0)
            mean, var
            _________________________________________________________
            E = 11 * mean[0] - 9 * mean[1]
            E
            _________________________________________________________
            Var = 121 * var[0] + 81 * var[1]
            Var = Var / k * (n - k) / (n - 1)
            std = np.sqrt(Var)
            std
        ''',
        9: '''
        Условие:
            Имеется 11 пронумерованных монет. Монеты подбрасываются до тех пор, пока не выпадет 257 различных (с учетом номера монеты) комбинаций орел-решка. Пусть Xi
            – число орлов в комбинации с номером i; а X¯¯¯¯=1/257*∑Xi – среднее число орлов в полученных таким образом комбинациях. 
            Требуется найти: 
            1) математическое ожидание E(X¯¯¯¯)
            2) дисперсию Var(X¯¯¯¯)
        Код:
            k = 257
            q = 11
            # k = 486
            # q = 13

            n = 2 ** q

            lst = np.array(list(product([0, 1], repeat=11)))
            lst
            _________________________________________________________
            E = lst.mean() * q
            E
            _________________________________________________________
            Var = lst.var() * q
            Var = Var / k * (n - k) / (n - 1)
            Var
        ''',
        10: '''
        Условие:
            Эмпирическое распределение признаков X и Y на генеральной совокупности Ω={1,2,...,100} задано таблицей частот

                   Y = 1  Y = 2  Y = 3
            X=100    11     32     11
            X=400    24     11     11

            Из Ω случайным образом без возвращения извлекаются 7 элементов. Пусть X¯¯¯¯ и Y¯¯¯¯ – средние значения признаков на выбранных элементах. 
            Требуется найти: 
            1) математическое ожидание E(X¯¯¯¯)
            2) дисперсию Var(Y¯¯¯¯)
            3) коэффициент корреляции ρ(X¯¯¯¯,Y¯¯¯¯)
        Код:
            vals = [(100, 1)] * 11 + [(100, 2)] * 32 + [(100, 3)] * 11 + \
            [(400, 1)] * 24 + [(400, 2)] * 11 + [(400, 3)] * 11
            k = 7
            # vals = [(200, 2)] * 10 + [(200, 3)] * 15 + [(200, 5)] * 20 + \
            # [(400, 2)] * 11 + [(400, 3)] * 14 + [(400, 5)] * 30
            # k = 6

            vals = np.array(vals)
            n = len(vals)
            _________________________________________________________
            E = vals.mean(axis=0)[0]
            E
            _________________________________________________________
            VarY = vals.var(axis=0)[1]
            VarY = VarY / k * (n - k) / (n - 1)
            VarY
            _________________________________________________________
            cov = np.cov(vals[:, 0], vals[:, 1])[0, 1] / k * (n - k) / (n - 1)
            cov # в чём прикол почему это не работает??
            _________________________________________________________
            cov = ((vals[:, 0] * vals[:, 1]).mean() - vals[:, 0].mean() * vals[:, 1].mean()) / k * (n - k) / (n - 1)
            cov
            _________________________________________________________
            VarX = vals.var(axis=0)[0]
            VarX = VarX / k * (n - k) / (n - 1)
            VarX
            _________________________________________________________
            ro = cov / (np.sqrt(VarX) * np.sqrt(VarY))
            ro
        ''',
        11: '''
        Условие:
            Эмпирическое распределение признаков X и Y на генеральной совокупности Ω={1,2,...,100} задано таблицей частот

                   Y = 1  Y = 2  Y = 3
            X=100    21     17     12
            X=300    10     27     13

            Из Ω случайным образом без возвращения извлекаются 6 элементов. Пусть X¯¯¯¯ и Y¯¯¯¯ – средние значения признаков на выбранных элементах. 
            Требуется найти: 
            1) математическое ожидание E(Y¯¯¯¯)
            2) стандартное отклонение σ(X¯¯¯¯)
            3) ковариацию Cov(X¯¯¯¯,Y¯¯¯¯)
        Код:
            vals = [(100, 1)] * 21 + [(100, 2)] * 17 + [(100, 4)] * 12 + [(300, 1)] * 10 + [(300, 2)] * 27 + [(300, 4)] * 13
            k = 6
            # vals = [(300, 2)] * 14 + [(300, 3)] * 29 + [(300, 4)] * 10 + 
            # [(400, 2)] * 17 + [(400, 3)] * 12 + [(400, 4)] * 18
            # k = 17

            vals = np.array(vals)
            n = len(vals)
            _________________________________________________________
            E = vals.mean(axis=0)[1]
            E
            _________________________________________________________
            VarX = vals.var(axis=0)[0]
            VarX = VarX / k * (n - k) / (n - 1)
            np.sqrt(VarX)
            _________________________________________________________
            cov = ((vals[:, 0] * vals[:, 1]).mean() - vals[:, 0].mean() * vals[:, 1].mean()) / k * (n - k) / (n - 1)
            cov
        '''
    }
    return dc[num]



help_()
