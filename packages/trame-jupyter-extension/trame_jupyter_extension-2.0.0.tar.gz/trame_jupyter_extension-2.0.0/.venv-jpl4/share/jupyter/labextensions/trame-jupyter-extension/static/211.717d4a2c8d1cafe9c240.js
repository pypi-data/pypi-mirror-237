"use strict";(self.webpackChunktrame_jupyter_extension=self.webpackChunktrame_jupyter_extension||[]).push([[211],{211:(e,t,s)=>{s.r(t),s.d(t,{default:()=>m});var n=s(614),i=s(788);class o{constructor(e){this.app=e,this.kernels={},this.www="",this.endpoint="/trame-jupyter-server",this.updateExtensionLocation()}finishInitialization(){this.updateSessionMapping(),this.app.serviceManager.sessions.runningChanged.connect(this.updateSessionMapping,this)}async updateExtensionLocation(){const e=i.ServerConnection.makeSettings();this.endpoint=n.URLExt.join(e.baseUrl,"trame-jupyter-server");const t=n.URLExt.join(e.baseUrl,"trame-jupyter-server","location");let s;try{s=await i.ServerConnection.makeRequest(t,{},e)}catch(e){throw new i.ServerConnection.NetworkError(e)}const o=await s.text();if(o.length>0)try{this.www=JSON.parse(o).www}catch(e){console.log("Not a JSON response body.",s)}if(!s.ok)throw new i.ServerConnection.ResponseError(s,o.message||o);this.finishInitialization()}getKernelCode(){return`\n      import os\n      os.environ["TRAME_DISABLE_V3_WARNING"] = "1"\n      os.environ["TRAME_IFRAME_BUILDER"] = "jupyter-extension"\n      os.environ["TRAME_BACKEND"] = "jupyter"\n      os.environ["TRAME_JUPYTER_WWW"] = "${this.www}"\n      os.environ["TRAME_JUPYTER_ENDPOINT"] = "${this.endpoint}"\n    `}updateSessionMapping(){const e=this.app.serviceManager.sessions.running();let t=null;do{t=e.next();const s=t.value;if(null==s?void 0:s.kernel){const e=s.kernel.id;if(!this.kernels[e]){const t=this.app.serviceManager.kernels.connectTo({model:s.kernel,handleComms:!0});this.kernels[e]=t,t.requestExecute({silent:!0,code:this.getKernelCode()})}}}while(!t.done)}getKernelConnection(e){return this.kernels[e]}dispose(){this.app.serviceManager.sessions.runningChanged.disconnect(this.updateSessionMapping,this)}}class r{constructor(){this._listeners={}}addEventListener(e,t){let s=this._listeners[e];s||(s=new Set,this._listeners[e]=s),s.add(t)}removeEventListener(e,t){const s=this._listeners[e];s&&s.delete(t)}emit(e,t){const s=this._listeners[e];s&&s.forEach((e=>{e(t)}))}removeListeners(e){const t=this._listeners[e];t&&t.clear()}}class a extends r{constructor(e){super(),this.kernel=e,this.comm=null}open(){this.comm&&!this.comm.isDisposed||(this.comm=this.kernel.createComm("wslink_comm"),this.comm.open(),this.comm.onMsg=this.onMessage.bind(this),this.comm.onClose=this.onClose.bind(this))}send(e){this.comm?this.comm.send(e.data,void 0,e.buffers):console.error("trame::jupyter-comm::send -- NO COMM")}onMessage(e){this.emit("message",{data:e.content.data,buffers:e.buffers})}onClose(e){console.error("trame::jupyter-comm::close -- NO COMM")}}const c=function(){let e=0;return function(){const t=e;return e+=1,t.toString()}}();class h extends r{constructor(e,t){super(),this.serverName="trame",this.clientId=c(),this.readyState=0;const s=new URLSearchParams(e.location.search);s.has("server")&&(this.serverName=s.get("server")||"trame"),this.window=e,this.comm=t,this.commListener=e=>{const{data:t,buffers:s}=e,{server:n,client:i,payload:o}=t;var r;if(i===this.clientId&&n===this.serverName)if(s&&s.length>0){const e=(null==(r=s[0])?void 0:r.buffer)?s[0].buffer:s[0];e.constructor=this.window.ArrayBuffer,e.__proto__=this.window.ArrayBuffer.prototype,this.emit("message",{data:e})}else this.emit("message",{data:o})},this.comm.addEventListener("message",this.commListener),this.window.addEventListener("unload",(()=>this.close())),setTimeout((()=>{this.readyState=1,this.emit("open",{data:""})}),0)}close(){this.comm.removeEventListener("message",this.commListener),console.log("trame::jupyter-comm::close","FIXME"),this.emit("close",{data:""})}send(e){const t="string"!=typeof e,s={data:{server:this.serverName,client:this.clientId},buffers:[]};t?s.buffers=[e]:s.data.payload=e,this.comm.send(s)}set onopen(e){this.removeListeners("open"),this.addEventListener("open",e)}set onmessage(e){this.removeListeners("message"),this.addEventListener("message",e)}set onclose(e){this.removeListeners("close"),this.addEventListener("close",e)}set onerror(e){this.removeListeners("error"),this.addEventListener("error",e)}}const m={id:"trame-jupyter-extension:plugin",description:"A JupyterLab extension for trame communication layer",autoStart:!0,activate:e=>{const t=new o(e),s={},n={app:e,activeManager:t,comms:s,init:function(e){const n=e.frameElement.dataset.kernelId;if(!s[n]){const e=t.getKernelConnection(n);if(!e)throw new Error(`trame: Could not get kernel connection to ${n}`);s[n]=new a(e),s[n].open()}if(s[n])return{createWebSocket:()=>new h(e,s[n])}}};window.trameJupyter=n}}}}]);