\documentclass{article}

\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{chemformula}
\usepackage{fancyvrb}
\usepackage{listings}        
\usepackage{url}
\usepackage{color}

\definecolor{codegray}{gray}{0.95}
\lstset{language=python, basicstyle=\small\ttfamily, showstringspaces=false, tabsize=4, backgroundcolor=\color{codegray}}  
\newcommand{\code}[1]{\colorbox{codegray}{\lstinline{#1}}}
\renewcommand{\vec}[1]{\underline{\mathbf{#1}}}
\newcommand{\mat}[1]{\underline{\underline{\mathbf{#1}}}}

\newtheorem{assumption}{Assumption}
\newtheorem{definition}{Definition}

\title{Application Note: Quantitative Mass Spectrometry \\  \textit{Documentation for \textbf{quant.physics}}}

\author{Spectro Inlets}
\date{November 2020}

\begin{document}

\maketitle

\tableofcontents

\section{Introduction: a new window through which to count molecules}

A clear goal of mass spectrometry, with value in countless chemical and biochemical applications, is to determine (A) the concentration of volatile components in a liquid or, similarly, (B) the partial pressure of components of a gas. A related goal, with value in more niche applications such as catalysis and electrocatalysis research, is to determine the (C) absolute number of a particular molecule produced in a given time. 

Mass spectrometry in principle makes this possible by registering a signal at a unique subset of m/z values in response to a given analyte molecule in the liquid or gas. The physics behind this, seperated into seven transfer steps from dissolved analyte to raw signal from the detector, is described in Section \ref{sec:steps} of this Application Note and motivates our approach to quantitative mass spectrometry. Despite each of these steps being thoroughly researched and well-described in both academic literature and the documentation of commercial providers of mass spectrometer solutions, a robust, versitile, and stable on-line quantification method based on mass spectrometry has been elusive.

{\color{red} TODO: Mention previous attempts at this, explain why it is hard}.

Spectro Inlets' approaches this problem informed by two unique advantages:

\begin{itemize}
	\item 
	Spectro Inlets' core chip-based vacuum inlet technology. This is a very well-defined and highly reproducible inlet. We know the exact dimensions of the chip capillary, and can quantitatively predict the rate at which it lets molecules into the mass spectrometer.
	
	\item 
	Spectro Inlets' turn-key application, Electrochemistry - mass spectrometry (EC-MS). EC-MS enables experiments in which the absolute molecular rate at which a given molecule is entering the mass spectrometer, $\dot{n}^i$, is directly under control. This experiment, called \textit{internal calibration} and briefly described in Section \ref{sec:calibration}, gives us a direct probe of the absolute sensitivity factor $F^i_M$. This enables verification of the capillary flux.
\end{itemize}

Though these two advantages only give direct new insight into vacuum inlet, one of seven transfer functions between a dissolved analyte and a mass spec signal, it proves to be the missing piece that can bring quantitative mass spectrometry to a practical reality. Sections \ref{sec:strategy} and \ref{sec:calibration} below describe how this approach gives both practical advantages and theoretical insight. In short, it involves treating the absolute flux of molecules through the vacuum inlet as a fundamental quantity which is the key also to quantification of an analyte in a bulk liquid or gas. 

Sections \ref{sec:modules} and \ref{sec:usage} describe the code package, \texttt{quant.physics}, developed in python to represent the physics and implement the quantification strategy described in Sections \ref{sec:steps} - \ref{sec:calibration}. This Application Note serves as a general documentation of \code{quant.physics} v1.0 so code examples are provided in the text of sections \ref{sec:modules} and \ref{sec:usage}. An accompanying Ipython notebook to this document contains the code examples makes all of the included figures (unless otherwise noted), and demonstrate the modules of \code{quant.physics}. On the other hand, this Application Note falls short of prescribing experimental procedures, which is application-specific and should be developed by the user and/or documented elsewhere. 



\section{Step-by-step physics of MS} \label{sec:steps}
This section goes through all of the steps from a molecule just hanging out in the liquid to an ionized fragment of that same molecule hitting the detector of the mass spectrometer and causing a signal to be recorded or show up on our screen. It is a journey full of triumph and tragedy, dramatic twists and turns, surprises around every corner...

Except it's not! Or... maybe it's an exciting journey for an individual molecule, but millions of molecules are making this journey, so from our point of view the law of large numbers takes all the surprise out of it. We further rob individual molecules of any remaining agency by operating under the assumption of \textit{linearity}. That means that, all else equal, for a given increase in the concentration of our molecule friend in the liquid, there's a proportional increase in the signal. This is true because our molecule's journey is in fact very predictable.

It has to (1) evaporate, (2) enter the vacuum chamber, (3) get to the ionization chamber, (4) get ionized (5) fragment (or stay together), (6) make it through the mass filter, and (7) create a signal at the detector. The assumption that the signal responds linearly to amount, all else equal, depends on the \textit{transfer functions} of each of these seven steps being constant with respect to the amount of our particular molecule, at least over some concentration range. Figure \ref{fig:steps} shows an overview of these steps and their transfer functions, and the intermediate quantities whose proportionality is given by that transfer function.

Here, we describe each step, the transfer function, its dependencies, and the assumptions that support it or could further strengthen it.

\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{fig/mass spec steps.png}
	\caption{Overview of Quantification by MS. The figure for step 4 is from wikipedia and the figures for steps 6 and 7 are from the \href{Mass Spectrometry textbook}{https://www.springer.com/gp/book/9783319543970}. Made in Inkscape (.svg in tex/fig)}
	\label{fig:steps}
\end{figure}

This Section throws a lot of symbols at things, but it's a necessary framework and the following Section will reduce it so that we don't have to use too many of these symbols again. 

The analyte molecule throughout this Application Note is called $i$, and variables that depend on / are specific to molecule type will have a superscript $^i$. The m/z ratio at which we are measuring the signal is called $M$, and all variables that depend on / are specific to the state of the mass spectrometer (most importantly the mass-filtering voltages that control m/z) during detection will have a subscript $_M$. The superscript $^0$ indicates total over molecules, i.e. $\sum^i$. Other known dependencies are, to the degree possible, indicated with parentheses after the transfer function. 

\subsection{Evaporation}

In evaporation, the molecule leaves the liquid $i$, where it has concentration $c^i$, and enters the gas (in the chip sampling volume), where it has partial pressure $p^i$. The transfer function is the ratio of $p^i$ to $c^i$. This transfer function is, by definition, the Henry's-Law constant $K_\text{H}^i$:

\begin{flalign}
& \textbf{Transfer function 1:} \hspace{3cm}  p^i = K_\text{H}^i(T) c^i \label{eq:step1} & 
\end{flalign}\\

\noindent\textbf{Dependencies}

\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{fig/fig_KH.png}
	\caption{Volatility constants of a few common molecules as a function of temperature from 0 to 100 $^\circ$ C}
	\label{fig:KH}
\end{figure}

The Henry's law volatility constant is a function of temperature according to 
\begin{equation}
K_\text{H}^i(T) = K_\text{H,0}^i \cdot \exp \left(T_c^i\left(\frac{1}{T_0} - \frac{1}{T}\right)\right)\,,\label{eq:KH_of_T}
\end{equation}
where $K_\text{H,0}^i$ is the volatility constant at the standard temperature of $T_0=$298.15 [K] and $T_c^i$ is the temperature dependence constant for analyte $i$. The Henry's-Law solubility constants $H_0^i = 1/K_\text{H,0}^i$ and temperature dependence constants $T_c^i$ are tabulated for a huge collection of molecules in Sanders' compilation available at \url{http://doi.org/10.5194/acp-15-4399-2015}. 

The volatility constants of a few common molecules are shown as a function of temperature in Figure \ref{fig:KH}.\footnote{All figures, unless otherwise specified, are made in the accompanying Ipython notebook}\\

\noindent\textbf{Assumptions}

The transfer function in Equation \ref{eq:step1} is subject to the following assumptions:
\begin{assumption}
	The concentration of analyte $i$ is equal to the concentration of analyte at the membrane, i.e. $c^i(y\!=\!0) = c^i$.\label{ass:mixed}
\end{assumption}
This is the assumption that the analysis liquid is well-mixed. This implies that we are not depleting $i$ at the membrane. 
\begin{assumption}
	The Henry's Law constant does not depend on the concentration of analyte $i$.\label{ass:Henry_c}
\end{assumption}
This assumption is required for linearity. It is only expected to hold for rather dilute solutions, as Henry's-Law is defined as the limiting volatility as $c\rightarrow 0$. It is a sub-assumption of this more general assumption:
\begin{assumption}
	The Henry's Law constant does not depend on the composition of the liquid.\label{ass:Henry_l}
\end{assumption}
This is a huge assumption which should be tested experimentally for some compounds and matrices, and/or accepted as a known uncertainty for the rest (since we can't test every compound in every matrix at every temperature). It is probably only valid for dilute aqueous solutions.
\begin{assumption}
	The Henry's Law constant does not depend on the pressure or composition of the gas.\label{ass:Henry_g}
\end{assumption}
This assumption will usually hold well because at $T>300$ K and $p<10$ bar, most gases behave ideally.

\subsection{Capillary transport}

The sampling volume of the chip is constantly leaking into the vacuum chamber via the chip capillary. The transfer function is the ratio of the flux of $i$ through the capillary, $\dot{n}^i$, to its the partial pressure in the chip, $p^i$. We will assume, as described below, that the capillary truly is taking a representative sample of the sampling volume. This transfer function, then, with the assumptions below, is the total capillary flux $\dot{n}^0$ divided by the total pressure in the chip $p^0$.

\begin{flalign}
& \textbf{Transfer function 2:}  \hspace{3cm} 
\dot{n}^i = \frac{\dot{n}^0(\vec{p}, T)}{p^0} p^i \label{eq:step2} &
\end{flalign}\\

\noindent\textbf{Dependencies}


\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{fig/capillary}
	\caption{Flux of air, \ch{CH4}, and \ch{He} through the chip at two temperatures as a function of pressure according to Equation \ref{eq:capillary}}
	\label{fig:cap}
\end{figure}

The transfer function depends on total chip pressure $p^0$ and the total capillary flux, $\dot{n}^0$. $p^0$ must be measured. The capillary flux, $\dot{n}^0(\underline{\mathbf{p}}, T)$, is calculated from a number of properties of the gas flowing through the capillary as follows:

The flow of molecules through the capillary goes through at least three regimes as the pressure drops from 1 bar to high vacuum (Henriksen2009): (1) a viscous flow regime near ambient pressure, (2) a transition regime, and (3) a molecular flow regime governed by Kundsen diffusion near high vacuum. It is therefore not trivial to derive an analytical expression, but this has been done. The \textit{capillary equation} is (Daniel's PhD):
\begin{equation}
\dot{n}^0(\vec{p}, T) = \frac{1}{R T}\frac{1}{l_\text{cap}} 
\left(\left( 
\frac{\pi}{8\nu}a^4\bar{p} + \frac{2\pi}{3}a^3\bar{v} \frac {1+2\frac{2\sqrt{2}}{\sqrt{\pi}}\frac{a}{\eta}\frac{\bar{p}}{\bar{v}}} {1+2.48\frac{2\sqrt{2}}{\sqrt{\pi}}\frac{a}{\eta}\frac{\bar{p}}{\bar{v}}}
\right)
\left(p^0-p_{\mathrm{tran}}\right) 
+ 
\frac{2\pi}{3}a^3\bar{v}\left(p_{\mathrm{tran}}-p_2\right)\right) 
\;, \label{eq:capillary}
\end{equation}

Here, $p^0$ is the inlet pressure, $p_2$ is the outlet pressure ($\approx$ 0), $p_{\mathrm{tran}}=\frac{k_B T}{2 \sqrt{2}\pi s^2 a}$ is the pressure at which the transition from viscous to molecular flow occurs, $\bar{p}=\frac{p^0 + \bar{p}_{\mathrm{tran}}}{2}$ is the average pressure in the viscous flow regime, $\eta$ is the viscosity of the gas, $s$ is the molecular diameter, $\bar{v}=\sqrt{\frac{8 k_B T}{\pi m}}$ is the mean thermal velocity of the gas molecules, and $m$ is the molecular mass. Furthermore, $l_\text{cap}$ is the length of the capillary, and $a=h_\text{cap}=w_\text{cap}$ is its height and width, assumed to be equal (square cross-section). By design, $l_\text{cap} = 1\,\text{mm}$, $w_\text{cap} = 6\,\mu\text{m}$, and $h_\text{cap} = 6\,\mu\text{m}$. This equation is plotted for a few common gases in \ref{fig:cap}


The capillary equation thus depends on the viscosity $\eta$, molecular diameter $s$, and molecular mass $m$ of the gas in the sampling volume. These can be looked up for a pure gas. But what if the gas in the sampling volume is a mixture? 

For the viscosity, we rely on the viscosity of mixtures calculation in Davidson1993 (\url{https://stacks.cdc.gov/view/cdc/10045/cdc_10045_DS1.pdf}), which takes the molecular masses, viscosities, and mol fractions of the components and applies the kinetic theory of gases. An example (\ch{O2} in \ch{He}) is shown in Figure \ref{fig:eta}.

\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{fig/viscosity_of_mixture}
	\caption{Viscosity of a He-\ch{O2} calculated by weighted average (black dotted) and by the method in Davidson1993 (red solid). The increased viscosity has to do with the inefficient transfer of momentum between the smaller He and larger \ch{O2}}
	\label{fig:eta}
\end{figure}

For molecular diameter and molecular mass, we rely (for now) simply on a weighted average. Since the mol fraction of a component is proportional to its partial pressure, we can write this for a property $X$ as
\begin{equation}
X = \frac{\sum_i p^i X^i}{p^0}
\end{equation}

The capillary flux equation also depends on the capillary geometry. It assumes that the depth=width=$a$ and the length=$l_\text{cap}$. The unique ability our company comes with is to verify this, so that it is no longer an assumption. As seen in Figure \ref{fig:steps} and described in more detail in Section \ref{sec:calibration}, the capillary flux can be isolated by comparing internal and semi-internal calibrations. The easiest way to do this in practice is to compare the signal at m/z=32 for \ch{O2} made by electrochemical oxygen evolution (known $\dot{n}^i$) and for \ch{O2} in air (known $p^i$), and then equate the two by replacing $l_\text{cap}$ with $l_\text{eff}$. In reality, it is the depth that varies and not the length. $l_\text{eff}$ is typically within $\pm$3\% of the actual $l_\text{cap}=1$mm.\\

\noindent\textbf{Assumptions}

\begin{assumption}
	A transport property of a mixed gas is the mol-weighted average of that transport property for its components.\label{ass:gas_average}
\end{assumption}

The transfer function in Equaition \ref{eq:step2} is subject to the following assumptions:
\begin{assumption}
	The partial pressure at the capillary inlet is equal to the partial pressure at the membrane, i.e. $p^i=p^i(y\!=\!0)$, i.e., the gas is well-mixed.\label{ass:mixed_p}
\end{assumption}
This assumption is analogous to Assumption \ref{ass:mixed}. I am highly confident in it, since gas diffusion is very rapidly at the length scales of the chip sampling volume size.

\begin{assumption}
	The rate at which molecules go through the capillary is proportional to their partial pressures at the capillary enterance. In other words, the capillary has no \textit{separation} effect.\label{ass:no_separation}
\end{assumption}
This assumption is reasonable because start of the capillary is in viscous flow regime, where the whole gas moves together as a continuum fluid, so there is no separation effect due to the capillary. Maybe there are separation effects later, when the pressure drops to the molecular flow regime, but these separation effects have no way of communicating back up through the viscous flow regime to the bulk. So they can't effect the rate at which gas is entering the capillary. They can, in principle, cause a small build-up of one compound relative to another in the middle of the capillary, but at steady state (aka dynamic equilibrium), the rate at which molecules are entering has to be the rate at which molecules are exiting the capillary. 

It is interesting to note that, if Assumptions \ref{ass:mixed_p} and \ref{ass:no_separation} are met, the following assumption is \textit{not needed} for the industrial sensor:
\begin{assumption}
	(Not needed:) The capillary is the only way for gas to get out of the sampling volume. \textit{separation} effect.\label{ass:no_back_diffusion}
\end{assumption}
... in other words, that there is no back diffusion through the carrier gas delivery channels. This isn't necessary for concentration determination, since the previous assumptions imply that any analyte that back-diffuses out of the sampling volume is immediately replaced by new analyte through the equilibrium with the liquid. This assumption is, however, needed for \textit{internal calibration}, described in Section \ref{sec:calibration}.

The critical assumption, and a unique assumption for Spectro Inlets, is that we can know $\dot{n}^0$:
\begin{assumption}
	The total flux through the capillary obeys the \textit{capillary equation}.\label{ass:cap}
\end{assumption}
The capillary equation is Equation \ref{eq:capillary} below. 

Assumption \ref{ass:cap} can thus be relaxed to the following:
\begin{assumption}
	The relative total flux through the capillary obeys the \textit{capillary equation}.\label{ass:cap_1}
\end{assumption}
since the \textit{absolute} flux is no longer an assumption. The only cost is that we need Assumption \ref{ass:no_back_diffusion} during the internal (OER) calibration.

\subsection{Vacuum transport}


When a molecule has made it through the capillary into the vacuum, it has to get to the ionziation source and stay there long enough to be ionized, rather than finding its way to the pump first. The transfer function to describe this is the ratio of the partial pressure of $i$ in the ionization source $p_\text{S}^i$ to the rate at which $i$ is coming through the capillary, $\dot{n}^i$. Because this ratio depends mostly on the \textit{geometry} of the setup, defined to include the pump size and location, we'll use \textbackslash mathcal\{G\} = $\mathcal{G}$ for it.

\begin{flalign}
& \textbf{Transfer Equation 3:}\hspace{3cm} p_\text{S}^i = \mathcal{G}^i(\text{geo.}) \dot{n}^i \label{eq:step3} &
\end{flalign}\\

\noindent\textbf{Dependencies}

\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{fig/mol fraction He pump compare}
	\caption{Apparent fraction He (calibrated at 1 bar) in a 60\% He-containing gas vs chip pressure ($p^0$) with different roughing pumps and ionizatino energies. A significant increase in apparent \ch{He} fraction is observed at low pressures with the membrane pump, attributed to insufficient pumping, and a nonlinear effect of ionization further lowers He at high pressures. {\color{red}This figure includes proprietary experimental data and is not in the accompanying Ipython notebook}.}
	\label{fig:G}
\end{figure}

In principle, $\mathcal{G}^i$ may depend on properties of the molecule $i$, for example its stickiness to the vacuum walls and its molecular mass. The molecular mass influences both the ballistic transport and the pumping speed. Evidence of this is shown in Figure \ref{fig:G}.\\

\noindent\textbf{Assumptions}

We assume the following, valid to our knowledge with the use of a powerful roughing pump:
\begin{assumption}
	The vacuum transport transfer function is a constant.
\end{assumption}
Or, as an equation:
\begin{equation}
\mathcal{G} = k_{\mathcal{G}}\label{eq:G}
\end{equation}


\subsection{Ionization}

When a molecule is in the ionization source, it can get hit by an electron coming from the filament, giving it enough energy to knock one of its own electrons loose. The transfer function is the ratio of the rate at which $i$ is ionized, $\dot{n}_\text{I}^i$, to its partial pressure at the ion source, $p_\text{S}^i$. We'll call this $\mathcal{I}$.

\begin{flalign}
& \textbf{Transfer Equation 4:}\hspace{3cm} \dot{n}_{\text{I}}^i = \mathcal{I}^i(E_\text{ion}, J_\text{emis}) p_\text{S}^i \label{eq:step4}& 
\end{flalign}\\

\noindent\textbf{Dependencies}

The ionization transfer function, as indicated in Equation \ref{eq:step4}, depends on  

For a given emission current and ionization energy, the rate at which it is ionized is proportional to its cross section $\sigma^i= \sigma ^i(E_\text{ion})$:
\begin{equation}
\mathcal{I}^i \approx k_I \sigma^i \label{eq:I}
\end{equation}
These ionization cross sections are generally available in the literature, as they can be measured by calibrating an ion gauge against a pressure sensor based on another mechanism.\\

\noindent\textbf{Assumptions}

The linearity and ideality assumptions plays a role here:
\begin{assumption}
	A molecule's chances of being ionized don't depend on how many of that or other molecules there are, i.e., $\mathcal{I}^i(E_\text{ion}, J_\text{emis})$ does not depend on $\underline{p}_\text{S}$
\end{assumption}

Figure \ref{fig:G}, unfortunately, indicates that this breaks down at higher chip pressure, lower roughing pump power, and higher $J_\text{emis}$. This is the combination that would give the highest $p_\text{S}^0$ and $\mathcal{I}$. Under these conditions, $\mathcal{I}$ for the other components seems to have increased relative to $\mathcal{I^{\ch{He}}}$ with increasing $p_\text{S}$, violating the linearity assumption. However, as long as a powerful scroll pump OR $J_\text{emis}\le 1000 \mu$A is used, there is not the same significant change in apparent composition with pressure. However, there is a uniform nonlinearity that effects all molecules at $p^0>1$ bar, which is discussed in \ref{sec:signal} (under signal.py) and elsewhere.


\subsection{Fragmenting}

The transfer function for fragmentation is the rate at which fragments of mass $M$ are generated in the ion source, $\dot{n}_{\text{s}, M}$, to the total rate at which the parent molecule $i$ is ionized, $\dot{n}_{\text{I}}^i$. It is dimensionless and can be considered a probability, so we'll use \textbackslash mathcal\{P\} = $\mathcal{P}$ for it, with both $i$ and $M$ dependencies:

\begin{flalign}
& \textbf{Transfer Equation 5:}\hspace{3cm} \dot{n}_{\text{s}, M} = \mathcal{P}^i_M(E_\text{ion}) \dot{n}_{\text{I}}^i & \label{eq:step5}
\end{flalign}\\

\noindent\textbf{Dependencies}

\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{fig/CH4_spectrum}
	\caption{Normalized \ch{CH4} spectrum (cracking pattern) from the \href{https://webbook.nist.gov/cgi/cbook.cgi?ID=C74828}{NIST webbook for \ch{CH4}}.}
	\label{fig:NIST}
\end{figure}


The probability that an ionization event will result in a fragment with m/z=$M$ is very difficult to produce but straight-forward to measure. It is approximately the portion of the mass spectrum of $i$ that is peak $M$. If $I_M^i$ is the (relative) intensity at $M$ in the mass spectrum of $i$, then
\begin{equation}
\mathcal{P}^i_M \approx \frac{I_M^i}{\sum_{M'}I^i_{M'}} \label{eq:P}
\end{equation}
For this to be useful a priori, trusted reference spectra need to be available. A free and very convenient library of reference spectra exist on the NIST webbook at \url{https://webbook.nist.gov/}. Figure \ref{fig:NIST} shows $\mathcal{P}^{\ch{CH4}}_M$ according to the NIST reference spectrum for \ch{CH4}.

However, in our experience the reference spectra there are in general incomplete and/or somewhat inaccurate for most molecules as measured by quadrupole mass spectrometry in-house (See the Ipython notebook under the calibration module). The NIST reference spectra, furthermore, do not specify the ionization energy.
\\

\noindent\textbf{Assumptions}

Double-ionization is a different process than fragmentation. Double-ionization is predominantly the result of two electron impact events, whereas fragmentation is the result of excess energy from a single electron impact event. Thus, double ionization depends on $J_\text{emis}$ whereas fragmentation only depends on $E_\text{ion}$. Double ions will also have a very different detector amplification (step 7), and so should be avoided. An easily double-ionized species, Ar, should have, according to NIST, a double ion signal portion of about 10\% (this is the case for our in-house calibrations, see the Ipython notebook), and thus presumably an even smaller portion flux portion. Written as an assumption, this is simply:
\begin{assumption}
	The fraction of ions which are double ionized can be neglected from the theory.
\end{assumption}
We also assume linearity and ideality:
\begin{assumption}
	The fragmentation pattern of an ion does not depend on how many of that or other ions there are.
\end{assumption}


\subsection{Filtering}


Everything from the generation of the charged fragment at m/z=$M$ to its impacting the detector, we'll group as filtering. This may be a bit unfair to the quadrupole, since any failure of ions from the source to make it into the quadrupole, or any loss in the reflection of the filtered ion beam to the detector gets grouped in. The transfer function is the ratio of the rate at which ions at $M$ are hitting the detector, $\dot{n}_{\text{d}, M}$, to the rate at which they are generated in the ion source, $\dot{n}_{\text{s}, M}$. It is also a dimensionless probability, which we will call $\mathcal{P}_\text{T}$ where the T stands for transmission.
\begin{flalign}
& \textbf{Transfer Equation 6:}\hspace{3cm}  
\dot{n}_{\text{d}, M} = \mathcal{P}_{\text{T},M}(\text{...}) \dot{n}_{\text{s}, M} \label{eq:step6} &
\end{flalign}\\

\noindent\textbf{Dependencies}

Filtering is tricky. Ideally, the probability of an ion with m/z=$M$ being transmitted through the quadrupole filter when the quadrupole is set to filter for m/z=$M$ should be high and constant. In reality, it is not constant due in part to fringe effects right before and after the start of the quadrupole (\href{doi.org/10.1002/rcm.8094}{Joseph2018}) which effect higher masses more strongly, and in part to the fact that a narrower relative resolution is required to keep constant m/z resolution as the m/z number increases (\href{doi.org/10.1002/mas.20249}{Douglas2009}). Both of these imply it should be a function of $M$. As a working approximation, we guess that it is a constant times a power of the the m/z number $M$:
\begin{equation}
\mathcal{P}_{\text{T},M}\approx k_\text{T} M^\beta_T\, \label{eq:T}
\end{equation}\\

\noindent\textbf{Assumptions}

The only assumption we dare make here is that of linearity:
\begin{assumption}
	The probability of an ion with m/z=$M$ making it through the quadrupole does not depend on how many of that ion or other ions there are.
\end{assumption}

\subsection{Detection}

This transfer function is actually an \textit{amplification function}, the ratio of the signal generated $S_M$ to the rate at which ions of m/z=$M$ are hitting the detector, $\dot{n}_{\text{d}, M}$. It gets a \textbackslash mathcal\{A\} = $\mathcal{A}$

\begin{flalign}
& \textbf{Transfer Equation 7:}\hspace{3cm}  
S_M = \mathcal{A}_M(V_\text{CEM}) \dot{n}_{\text{d}, M} \label{eq:step7} & 
\end{flalign}

\noindent\textbf{Dependencies}

For a Faraday Cup, the ''amplication function'' is in theory just Faraday's constant:
\begin{equation}
\mathcal{A}_M \approx \mathcal{F} \,,\hspace{5mm}\text{Faraday cup}
\end{equation}
For a channel electron multiplier, the amplification factor is some much larger number that depends on the CEM voltage. It also depends on the mass of the fragment impacting the CEM. One source(\href{10.1002/rcm.8094}{Joseph2018}) says that the number of electrons ejected on the first impact (so far the same for CEM and SEM) is proportional to the inverse square root of the mass of the ion.
\begin{equation}
\mathcal{A}_M \approx k_\mathcal{A} M^{-\frac{1}{2}} \,,\hspace{5mm}\text{CEM}\label{eq:CEM}
\end{equation}

\noindent\textbf{Assumptions}

The only assumption to make here a priori is that of linearity, i.e.
\begin{assumption}
	The signal per ion impacting the detector at m/z=$M$ making it through the quadrupole does not depend on how many of that ion are hitting the detector.
\end{assumption}



\section{Quantification strategy} \label{sec:strategy}

This section applies the physics described above to suggest a strategy for quantifying signals, i.e. calculating a set of concentrations, $\vec{c}$, from a set of signals, $\vec{S}$. The key is to make a distinction between the ``external steps'' to and including the vacuum inlet (Subsection \ref{sec:H}) and the ``internal steps'' that take place in the vacuum chamber (Subsections \ref{sec:F} and \ref{sec:f}).

First, though, we have to be a bit more precise what we mean by a ``signal''.

\subsection{Defining the signal}

\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{fig/peak}
	\caption{M32-CEM peak and signal using a Gauss fit.}
	\label{fig:peak}
\end{figure}

The word signal in its broadest term just refers to the output of the mass spectrometer, i.e. raw data. However in \text{quant.physics} it takes on another meaning as well: 

\begin{definition}\label{def:signal}
	A \textbf{signal} $S_M$ is a single number in [A] resulting from a well-defined measurement by a mass spectrometer, where the subscript $M$ defines the measurement. Typically the signal is the height of the peak around an integer m/z ratio at a given mass spec setting, so $M$ is the combination of the m/z value and the setting.
\end{definition}

This can often be approximated sufficiently as the read-out of the mass spectrometer set to exactly that mass. This is called mass identification or MID, and the raw data is the signal.

A disadvantage to this simple MID is that it is sensitive to changes over time in peak center or shape. A more robust way to define the signal is \textit{advanced MID}, whereby a scan is made around a peak and its height is fit. An example of this for the peak centered around m/z=32 as measured with a CEM detector with air in the chip is shown in Figure \ref{fig:peak}. The signal is the height of the gauss curve which fits the raw data.

The convention for defining the conditions of the signal in quant is with a string starting with `M', followed by the integer that is the m/z at which the peak is centered, and then followed by a hyphen and a setting. For example, `M32-CEM' is a the height of the gauss fit of the peak centered at m/z=32 with the CEM detector and otherwise default settings. Note that this meaning $M$ is closely related to, but slightly distinct from, the meaning implied when $M$ is not a subscript, i.e. the numerical dimensionless m/z value.

We suggest using the following default settings in quantitative mass spectrometry with electron ionization and a quadrupole mass filter:
\begin{align}
E_\text{ion} &= 70\,\text{eV} \\
J_\text{emis} &= 1000\,\mu\text{A} \\
\text{width at 10\%}(\text{all peaks}) &= 0.7 \, \text{amu} \\
\text{detector} &= \text{Faraday cup (FC)}
\end{align}
We further suggest that the `CEM' setting, if not otherwise specified, should imply that the channel electron multiplier is tuned to achieve the following:
\begin{align}
S_\text{M28-CEM}(\text{air through chip at 1 bar and 298.15 C}) &= 5 \cdot 10^{-8}\,\text{[A]} \\
\end{align}

\subsection{The absolute sensitivity factor $F$ in [C/mol]}\label{sec:F}

If we just multiply the seven Transfer equations in Section \ref{sec:steps} (Equations \ref{eq:step1}, \ref{eq:step2}, \ref{eq:step3}, \ref{eq:step4}, \ref{eq:step5}, \ref{eq:step6}, and \ref{eq:step7}), we get a big transfer function which is the product of the seven transfer functions for the individual steps.
\begin{equation}
S_M = \left(
K_\text{H}^i(T)
\frac{\dot{n}^0(\vec{p}, T)}{p^0} 
\mathcal{G}^i(\text{geo.}) 
\mathcal{I}^i(E_\text{ion}, J_\text{fil})
\mathcal{P}^i_{M}(E_\text{ion})
\mathcal{P}_{\text{T},M}(\text{?})
\mathcal{A}_M(V_\text{CEM})
\right) c^i 
\end{equation}

The first two transfer functions, for \textit{evaporation} and \textit{capillary transport}, are different from the others in that they are expressed fully in know-able physical quantities and not unknown functions or constants. We therefore factor these two out (and address them below in Subsection \ref{sec:H}), leaving 
\begin{equation}
S_M = \left(
\mathcal{G}^i(\text{geo.}) 
\mathcal{I}^i(E_\text{ion}, J_\text{fil})
\mathcal{P}^i_{M}(E_\text{ion})
\mathcal{P}_{\text{T},M}(\text{?})
\mathcal{A}_M(V_\text{CEM})
\right) \dot{n}^i 
= F_M^i \dot{n}^i  \label{eq:F}
\end{equation}
where the transfer functions for the five ``internal steps'' have been grouped to one number $F_M^i$, referred to as the sensitivity factor.
\begin{definition}\label{def:F}
	The \textbf{sensitivity factor} $F^i_M$ is the change in the signal in [A] at mass $M$ in response to a change flux of the molecule $i$ in [mol/s], all else equal. It has units [A]/[mol/s] = [C/mol].
\end{definition}
The most important implication of this definition is that a sensitivity factor is an \textit{absolute} quantity, and distinct from the relative sensitivity factors more commonly reported. This is the basis of \textit{absolute quantification} in mass spectrometry which makes the new approach unique (see Soren's PhD, ch 2), made possible by Spectro Inlets' core technology and turnkey application, as described in the introduction. 

Each molecule has a sensitivity factor at each mass, though most are zero. Masses with m/z ratios at which the molecule forms fragments correspond to its non-zero sensitivity factors. Thus, \textbf{any} list of molecules (known in \code{quan.physics} as \code{mol_list}) and list of masses and settings (\code{mass_list}) together define a \textbf{sensitivity matrix} with a sensitivity factor for each molecule at each mass. This is one of the most important themes in \code{quant}.

As will be described below, sensitivity factors are an especially useful concept because they can work as the fundamental property in need of calibration for three types of quantification: absolute flux quantification (when you have $\vec{S}$ and need $\vec{\dot{n}}$ as in EC-MS), pressure quantification (when you have $\vec{S}$ and need $\vec{p}$), and concentration quantification (when you have $\vec{S}$ and need $\vec{c}$). An important implication of unifying these types of quantification is that \textit{all uncertainty is put in F}. 

Sensitivity factors should be measured in calibration experiments (Section \ref{sec:calibration}). When they can't, the assumptions and dependencies in the transfer functions of mass spectrometry presented above allow for a means of \textit{predicting} an unknown sensitivity factor based on other measured sensitivity factors, described later in Section \ref{sec:f}.


\subsection{The mass transfer coefficient $H$ in [m$^3$/s] }\label{sec:H}

The first two transfer functions - evaporation and capillary transport - can be combined to be the ``external'' transfer function, called the mass transfer coefficient $H$:
\begin{equation}
\dot{n}^i = \left(
K_\text{H}^i(T)
\frac{\dot{n}^0(\vec{p}, T)}{p^0} 
\right) c^i = H^i c^i \label{eq:H}
\end{equation}
Note that $H^i$ has units [(mol/s) / (mol/m$^3$)] = [m$^3$/s]. It can thus be understood physically as the rate that the medium is depleted of the analyte $i$ as it is removed and transported through the capillary. This understanding helps a bit with Assumption $\ref{ass:mixed}$, which depends on the liquid at the membrane not being depleted: depletion shouldn't be a problem so long as the flow rate of the liquid over the chip is significantly larger than $H^i$. On the other hand, 100\% collection efficiency requires a significantly slower flow than $H^i$ (or a residence time larger than the working volume divided by $H^i$). Typical mass transfer coefficients vary from $H^{\ch{H2}}=11$ [$\mu$l/s] to $H^{\ch{ethanol}}=52$ [pl/s] in water with \ch{He} as carrier gas at standard pressure and temperature.

The [m$^3$/s] units also differentiate $H^i$ from $h^i$ described in Trimarco2018. $h^i$ was normalized to the electrode or membrane area to give a mass transfer coefficient in [m/s].

The mass transfer coefficient $H^i$ is, however, not used that often because it is actually a useful middle step in concentration step, and often an end step on its own, to explicitly calculate the partial pressures. Thus, instead of solving Equation \ref{eq:H}, quantification will usually solve Equation \ref{eq:step2} followed by Equation \ref{eq:step1}.


\subsection{$(\vec{x}, \vec{y}) \rightarrow \vec{S} \rightarrow \vec{\dot{n}} \rightarrow \vec{p} \rightarrow \vec{c}$} \label{sec:solve}

To quantify a molecule based on mass spectrometer measurements, we have to start with raw data and end with quantification. This is the opposite direction to the flow of molecules illustrated in Figure \ref{fig:steps}. So we have to in effect go backwards through the steps described in Section \ref{sec:steps}. With the above groupings, this leads to the following procedure for calculating flux ($\vec{\dot{n}}$), pressure ($\vec{p}$), or concentration ($\vec{c}$) from a raw data like a mass spectrum ($\vec{x}$, $\vec{y}$):

\begin{itemize}
	\item $(\vec{x}, \vec{y}) \rightarrow \vec{S}$. \textbf{Correct and fit the raw data to obtain signals.} To ``correct'' the raw data in this context means (i) subtracting background if needed and (ii) correcting for non-linearity if needed. Peak fitting is then used to obtain a single value (the signal, i.e. the height of the peak) for each integer m/z ratio in the masses that will be used in the next step. The peak-fitting step can be skipped if using simple MID.
	
	\item $\vec{S} \rightarrow \vec{\dot{n}}$. \textbf{Solve one or more matrix equations involving sensitivity factors and signals to obtain fluxes.} In the simplest case, when a non-overlapping (i.e. interference-free) peak can be chosen for each possible volatile component of the medium and the chip gas, one can divide each signal element-wise by the corresponding sensitivity factor to get the flux:
	\begin{equation}
	\dot{n}^i = \frac{S_M}{F^i_M}\,, \hspace{1cm} \text{if there are no interferences.}
	\end{equation}
	This is a special case, corresponding to a diagonal sensitivity matrix. In general, one will need to solve a matrix equation with a sensitivity matrix that also has non-zero off-diagonal elements:
	\begin{equation}
	\mat{F} \, \vec{\dot{n}} = \vec{S}\,, \hspace{1cm} \text{whether or not there are interferences.}
	\end{equation}
	Here, $\mat{F}$ is the sensitivity matrix where each element $F_M^i$ is a sensitivity factor in [C/mol] for rows spanning the list of masses $M$ chosen to quantify the molecules present (\code{mass_list}) and columns spanning the list of volatile molecules $i$ present during the measurement (\code{mol_list}). These sensitivity factors should come from measurements, and if needed missing sensitivity factors can be predicted by the method in Section \ref{sec:f}.
	
	The solution to this equation, as long as $\mat{F}$ is square (i.e. $\vec{S}$ and \code{mass_list} are the same length as $\vec{\dot{n}}$ and \code{mol_list}), can be obtained just by taking the matrix inverse of $\mat{F}$:
	\begin{equation}
		\vec{\dot{n}} = \mat{F}^{-1} \vec{S}\,, \hspace{1cm} \text{if $\mat{F}$ is a square matrix.}\label{eq:Q1}
	\end{equation}
	However, it can make sense to include extra masses to get a better fit for the results. In that case, one can use a sensitivity matrix which is wider than it is tall (more masses than mols), and use a \textit{pseudo-inverse} when solving for the flux:
	\begin{equation}
	\vec{\dot{n}} = \mat{F}^{+} \vec{S}\,, \hspace{1cm} \text{if $\mat{F}$ is not a square matrix.}\label{eq:Q2}
	\end{equation}
	Here, $\mat{F}^+$ is the \href{https://en.wikipedia.org/wiki/Moore\%E2\%80\%93Penrose_inverse}{Moore-Penrose inverse} of $\mat{F}$, which minimizes the least-square error produced by the over-fitting that comes from using more masses than molecules.
	
	More complex solutions involving splitting up the problem and using multiple sensitivity matrices might also make sense and are supported in \code{quant.physics}. Choosing the sensitivity matrices is, in general, an application-specific problem requiring knowledge of the medium and the quantification needs. It must be worked out by the user or addressed in more detail elsewhere.
	
	\item $\vec{\dot{n}} \rightarrow \vec{p}$. \textbf{Find the self-consistent solution for the total capillary flux and the partial pressure of each gas in the chip.} Equation \ref{eq:step2} is gives the transfer function relating fluxes ($\vec{\dot{n}}$) to partial pressures ($\vec{p}$). 
	
	The transfer function itself, $\dot{n}^0(\vec{p}, T)/p^0$ depends on the ``answer'', the partial pressures. This is because the composition of the gas in the chip effects its flow through the capillary. There are a few ways to deal with this (see the docstring to \code{Chip.calc_pp} for pros and cons for each of them).
	
	During quantification, this transfer function becomes quite simple if we can make the assumption that we have quantified the flux of everything passing through the chip gas accurately. Then we can bypass the capillary equation by assuming the total flux $\dot{n}^0$ is just the sum of the measured fluxes. Equation \ref{eq:step2} is then just:
	\begin{equation}
	p^i = p^0 \frac{\dot{n}^i}{\sum_i \dot{n}^i}\label{eq:naive}
	\end{equation}
	This is what is called the ``naive'' mode. One implication of this mode is that the absolute sensitivity factors $F_i$ are used just as if they were relative sensitivity factors.
	
	The naive mode ignores the capillary equation, Equation \ref{eq:capillary}. It can be tested by comparing $\dot{n}^0$ as calculated by the capillary equation to the sum of the measured calibrated flux, $\sum_i \dot{n}^i$. In general, error in the quantification of one or more product will lead to less than perfect match. In some applications, this may nonetheless be the most accurate way of calculating the partial pressure in the chip of the molecules of interest. However, it links the error of quantification of every molecule to the errors of quantification of every other molecules.
	
	This is why some applications may get better results by using the physics of the capillary equation, and placing the error on one specific molecule with a very high flux, for which the quantification is not as important. In gas measurements, accurate quantification of the base gas such as \ch{N2} may not be important. In liquid applications, accurate quantification of the carrier gas, typically He, is not very important. In these cases, the capillary equation can be satisfied by ``relaxing'' the flux of the carrier gas, allowing it to take a different value when determining the composition of the capillary gas than its apparent flux from quantification of signals. The equation to solve, for $\dot{n}^{\ch{He}}$ is then:
	\begin{align}
		\sum_{i\ne \ch{He}}\dot{n}^i + \dot{n}^{\ch{He}} = \dot{n}^0(\vec{p}, T)\,&\hspace{1cm}\text{where}\\ \label{eq:solver1}
		p^i = p^0 \frac{\dot{n}^i}{\sum_{i\ne \ch{He}}\dot{n}^i + \dot{n}^{\ch{He}}}&\\ \label{solver2}
	\end{align}
	Here, $\dot{n}^0(\vec{p}, T)$ is the capillary equation. Solving this equation for $\dot{n}^{\ch{He}}$ yields the pressure $p^i$ for each molecule $i$, i.e. $\vec{p}$. This approach, called the ``He solver'' mode, is the default mode of \code{Chip.calc_pp}.
	
	\item $\vec{p} \rightarrow \vec{c}$. \textbf{Divide each partial pressure by the volatility constant to obtain concentrations.} Going from partial pressures in the chip to concentrations is easy by direct application of Henry's law, which is the first transfer function, Equation \ref{eq:step1}. Just calculate the Henry's-law volatility constant at the operation temperature and divide the partial pressure for each molecule of interest in the chip by it:
	\begin{equation}
	c^i = \frac{p^i}{K_\text{H}^i(T)}
	\end{equation}
	
	
\end{itemize}

The \code{quant.physics} package provides tools for each of these steps. \code{SignalProcessor} class in the \code{signal} module handles the $(\vec{x}, \vec{y})\rightarrow \vec{S}$ step, calling on classes of the \code{peak} module. The \code{Quantifier} class in the \code{quantifier} module handles the remaining steps, calling on all the remaining interlinked modules, especially the \code{sensitivity} module for the $\vec{S} \rightarrow \vec{\dot{n}}$ step, the \code{chip} module for the $\vec{\dot{n}} \rightarrow \vec{p}$ step, and the \code{molecule} module for the $\vec{p}\rightarrow\vec{c}$ step. Each of these modules is described below in \ref{sec:modules}, but first we conclude the theory part of this document with comments on how to measure the sensitivity factors needed for the central $\vec{S} \rightarrow \vec{\dot{n}}$ step.



\section{Determining sensitivity factors}\label{sec:calibration}

Sensitivity factors play a central role in \code{quant.physics}. They represent five of the seven transfer functions described in Section \ref{sec:steps}, including the steps about which least is known a priori. For this reason, as a design decision, sensitivity factors are treated as the one unknown parameter of \code{quant.physics} which must be determined by calibration. How to do so is described in the first part of this section. The 

\subsection{Calibration experiments}

A calibration is an experiment used to determine sensitivity factors $F^i_M$, the signal response at mass-setting $M$ to flux of molecule $i$ into the vacuum chamber. 

Just as there are three types of quantification of interest to various users (absolute rate, partial pressure, concentration), there are three corresponding types of calibration experiments. The first two are described in more detail in Soren's PhD Thesis.

All calibration experiments have in common that the signal at mass $M$ is measured while the flux of molecule $i$ is known. A simple \textit{point calibration} just involves a single measurement of a signal under conditions where its safe to assume that all of that signal is coming from the known flux of a molecule. Then the sensitivity factor $F_M^i$ is just the ratio of the signal at $M$ to the flux of $i$:
\begin{equation}
	F_M^i = \frac{S_M}{\dot{n}^i}\,, \hspace{1cm} \text{point calibration.} \label{eq:point}
\end{equation}

Ideally the measurement is made at a number of fluxes, where $\dot{n}^i$ is varied while everything else is held constant, allowing for a \textit{calibration curve}. The sensitivity factor $F_M^i$ is then, by its definition, the response of the signal to the flux:
\begin{equation}
F_M^i = \frac{\mathrm{d}S_M}{\mathrm{d}\dot{n}^i}\,, \hspace{1cm} \text{calibration curve.}
\end{equation} 
Calibration curves are preferable because they are more robust against background.

The only difference between the calibrations is the way in which $\dot{n}^i$ is known and controlled:

\begin{itemize}
	\item \textbf{Flux calibration, also called \textit{internal calibration}}: In a flux calibration, the signal is measured while directly controlling the flux. This is possible through \textit{electrochemistry} for a handful of molecules which can be produced at 100\% \textit{Faradaic efficiency} by an electrochemical process. This includes \ch{O2} by the oxygen evolution reaction (OER), \ch{H2} by the hydrogen evolution reaction (HER), and \ch{CO2} by the CO oxidation reaction. Some slightly more exotic possibilities could include \ch{Cl2} from the chlorine evolution reaction, ethane from the ethylene reduction reaction, etc. The flux is controlled by the electrochemical current:
	\begin{equation}
	\dot{n}^i = \frac{I}{z\mathcal{F}}
	\end{equation}
	where $I$ is the aelectrode current in [A], $z$ is the number of electrons transferred per molecule of $i$ produced (positive for an oxidative reaction, negative for a reductive reaction), and $\mathcal{F}$ is Faraday's constant. Getting multiple values of $\dot{n}^i$ can be accomplished by varying the current $I$.
	
	Even though it is only a small portion of interesting molecules that can be calibrated in this way, \textit{internal calibration}, by being the most direct probe of the sensitivity factor, has been essential to the development of the theory of quantitative mass spectrometry presented in this document.
	
	\item \textbf{Pressure calibration, also called \textit{semi-internal calibration}}: In a pressure calibration, the signal is measured while controlling the gas in the chip - both its total pressure and the mol fraction of the analyte gas $i$. The total flux is given by the capillary equation (Equation \ref{eq:capillary}) and the flux of $i$ is the total flux times the mol fraction $i$ in the gas, $x^i$:
	\begin{equation}
	\dot{n}^i = x^i \dot{n}^0(\vec{p}, T)
	\end{equation}
	Pressure calibration works best for analytes which are gaseous at standard conditions. Getting multiple values of $\dot{n}^i$ can be accomplished by testing multiple gases with different mol fractions of $i$, or by varying the total pressure of the gas in the chip.
	
	\item \textbf{Concentration calibration, also called \textit{external calibration}}: In a concentration calibration, it is the liquid on the chip which is controlled. The flux is then known via its vapor pressure, calculated by Henry's law; and the total flux, calculated by the capillary equation: 	
	\begin{equation}
	\dot{n}^i =  \frac{c^iK_\text{H}^i(T)}{p^0} \dot{n}^0(\vec{p}, T) 
	\end{equation}
	This experiment requires a carrier gas to pressurize the chip, and the carrier gas dominates $\vec{p}$ and thus determines the total capillary flux.
	Concentration calibration works best for analytes which are volatile liquids at standard conditions. Getting multiple values of $\dot{n}^i$ can be accomplished by preparing a concentration series with different values of $c_i$.
	
\end{itemize}

The decision to put the uncertainty in $F$ allows for some leniency in the methodology, so long as the calibration experiment resembles the measurement to quantify as much as possible. For example, if a wrong assumption capillary flux or Henry's-Law constant is used when analyzing calibration experiments for concentration quantification, it will result in a value of $F$ which is not true, but still works for quantification so long as the (wrong) assumptions about capillary flux and Henry's-law constant remain in use. You will only notice when comparing values of $F$ obtained in different ways. In time, comparison of internal, semi-internal, and external calibrations can serve as a new method for determining more accurate Henry's-law constants, viscosities of mixtures, etc. In Soren's PhD Thesis, Section 2.2, the 

Detailed experimental procedures for these calibration experiments, as well as the exact treatment of uncertainty, are application-specific and should be developed elsewhere.

\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{fig/calibration}
	\caption{A calibration, i.e. a set of sensitivity factors, visualized as mass spectrum.}
	\label{fig:cal}
\end{figure}

Figure \ref{fig:cal} shows a collection of sensitivity factors obtained by calibration.

{\color{red} This application note could be strengthened by adding the treatment of uncertainty, namely the ``Centrality of the Sensitivity Factor'' section from the Recipe of Recipes document}

\subsection{Predicting sensitivity factors ($F$-vs-$f$)}\label{sec:f}

Sensitivity factors should be measured to the degree possible. If a sensitivity factor cannot be measured, for example due to unavailability in a well-defined and safe form, an approximate predicted value will have to stand in. Here we describe how to predict a sensitivity factor based on the theory presented in Section \ref{sec:steps}.

If we add the various assumptions and dependencies for all the ``internal'' transfer functions, represented in Equations \ref{eq:G}, \ref{eq:I}, \ref{eq:P}, \ref{eq:T}, and \ref{eq:CEM} (assuming CEM detector) into Equation \ref{eq:F} defining the sensitivity factor, we get the following expression for $F$:
\begin{equation}
F^i_M \approx k_\mathcal{G}k_\mathcal{I}\sigma^i\frac{I_M^i}{\sum_{M'}I^i_{M'}}k_\mathcal{T}M^{\beta_T}k_\mathcal{A}M^{-\frac{1}{2}}\,.
\end{equation}
(Note that $M$ here takes on two slightly distinct meanings, first as the mass string defined above in the subscripts, and then as the dimensionless m/z number as the base for the exponents.) The above equation is simplified by joining the constants to $k_F=k_\mathcal{G}k_\mathcal{I}k_\mathcal{T}k_\mathcal{A}$,and defining $\beta = \beta_T-\frac{1}{2}$:
\begin{equation}
F^i_M \approx k_F\sigma^i\frac{I_M^i}{\sum_{M'}I^i_{M'}}M^{\beta}
\end{equation}

For the Faraday cup, we arrive at the same expression just with a different $k_F$ and $\beta$.

The least confident assumptions were in the $M$-dependency. To acknowledge this, we can replace the simple power-of-$M$ expression with a transmission-amplification function $\mathcal{T}(M)$. However, for now we will assume the $M^\beta$ dependency.

Finally, to be transparent that this is a predicted and not measured sensitivity factor, and that we know nothing about the constant in front, we rename it from big $F$ to little $f$, and replace the supposedly knowable $k_F$ with an arbitrary constant $k$ chosen to set
\begin{equation}
f_\text{M32}^{\ch{O2}}=1 \label{eq:k}
\end{equation}
where `M32' should be extended with the setting for which the expression $f$ will be used.

The equation for $f$ is then
\begin{equation}
f^i_M = k\sigma^i\frac{I_M^i}{\sum_{M'}I^i_{M'}}M^\beta \label{eq:f}
\end{equation}
This little-f sensitivity factor $f$ serves the purpose of helping to predict big F, the absolute sensitivity factor. They should be directly proportional. The proportionality factor, $\alpha$, is due to fact that $f_\text{M32}^{\ch{O2}}=1$ equal to the predicted value of the absolute sensitivity of oxygen at m/z=32, $F_\text{M32}^{\ch{O2}}$, at the setting for which $f$ will be used.

\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{fig/F_vs_f}
	\caption{Measured sensitivity factors vs relative sensitivity factors calculated by Equation \ref{eq:f} for a few common gases at their primary masses with the CEM detector. The fit parameters are $\alpha=7.98$ [C/mol] and $\beta=-0.46$. The fit is used here to predict the sensitivity factor for ethylene (\ch{C2H4}) at m/z=26 (green dot on the line)}
	\label{fig:Fvf}
\end{figure}

Thus, 
\begin{equation}
F^i_{M, \text{predicted}} = \alpha f^i_M
\end{equation}
or, substituting for $f$ and assuming the power-of-$M$ transmission-amplification function motivated above,
\begin{equation}
F^i_{M, \text{predicted}} = \alpha k \sigma^i\frac{I_M^i}{\sum_{M'}I^i_{M'}}M^{\beta}\,. \label{eq:prediction}
\end{equation}

$k$ is defined by Equation \ref{eq:k}, so Equation \ref{eq:prediction} has two free parameters: $\alpha$ and $\beta$. These two parameters need to be fit to a set of measured sensitivity factors at a given mass spec setting, and then Equation \ref{eq:prediction} can be used to predict missing sensitivity factors with the same mass spec setting.

Figure \ref{fig:Fvf} shows an example of this fit. This type of plot is referred to as an ``F-vs-f'' plot.

\subsection{In-operando recalibration} \label{sec:recalibration}
One of the challenges of quantitative mass spectrometry is \textit{sensitivity drift}, whereby the amplification function of the detector, or the transmission function of the quadrupole, and/or the ionization efficiency of the ion source, change (decrease, usually) over time, such that the signal produced by a constant input changes. In other words, sensitivity factors are not constant, but need to be \textit{recalibrated} from time to time.

Just like calibration experiments, recalibration requires knowing the flux of a molecule independently of the mass spectrometry measurement: If the flux is known, and the signal can be measured, the sensitivity factor can come from \ref{eq:point}.

In a liquid application, there are two fluxes that can be known during operation independently of the measurement, if the temperature $T$ and total pressure $p^0$ are known:
\begin{itemize}
	\item \textbf{The solvent, from $T$}. The solvent, typically \ch{H2O}, under the assumption of ideality, has a vapor pressure that is a known function of temperature. The chip will be saturated with this vapor, so the partial pressure is known to be the vapor pressure, $p^{\ch{H2O}}_\text{vap}(T)$, a function of temperature. The flux of solvent is then
	\begin{equation}
		\dot{n}^{\ch{H2O}}_\text{calc} = \frac{p^{\ch{H2O}}_\text{vap}(T)}{p^0} \dot{n}^0(\vec{p}, T)\, \label{eq:solvent}
	\end{equation}
	where $\dot{n}^0(\vec{p}, T)$ is the total capillary flux calculated by the capillary equation (Equation \ref{eq:capillary}). 
	
	\item \textbf{The carrier gas, from $p$}. The carrier gas, typically \ch{He}, makes up the majority of the gas in the chip. Its flux is solved for in Equation \ref{eq:solver1}, which matches the capillary flux to that expected based on the total pressure:
	\begin{equation}
	\dot{n}^{\ch{He}}_\text{calc} = \dot{n}^0(\vec{p}, T) -  \sum_{i\ne \ch{He}}\dot{n}^i \label{eq:carrier}
	\end{equation}
\end{itemize}

With these independent approximations of the \ch{H2O} and \ch{He} fluxes, and signal measurements at their primary masses, M18 and M4, respectively, we have two new point calibrations:
\begin{equation}
	(F^{\ch{H2O}}_\text{M18})_\text{new} = \frac{S_\text{M18}}{\dot{n}^{\ch{H2O}}_\text{calc}}\label{eq:H2ORecal}
\end{equation}
and
\begin{equation}
	(F^{\ch{He}}_\text{M4})_\text{new} = \frac{S_\text{M4}}{\dot{n}^{\ch{He}}_\text{calc}}\,.\label{eq:HeRecal}
\end{equation}
This assumes, importantly, there are no significant interferences at those peaks. In this most general case of quantification of a changing liquid, no other molecules have known fluxes for use in point calibrations.

Both of these rely on knowing the composition of the chip gas for the capillary equation, which in turn requires correct quantificaiton. We will return to this, but for now assume that the pre-recalibration quantification is a good enough approximation for providing these independent calculations of the \ch{H2O} and \ch{He} fluxes.

A bigger problem is that we only have recalibrated values for $F^{\ch{H2O}}_\text{M18}$ and $F^{\ch{He}}_\text{M4}$ which need to be expanded into recalibrated values for all sensitivity factors in use for the quantification algorithm. The only way to do this is to assume that there is a system by which the sensitivity factors change. As there are only two in-operando point calibrations available, the change of all sensitivity factors can be described by at most two parameters. 

\textbf{One recalibration parameter}

Most simply, all sensitivity factors could be assume to increase or decrease in proportion to each other. Then recalibration multiplies all sensitivity factors by a constant scaling parameter $\rho$:
\begin{equation}
\frac{(F_M^i)_\text{new}}{(F_M^i)_\text{old}} = \rho \,, \hspace{1cm} \text{one-parameter recalibration}
\end{equation}
The scaling parameter $\rho$ can then be either determined by the solvent point calibration or the carrier gas point calibration or a geometric average of the two:
\begin{equation}
\rho = \sqrt{\frac{(F^{\ch{H2O}}_\text{M18})_\text{new}(F^{\ch{He}}_\text{M4})_\text{new}} {(F^{\ch{H2O}}_\text{M18})_\text{old}(F^{\ch{He}}_\text{M4})_\text{old}}} \,, \hspace{1cm} \text{one parameter from solvent and carrier.}
\end{equation}

\textbf{Two recalibration parameters}

Alternatively, the two point calibrations available in operando could be used to define two parameters. Based on the mass spectrometry physics and the qualified success of the $F$-vs-$f$ sensitivity factor prediction framework in Section \ref{sec:f}, the second parameter is tentatively assigned to an exponent of the m/z number, called $\Delta \beta$:
\begin{equation}
\frac{(F_M^i)_\text{new}}{(F_M^i)_\text{old}} = \rho \left(\frac{M}{32}\right)^{\Delta \beta} \,, \hspace{1cm} \text{two-parameter recalibration}, \label{eq:2par}
\end{equation}
where the m/z number $M$ is divided by 32 as a reference mass, just like the predictive sensitivity factor is relative to $f^{\ch{O2}}_\text{M32}=1$. In this way, both of the recalibration parameters are analogous to the fit parameters of the $F$-vs-$f$ analysis:
\begin{equation}
\rho = \frac{\alpha_\text{new}}{\alpha_\text{old}}\hspace{1cm}\text{and}\hspace{1cm}\Delta \beta = \beta_\text{new} - \beta_\text{old}
\end{equation}
The expressions for $\rho$ and $\Delta \beta$ in terms of the old and new sensitivity factors for the solvent and the carrier gas are:
\begin{align}
\Delta \beta &= \log_{(18/4)}\left(
	\frac {(F^{\ch{H2O}}_\text{M18})_\text{new}(F^{\ch{He}}_\text{M4})_\text{old}} {(F^{\ch{H2O}}_\text{M18})_\text{old}(F^{\ch{He}}_\text{M4})_\text{new}}  
\right) \,,\hspace{1cm} \text{and} \label{eq:db} \\
\rho &= \frac{(F^{\ch{He}}_\text{M4})_\text{new}}{(F^{\ch{He}}_\text{M4})_\text{old}} \left(\frac{32}{4}\right)^{\Delta \beta}\,. \label{eq:rho}
\end{align}
With $\Delta \beta$ and $\rho$ determined, all sensitivity factors for which this shift applies can be recalibrated by Equation \ref{eq:2par}. A recalibration shift applies only to the sensitivity factors for which the same physics applies, i.e. those with the same physics. For example, a gradual signal loss with a CEM detector does not imply the same for measurements with the FC detector.

As a final consideration, updating the sensitivity matrix with a recalibration will effect the quantification of all molecules and thus the makeup of the gas in the chip and, in turn, the total capillary flux. Though these effects should be rather small, with the carrier usually making up the majority of the capillary gas, they can be accounted for to reach self-consistency. One way to do this is an iterative process:

\begin{itemize}
	\item Use the present sensitivity factors to calculate $\vec{p}$ and the capillary flux as described in Section \ref{sec:solve}.
	
	\item Calculate the fluxes of solvent and carrier, and then  $(F^{\ch{H2O}}_\text{M18})_\text{new}$ and $(F^{\ch{He}}_\text{M4})_\text{new}$ by Equations \ref{eq:H2ORecal} and \ref{eq:HeRecal}, respectively 
	
	\item Use these two in-operando point calibrations to calculate the adjustment parameters $\Delta \beta$ and $\rho$ by Equations \ref{eq:db} and \ref{eq:rho}, respectively.
	
	\item Check for convergence: if $\Delta \beta$ is between -0.01 and 0.01, and $\rho$ is between 0.99 and 1.01, then we're done.
	
	\item If not converged, then adjust the sensitivity factors by Equation \ref{eq:2par} and repeat from the first step.
\end{itemize}

This is the recalibration algorithm defined in the \code{recal_with_H2O_and_carrier} function of the \code{recalibration} module, the default used in \code{quant.physics}.

This also concludes the physics-focused part of this application note. The next section give a high-level description of the modules of \code{quant.physics}, a powerful tool to handle all of this physics.

\section{The modules of \code{quant.physics}} \label{sec:modules}

The \code{quant.physics} package tries to make the best of modular, object-oriented programming to capture all of the physics involved in quantitative mass spectrometry with a Spectro Inlets inlet system. Modules and classes do their best to represent physically intuitive concepts in the system and in your workflow. This section gives a very brief description of each module as it exists in quant.physics v1.0, with examples of some of the most important interfaces in the accompanying Ipython notebook. 


Most of the equations in the previous sections of this document appear somewhere in the package. It is much bigger than that, though, because of the need to keep various pieces of information in the right places accessible through intuitive interfaces.

The code is pretty well self-documented, so don't hesitate to import anything and input it to python's \code{help} function to see the docstring. There are code examples to go along with these explanations for each module in the accompanying Ipython notebook. The modules have an explicit hierarchy, and this section goes through them from lowest to highest in that hierarchy.


\subsection{constants.py}\label{sec:constants}

The \textbf{constants} module defines constants used throughout \code{quant.physics}, such as:
\begin{itemize}
	\item The \code{Path} objects directing to files used by \code{quant.physics}, such as the \code{MOLECULE_DIRECTORY} containing molecule constants like Henry's-Law parameters and ionization cross section.	
	\item The physical constants used in \code{quant.physics} such as the \code{GAS_CONSTANT} representing $R=8.3143$ [J/mol/K].
	\item The chip design parameters including \code{STANDARD_CAPILLARY_WIDTH = 6e-6} [m]
	\item Standard conditions including \code{STANDARD_TEMPERATURE = 298.15} [K]
	\item Plotting preferences such as \code{STANDARD_COLORS}
\end{itemize}

\subsection{tools.py}\label{sec:tools}

The \textbf{tools} module contains useful pythony stuff used elsewhere like a \code{singleton_decorator}.

It also includes some little function for parsing mass strings. For example:

\begin{lstlisting}
>>> from physics.tools import mass_to_M, mass_to_setting
>>> mass_to_M("M32-CEM")
32.0
>>> mass_to_setting("M32-CEM")
'CEM'
\end{lstlisting}

It also includes a string made when \code{quant.physics} is imported that represent the day's date in Soren's format. For example, the 13th of November 2020 is "20K13" where 'K' (the 11th letter) represents November (the 11th month). This string is used by default when new calibrations are defined.

\subsection{medium.py}\label{sec:medium}

The \textbf{medium} module's only purpose is to give a home to the one-and-only pressure and temperature of the system, so that different classes agree on these two external conditions. That home, \code{Medium}, is a singleton. Accessing the attributes \code{T} or \code{p} of \textit{\textbf{any}} other class in any of the modules of quant including \code{Quantifier}, \code{Molecule}, \code{Chip}, or \code{Gas} will just return \code{Medium().T} or \code{Medium().p}, respectively.

\subsection{molecule.py}\label{sec:molecule}

The \textbf{molecule} module defines the \code{Molecule} class. Instances of this class, initated with the \code{Molecule.load()} constructor class method whgich takes the molecule name (e.g. "H2"), load a number of constants including Henry's-Law constant, thermochemistry, molecular diameter, ionization cross section data, and reference spectrum from a .json data file in the \code{MOLECULE_DIRECTORY}. 

{\color{red} This application note could be strengthened by adding the description of the molecule data files from the Recipe of Recipes document}

The \code{molecule} thus initiated wraps this data with some useful methods, such as one to calculate the volatility constant as a function of temperature (used to generate the data for Figure \ref{fig:KH}) and plot the reference spectrum (such as Figure \ref{fig:NIST}.

The module also defines a \code{MoleculeDict}, a singleton whose only instance is called \code{mdict} everywhere it is used in \code{quant.physics}. The \code{mdict} collects \code{Molecule} instances when they are initiated with the \code{mdict.get()} method which takes the molecule name as its arguemt, and then makes them available by method or by indexing as well. \code{mdict.get()} is almost always prefered over \code{Molecule.load()} because it avoids an unnecessary second read of the molecule file.

\subsection{mixture.py}\label{sec:mixture}

The \textbf{mixture} module has a base class \code{Mixture} which serves as a framework for dealing with a mixture of molecules. The most important attribute of its instances (\code{mixture}) is \code{mixture.comp}, which is a dictionary of {$i$: $x^i$} where $i$ is the name of a molecule and $x^i$ is its mol fraction in the mixtrue. If \code{abc} is an attribute of \code{Molecule}, then \code{mixture.abc} returns the mol-weighted average of \code{abc} for each of the molecules in the mixture. \code{Mixture.make()} is a constructor that takes a \code{comp} dictionary or the name of a molecule or the name of a standard mixture (such as \code{"air"}), and populates the mixture accordingly.

The \code{Gas} class inherits from \code{Mixture} and adds a couple things: First, it has an updated viscosity correction that overrides the weighted average inherited from \code{Mixture} and instead uses the algorithm in Davidson1993. This was used to generate the data for Figure \ref{fig:eta}. Second, \code{gas.saturated_with()} takes a molecule as input and returns a gas that contains that molecule at the mol fraction dictated its vapor pressure and the system pressure.

\subsection{chip.py}\label{sec:chip} 

The \textbf{chip} module defines the \code{Chip} class, which is basically a wrapper around the capillary equation, Equation \ref{eq:capillary}. An instance of \code{Chip} can be defined by with the \code{Chip.load} method which takes as its argument the name of a .json file in the \code{constants.CHIP_DIRECTORY}, which just contains the capillary dimensions if they differ from the defaults of a known chip. It can also be initialized with the default dimensions directly from \code{chip=Chip()}. Either can take \code{p}, \code{T}, \code{carrier}, and \code{solvent} as arguments, where the first two set the system \code{Medium().p} and \code{Medium().T}, respectively. 

\code{chip.gas} represents the gas in the chip. By default it is \code{chip.carrier} saturated with \code{chip.solvent}. The capillary equation is called with \code{chip.calc_n_dot_0()}. It can take a \code{gas}, \code{p}, and \code{T} as inputs but by default uses those of the chips. This method was used to generate the data in Figure \ref{fig:cap}. It also has a \code{chip.calc_n_dot()} function which returns a dictionary giving the flux in [mol/s] for each of the molecules in its gas.

The \code{chip} also has a number of methods for calculating the partial pressure of the gases in it given a set of quantified fluxes, including that which solves Equation \ref{eq:solver1}. This resets the chip's gas.

\subsection{peak.py}\label{sec:peak}

The \textbf{peak} module defines a \code{Peak} base class and classes that inherit from it (so far only \code{GaussPeak}). Each of these classes is initiated with x-and-y data, and have methods for extracting a \code{height}, \code{width}, and \code{center} from it. For the base class, these are extracted by stupid-simple means (for example, height is just the maxiumum y value), while for a \code{gauss_peak} (instance of \code{GaussPeak}), they come from the Gaussian fit. A peak that fails to fit raises a \code{PeakFitError}. A peaks also has a \code{signal} attribute, which is the height unless it is flagged with \code{peak.error=True}, in which case \code{peak.signal} returns 0. 

Each \code{Peak} class has a \code{plot} method for visualization. Figure \ref{fig:peak} was made with \code{gauss_peak.plot()}.

\subsection{signal.py}\label{sec:signal}

The \textbf{signal} module contains three classes for organizing, visualizing, and analyzing raw data. 

The \code{SignalDict} class stores signals, as defined in Definition \ref{def:signal}. When a signal is added, either its time is also added or it gets timestamped, so that \code{SignalDict} knows its history. Besides that, it acts like a dictionary which returns the latest signal in [A] when indexed with a mass-setting string.

The \code{SignalProcessor} class is the main data-processing class of \code{quant.physics}. It can be loaded from a processor file containing data on nonlinearity and background, or initiated directly. Either way, it can be given a \code{peak_type} which specifies which \code{Peak} class the instance, \code{signal_processor}, uses. Its \code{calc_signal} method class takes in raw x-and-y data, corrects it for nonlinearity and/or background, makes a \code{Peak}, and then calculates the signal, adds it to its \code{SignalDict}, and returns it. 

The \code{PeakSeries} class provides a mean of storing, visualizing, and analyzing a series of spectra over one or more peaks. It is useful in, for example, calibration experimental data analysis. A new application should consider writing a parser for its data files that produces a instance of PeakSeries or class that inherits from it.

\subsection{sensitivity.py}\label{sec:sensitivity}

The \textbf{sensitivity} module contains several classes for managing sensitivity factors. 

First, the \code{SensitivityFactor} class is a wrapper around a single sensitivity factor. A \code{sensitivity_factor} has the actual number in [C/mol] as its attribute \code{F}, with its attributes \code{mol} and \code{mass} attribtes specifying the molecule and mass-setting for which it applies. The \code{SensitivityUnion} class can unite sensitivity factors with matching mol and mass. Its \code{F} is the average of those of its members, and it has a property \code{accuracy} telling the relative deviation thereof. 

The \code{SensitivityList} is a wrapper around a list of sensitivity factors which a \code{filter} method that returns a smaller \code{SensitivityList} based on any attribute of the \code{sensitivity_factors}. It also has a \code{to_sensitivity_matrix} method which takes \code{mol_list} and \code{mass_list} as arguments and passes them on, with the needed \code{sensitivity_factors} to \code{SensitivityMatrix}.

The \code{SensitivityMatrix} class is the home of the central calculation in quantification, Equation \ref{eq:Q1} for counting flux, which is \code{sensitivity_matrix.calc_n_dot()}. In this methed, the inverse to \code{sensitivity_matrix.F_mat} ($\mat{F}$) is taken and matrix multiplied onto the \code{signals} or \code{signal_dict} given as an argument, and the result is rearranged as a dictionary \code{n_dot}. \code{sensitivity_matrix.F_mat} is is a matrix spanning \code{sensitivity_matrix.mol_list} and \code{sensitivity_matrix.mass_list} where any entry that was not available from the \code{sensitivity_list} that initiated it is predicted by the method described in Section \ref{sec:f}. 

That prediction is done by the class \code{SensitivityFit}. A \code{sensitivity_fit} has a \code{fit} method which determines the parameters \code{sensitivity_fit.alpha} and \code{sensitivity_fit.beta} ($\alpha$ and $\beta$ in Equation \ref{eq:prediction}), and a \code{plot_F_vs_f} method for visualization (Figure \ref{fig:Fvf}).

\subsection{calibration.py}\label{sec:cal}

The \textbf{calibration} module defines two classes, each of which inherit from classes in the \code{sensitivity} module. 

\code{CalPoint} inherits from \code{SensitivityFactor} and adds to its parent metadata attributes and specs such as \code{precision} and \code{background_std} whre the latter can be used to calculate its detection limit. A \code{CalPoint} should be initialized directly with all of these attributes, which are descriptions of and results from a calibration experiment.

\code{Calibration} inherits from \code{SensitivityList} and adds to its parent methods for visualization, saving, loading, and fitting. \code{Calibration} is the class for collecting and saving calibration results for later use. During quantificaiton, a \code{calibration} is loaded and used to generate \code{sensitivity_matrices} with a beefed up version of the inherited \code{make_sensitivity_matrix} function. \code{calibration.fit}, whose parameters are saved and loaded with the \code{CalPoints}, is passed on to the sensitivity matrices that \code{calibration} makes. The fit is mainly just to be able to sanity-check the \code{calibration}, usually after \code{filter}'ing for a specific setting. The \code{calibration.plot_as_spectrum()} method makes figures like Figure \ref{fig:cal}. It also has a \code{print_report} method so you can prove to your boss that you're doing something.

\subsection{recalibration.py}\label{sec:recal}

The \textbf{recalibration} module is home to module-level functions for recalibration, such as \code{recal_with_H2O_and_carrier}, the calculations of which are described in Section \ref{sec:recalibration}. Each reacalibration function takes a \code{sensitivity_matrix}, a dictionary or \code{SignalDict} of \code{signals}, and a \code{chip} as its first three arguments, and returns a new \code{sensitivity_matrix} corrected based on the data in the \code{signals} and the external conditions read from the \code{chip}.

\subsection{quantifier.py}\label{sec:quantifier}

Finally, the \textbf{quantifier} module defines the \code{Quantifier} class, which is initiated with a \code{calibration_file}, a \code{mol_list} and \code{mass_list}, and a \code{chip}, as well as a few other options. The \code{quantifier} loads the \code{calibration} from the file and immediately uses it to build a \code{sensitivity_matrix} based on the \code{mol_list} and \code{mass_list}. 

The \code{quantifier} binds the \textbf{recalibration} functions so that it can serve as the interface for recalibration of its \code{sensitivity_matrix}. 

Most importantly, \code{quantifier} binds the methods for quantification according to the procedure in Section \ref{sec:solve}:
\begin{itemize}
	\item \code{quantifier.calc_n_dot} for flux quantification,
	
	\item \code{quantifier.calc_pp} for partial pressure quantification, and
	
	\item \code{quantifier.calc_c} for concentration quantification.
\end{itemize}

That concludes our tour of \code{quant.physics}, most of which is in the Ipython notebook. We hope you enjoyed it and find the tools and physics here useful!

\section{Using \textbf{quant.physics}} \label{sec:usage}

To run the examples shown in this Application Note, make sure the folder quant is in your pythonpath. This can be done by explicitly adding it at the top of a script or during an ipython session with this code:

\begin{lstlisting}
from pathlib import Path
import sys
quant_path = Path.home() / "git/spitze/src/spitze/quant"   # update me!!!
sys.path.append(str(quant_path))
\end{lstlisting}

{ \color{red} 	
TODO: 

Separate \code{quant.physics} from the rest of \code{spitze.quant} and make it open-source and pip installable. After the package is open-sourced, this section should then be updated with installation instructions before this Application Note is published on Spectro Inlets' website. 
	
Soren: 

I am in favor of open-sourcing the whole package and adding it to pypi, and will gladly help to do so out of academic interest after starting at Imperial. I would also be interested in working together to publish a modified version of this documentation in e.g. the Journal of Open Source Software.

This is the only existing quantification software that can be made ready for Spectro Inlets' EC-MS customers in the near-to-mid future. (\code{EC\_MS} does not have any supportable quantification capability.) I think it could be renamed \texttt{msquant} or similar and hosted as an open repository on Spectro Inlets' github, as well as pypi, under the MIT license. For EC-MS users, \code{quant} would function as a plug-in for the In-Situ Experimental Data Tool, \code{ixdat}, which will take over from \code{EC\_MS} in the coming months.

There are some additional minor practical things to figure out: The \texttt{quant/data} folder could be included in the open-source version with some data for common molecules (taken directly from NIST and other open sources), but not strategically important molecules or calibration data, which Spectro Inlets should hold closed-source. spitze.quant would then have its own data directory, independent of the open version. \texttt{quant} should therefore read from some sort of settings.ini file to switch between data directories. Everything uses \\\texttt{quant.physics.constants.DATA\_DIRECTORY}, so this should be pretty easy. Spectro inlets should similarly hold closed-source the \texttt{spit} and \texttt{calibration\_tools} modules, documented in the "Recipe of Recipes".

I look forward to working with you to figure this out!
}
{
\color{blue}
For the Industrial LGA application, usage is covered extensively in the "Recipe of Recipes" documentation of \code{spitze.quant}
}

\section{Conclusion: how to improve}\label{sec:conclusion}

{\color{red} TODO}

\end{document}
