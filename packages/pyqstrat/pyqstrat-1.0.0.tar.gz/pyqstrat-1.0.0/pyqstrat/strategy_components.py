# $$_ Lines starting with # $$_* autogenerated by jup_mini. Do not modify these
# $$_markdown
# # Strategy Components
# ## Purpose
# Helper components to build strategies with common use cases like VWAP entry and exit, and finite risk 
# $$_end_markdown
# $$_code
# $$_ %%checkall
import numpy as np
from dataclasses import dataclass
import math
from types import SimpleNamespace
from typing import Sequence, Callable
from pyqstrat.account import Account
from pyqstrat.pq_types import Contract, ContractGroup, Trade, Order, VWAPOrder
from pyqstrat.pq_types import MarketOrder, LimitOrder, TimeInForce
from pyqstrat.strategy import PriceFunctionType, StrategyContextType
from pyqstrat.pq_utils import assert_, get_child_logger, np_indexof_sorted


_logger = get_child_logger(__name__)


@dataclass
class VectorIndicator:
    '''
    An indicator created from a vector
    Args:
        vector: Vector with indicator values. Must be the same length as strategy timestamps 
    '''
    vector: np.ndarray
        
    def __call__(self,
                 contract_group: ContractGroup, 
                 timestamps: np.ndarray, 
                 indicator_values: SimpleNamespace,
                 context: StrategyContextType) -> np.ndarray:
        return self.vector


@dataclass
class VectorSignal:
    '''
    A signal created from a vector that has boolean values
    Args:
        vector: Vector with indicator values. Must be the same length as strategy timestamps 
    '''
    vector: np.ndarray
    
    def __call__(self,
                 contract_group: ContractGroup, 
                 timestamps: np.ndarray, 
                 indicator_values: SimpleNamespace,
                 parent_values: SimpleNamespace,
                 context: StrategyContextType) -> np.ndarray:
        return self.vector

    
def get_contract_price_from_dict(price_dict: dict[str, dict[np.datetime64, float]], 
                                 contract: Contract,
                                 timestamp: np.datetime64) -> float:               
    assert_(contract.symbol in price_dict, f'{contract.symbol} not found in price_dict')
    ret = price_dict[contract.symbol].get(timestamp)
    if ret is None: return math.nan
    return ret


def get_contract_price_from_array_dict(price_dict: dict[str, tuple[np.ndarray, np.ndarray]], 
                                       contract: Contract, 
                                       timestamp: np.datetime64) -> float:
    tup: tuple[np.ndarray, np.ndarray] | None = price_dict.get(contract.symbol)
    assert_(tup is not None, f'{contract.symbol} not found in price_dict')
    _timestamps: np.ndarray = tup[0]  # type: ignore
    idx = np_indexof_sorted(_timestamps, timestamp)
    if idx == -1: return math.nan
    return tup[1][idx]  # type: ignore
    

@dataclass
class PriceFuncArrayDict:
    '''
    A function object with a signature of PriceFunctionType and takes a dictionary of 
        contract name -> tuple of sorted timestamps and prices
        
    >>> timestamps = np.arange(np.datetime64('2023-01-01'), np.datetime64('2023-01-04'))
    >>> price_dict = {'AAPL': (timestamps, [8, 9, 10]), 'IBM': (timestamps, [20, 21, 22])}
    >>> pricefunc = PriceFuncArrayDict(price_dict)
    >>> Contract.clear_cache()
    >>> aapl = Contract.create('AAPL')
    >>> assert(pricefunc(aapl, timestamps, 2, None) == 10)
    >>> ibm = Contract.create('IBM')
    >>> basket = Contract.create('AAPL_IBM', components=[(aapl, 1), (ibm, -1)])
    >>> assert(pricefunc(basket, timestamps, 1, None) == -12)
    '''
    price_dict: dict[str, tuple[np.ndarray, np.ndarray]]
        
    def __init__(self, price_dict: dict[str, tuple[np.ndarray, np.ndarray]]) -> None:
        self.price_dict = price_dict
        
    def __call__(self, contract: Contract, timestamps: np.ndarray, i: int, context: StrategyContextType) -> float:
        price: float = 0.
        timestamp = timestamps[i]
        if contract.is_basket():
            for _contract, ratio in contract.components:
                price += get_contract_price_from_array_dict(self.price_dict, _contract, timestamp) * ratio
        else:
            price = get_contract_price_from_array_dict(self.price_dict, contract, timestamp)
        return price
    
    
@dataclass
class PriceFuncDict:
    '''
    A function object with a signature of PriceFunctionType and takes a dictionary of contract name -> timestamp -> price
    >>> timestamps = np.arange(np.datetime64('2023-01-01'), np.datetime64('2023-01-04'))
    >>> aapl_prices = [8, 9, 10]
    >>> ibm_prices = [20, 21, 22]
    >>> price_dict = {'AAPL': {}, 'IBM': {}} 
    >>> for i, timestamp in enumerate(timestamps):
    ...    price_dict['AAPL'][timestamp] = aapl_prices[i]
    ...    price_dict['IBM'][timestamp] = ibm_prices[i]
    >>> pricefunc = PriceFuncDict(price_dict)
    >>> Contract.clear_cache()
    >>> aapl = Contract.create('AAPL')
    >>> assert(pricefunc(aapl, timestamps, 2, None) == 10)
    >>> ibm = Contract.create('IBM')
    >>> basket = Contract.create('AAPL_IBM', components=[(aapl, 1), (ibm, -1)])
    >>> assert(pricefunc(basket, timestamps, 1, None) == -12)
    '''
    price_dict: dict[str, dict[np.datetime64, float]]
        
    def __init__(self, price_dict: dict[str, dict[np.datetime64, float]]) -> None:
        self.price_dict = price_dict
        
    def __call__(self, contract: Contract, timestamps: np.ndarray, i: int, context: StrategyContextType) -> float:
        timestamp = timestamps[i]
        price: float = 0.
        if contract.is_basket():
            for _contract, ratio in contract.components:
                price += get_contract_price_from_dict(self.price_dict, _contract, timestamp) * ratio
        else:
            price = get_contract_price_from_dict(self.price_dict, contract, timestamp)
        return price
    

@dataclass
class SimpleMarketSimulator:
    '''
    A function object with a signature of MarketSimulatorType.
    It can take into account slippage and commission
    >>> ContractGroup.clear_cache()
    >>> Contract.clear_cache()
    >>> put_symbol, call_symbol = 'SPX-P-3500-2023-01-19', 'SPX-C-4000-2023-01-19'
    >>> put_contract = Contract.create(put_symbol)
    >>> call_contract = Contract.create(call_symbol)
    >>> basket = Contract.create('test_contract')
    >>> basket.components = [(put_contract, -1), (call_contract, 1)]
    >>> timestamp = np.datetime64('2023-01-03 14:35')
    >>> price_func = PriceFuncDict({put_symbol: {timestamp: 4.8}, call_symbol: {timestamp: 3.5}})
    >>> order = MarketOrder(contract=basket, timestamp=timestamp, qty=10, reason_code='TEST')
    >>> sim = SimpleMarketSimulator(price_func=price_func, slippage_per_trade=0)
    >>> out = sim([order], 0, np.array([timestamp]), {}, {}, SimpleNamespace())
    >>> assert(len(out) == 1)
    >>> assert(math.isclose(out[0].price, -1.3))
    >>> assert(out[0].qty == 10)    
    '''
    price_func: PriceFunctionType
    slippage: float
    commission: float
        
    def __init__(self,
                 price_func: PriceFunctionType,
                 slippage_per_trade: float = 0.,
                 commission_per_trade: float = 0) -> None:
        '''
        Args:
            price_func: A function that we use to get the price to execute at
            slippage_per_trade: Slippage in local currency. Meant to simulate the difference
            between bid/ask mid and execution price 
            commission_per_trade: Fee paid to broker per trade
        '''
        self.price_func: PriceFunctionType = price_func
        self.slippage: float = slippage_per_trade
        self.commission: float = commission_per_trade
    
    def __call__(self,
                 orders: Sequence[Order],
                 i: int, 
                 timestamps: np.ndarray, 
                 indicators: dict[ContractGroup, SimpleNamespace],
                 signals: dict[ContractGroup, SimpleNamespace],
                 strategy_context: SimpleNamespace) -> list[Trade]:
        '''TODO: code for limit orders and stop orders'''
        trades = []
        timestamp = timestamps[i]
        # _logger.info(f'got: {orders}')
        for order in orders:
            if not isinstance(order, MarketOrder) and not isinstance(order, LimitOrder): continue
            contract = order.contract
            if not contract.is_basket(): 
                raw_price = self.price_func(contract, timestamps, i, strategy_context)
            else:
                raw_price = 0.
                for (_contract, ratio) in contract.components:
                    raw_price += self.price_func(_contract, timestamps, i, strategy_context) * ratio
                    if np.isnan(raw_price):
                        break
            if np.isnan(raw_price): continue
            slippage = self.slippage * order.qty
            if order.qty < 0: slippage = -slippage
            price = raw_price + slippage
            if isinstance(order, LimitOrder) and np.isfinite(order.limit_price):
                if ((abs(order.qty > 0) and order.limit_price > price) 
                        or (abs(order.qty < 0) and order.limit_price < price)):
                    continue
            commission = self.commission * order.qty
            if order.qty < 0: commission = -commission
            trade = Trade(order.contract, order, timestamp, order.qty, price, self.commission)
            _logger.info(f'TRADE: {timestamp.astype("M8[m]")} {trade}')
            order.fill()
            trades.append(trade)
        return trades
    

@dataclass
class PercentOfEquityTradingRule:
    '''
    A rule that trades a percentage of equity.
    
    Args:
        reason_code: Reason for entering the order, used for display
        equity_percent: Percentage of equity used to size order
        long: Whether We want to go long or short
        limit_increment: If not nan, we add or subtract this number from current market price (if selling or buying respectively)
            and create a limit order. If nan, we create market orders
        price_func: The function we use to get intraday prices
    '''
    
    reason_code: str
    price_func: PriceFunctionType
    equity_percent: float = 0.1  # use 10% of equity by default
    long: bool = True
    limit_increment: float = math.nan
        
    def __call__(self,
                 contract_group: ContractGroup,
                 i: int,
                 timestamps: np.ndarray,
                 indicator_values: SimpleNamespace,
                 signal_values: np.ndarray,
                 account: Account,
                 current_orders: Sequence[Order],
                 strategy_context: StrategyContextType) -> list[Order]:
        
        timestamp = timestamps[i]
            
        contracts = contract_group.get_contracts()
        orders: list[Order] = []
        for contract in contracts:
            entry_price_est = self.price_func(contract, timestamps, i, strategy_context)
            if math.isnan(entry_price_est): return []

            curr_equity = account.equity(timestamp)
            risk_amount = self.equity_percent * curr_equity
            order_qty = risk_amount / entry_price_est
            order_qty /= len(contracts)  # divide up qty equally between all contracts
            if not self.long: order_qty *= -1
            order_qty = math.floor(order_qty) if order_qty > 0 else math.ceil(order_qty)
            if math.isclose(order_qty, 0.): return []
            
            if math.isfinite(self.limit_increment):
                entry_price_est = self.price_func(contract, timestamps, i, strategy_context)
                entry_price_est -= np.sign(order_qty) * self.limit_increment
                    
                limit_order = LimitOrder(contract=contract,
                                         timestamp=timestamp, 
                                         qty=order_qty, 
                                         limit_price=entry_price_est, 
                                         reason_code=self.reason_code)
                orders.append(limit_order)
            else:
                market_order = MarketOrder(contract=contract, 
                                           timestamp=timestamp,
                                           qty=order_qty, 
                                           reason_code=self.reason_code) 
                orders.append(market_order)
        return orders
   

@dataclass
class VWAPEntryRule:
    '''
    A rule that generates VWAP orders
    
    Args:
        reason_code: Reason for each order. For display purposes
        vwap_minutes: How long the vwap period is. For example, a 5 minute vwap order will execute at 5 minute vwap 
        from when it is sent to the market
        price_func: A function that this rule uses to get market price at a given timestamp
        long: Whether we want to go long or short
        percent_of_equity: Order qty is calculated so that if the stop price is reached, we lose this amount
        stop_price_ind: Don't enter if estimated entry price is 
            market price <= stop price + min_price_diff (for long orders) or the opposite for short orders
        min_price_diff: See stop_price_ind
    '''
    reason_code: str
    vwap_minutes: int
    price_func: PriceFunctionType
    long: bool
    percent_of_equity: float
    stop_price_ind: str | None
    min_price_diff: float
    single_entry_per_day: bool
        
    def __init__(self, 
                 reason_code: str,
                 vwap_minutes: int,
                 price_func: PriceFunctionType,
                 long: bool = True,
                 percent_of_equity: float = 0.1,
                 stop_price_ind: str | None = None,
                 min_price_diff: float = 0,
                 single_entry_per_day: bool = False) -> None:
        self.reason_code = reason_code
        self.price_func = price_func
        self.long = long
        self.vwap_minutes = vwap_minutes
        self.percent_of_equity = percent_of_equity
        self.stop_price_ind = stop_price_ind
        self.min_price_diff = min_price_diff
        self.single_entry_per_day = single_entry_per_day
        
    def __call__(self,
                 contract_group: ContractGroup,
                 i: int,
                 timestamps: np.ndarray,
                 indicator_values: SimpleNamespace,
                 signal_values: np.ndarray,
                 account: Account,
                 current_orders: Sequence[Order],
                 strategy_context: StrategyContextType) -> list[Order]:
        timestamp = timestamps[i]
        if self.single_entry_per_day:
            date = timestamp.astype('M8[D]')
            trades = account.get_trades_for_date(contract_group.name, date)
            if len(trades): return []
            
        for order in current_orders:
            if order.contract.contract_group == contract_group and order.is_open(): return []

        orders: list[Order] = []
        contracts = contract_group.get_contracts()
        for contract in contracts:
            entry_price_est = self.price_func(contract, timestamps, i, strategy_context)
            if math.isnan(entry_price_est): return []

            if self.stop_price_ind:
                _stop_price_ind = getattr(indicator_values, self.stop_price_ind)
                stop_price = _stop_price_ind[i]
                if self.long and (entry_price_est - stop_price) < self.min_price_diff: return []
                if not self.long and (stop_price - entry_price_est) < self.min_price_diff: return []
            else:
                stop_price = math.nan

            curr_equity = account.equity(timestamp)
            risk_amount = self.percent_of_equity * curr_equity
            order_qty = risk_amount / (entry_price_est - stop_price)
            order_qty /= len(contracts)  # divide up equity percentage equally
            order_qty = math.floor(order_qty) if order_qty > 0 else math.ceil(order_qty)
            if math.isclose(order_qty, 0.): return []
            vwap_end_time = timestamp + np.timedelta64(self.vwap_minutes, 'm')
            order = VWAPOrder(contract=contract,
                              timestamp=timestamp, 
                              vwap_stop=stop_price,
                              vwap_end_time=vwap_end_time, 
                              qty=order_qty, 
                              time_in_force=TimeInForce.GTC,
                              reason_code=self.reason_code)
            orders.append(order)
        return [order]
    
    
@dataclass
class VWAPCloseRule:
    '''
    Rule to close out a position at vwap price
    Args:
        reason_code: Reason_code: Reason for each order. For display purposes
        vwap_minutes: How long the vwap period is. For example, a 5 minute vwap order will execute at 5 minute vwap
    '''
    reason_code: str
    vwap_minutes: int
        
    def __init__(self, 
                 vwap_minutes: int,
                 reason_code: str) -> None:
        self.vwap_minutes = vwap_minutes
        self.reason_code = reason_code
        
    def __call__(self,
                 contract_group: ContractGroup,
                 i: int,
                 timestamps: np.ndarray,
                 indicator_values: SimpleNamespace,
                 signal_values: np.ndarray,
                 account: Account,
                 current_orders: Sequence[Order],
                 strategy_context: StrategyContextType) -> list[Order]:
        timestamp = timestamps[i]
        for order in current_orders:
            if order.contract.contract_group == contract_group and order.is_open(): return []
        positions = account.positions(contract_group, timestamp)
        orders: list[Order] = []
        for (contract, qty) in positions:
            # assert len(positions) == 1, f'expected 1 positions, got: {positions}'
            vwap_end_time = timestamp + np.timedelta64(self.vwap_minutes, 'm')
            order = VWAPOrder(contract=contract,  # type: ignore
                              timestamp=timestamp, 
                              vwap_end_time=vwap_end_time, 
                              qty=-qty, 
                              time_in_force=TimeInForce.GTC,
                              reason_code=self.reason_code)
            orders.append(order)
        return orders


@dataclass    
class VWAPMarketSimulator:
    '''
    A market simulator that simulates buying and selling at VWAP prices.
    This works with VWAP orders and ignores all other order types
    The order executes either:
    a. After the vwap end time defined in the VWAP order
    b. If marker price <= vwap stop price defined in the VWAP order for buy orders
    c. If market price >= vwap stop price for sell orders
    '''
    price_indicator: str
    volume_indicator: str
    backup_price_indicator: str | None

    def __init__(self,
                 price_indicator: str,
                 volume_indicator: str,
                 backup_price_indicator: str | None = None) -> None:
        '''
        Args:
            price_indicator: An indicator that contains historical trade price per timestamp
            volume_indicator: An indicator that contains volume per timestamp
            backup_price_indicator: Execution price to use if price or volume is missing
        '''
        self.price_indicator = price_indicator
        self.volume_indicator = volume_indicator
        self.backup_price_indicator = backup_price_indicator
    
    def __call__(self,
                 orders: Sequence[Order], 
                 i: int, 
                 timestamps: np.ndarray, 
                 indicators: dict[ContractGroup, SimpleNamespace],
                 signals: dict[ContractGroup, SimpleNamespace],
                 strategy_context: SimpleNamespace) -> list[Trade]:
        trades = []
        timestamp = timestamps[i]
        for order in orders:
            if not isinstance(order, VWAPOrder): continue
            cg = order.contract.contract_group
            inds = indicators.get(cg)
            assert_(inds is not None, f'indicators not found for contract group: {cg} {timestamp} {i}')
            price_ind = getattr(inds, self.price_indicator)  # type: ignore
            assert_(price_ind is not None, f'indicator: {self.price_indicator} not found for contract group: {cg} {timestamp} {i}')
            volume_ind = getattr(inds, self.volume_indicator)  # type: ignore
            assert_(volume_ind is not None, f'indicator: {self.volume_indicator} not found for contract group: {cg} {timestamp} {i}')
            end_order = False
            if math.isfinite(order.vwap_stop) and (
                    (order.qty >= 0 and price_ind[i] <= order.vwap_stop) or (order.qty < 0 and price_ind[i] >= order.vwap_stop)):
                end_order = True
            if not end_order and timestamp < order.vwap_end_time and i != len(timestamps) - 1 \
                    and not timestamps[i + 1].astype('M8[D]') > timestamps[i].astype('M8[D]'):
                continue
            mask = (price_ind > 0) & (volume_ind > 0)
            if end_order:
                mask &= (timestamps >= order.timestamp) & (timestamps <= timestamp)
            else:
                mask &= (timestamps >= order.timestamp) & (timestamps <= order.vwap_end_time)
            amt = price_ind[mask] * volume_ind[mask]
            if not len(amt):
                if order.qty <= 0: continue
                _logger.info(f'using backup price for {cg} {timestamp} {i} qty: {order.qty} {order}')
                assert_(self.backup_price_indicator is not None, 
                        f'backup price indicator not found and no vwap found for: {cg} {timestamp} {i}')
                _backup_price_ind = getattr(inds, self.backup_price_indicator)  # type: ignore
                assert_(_backup_price_ind is not None, f'backup price indicator not found for: {cg} {timestamp} {i}')
                vwap = _backup_price_ind[i]
            else:
                vwap = np.sum(amt) / np.sum(volume_ind[mask])
            assert_(vwap >= 0)
            fill_qty = order.qty
            if end_order:
                fill_fraction = (timestamp - order.timestamp) / (order.vwap_end_time - order.timestamp)
                fill_fraction = min(fill_fraction, 1)
                fill_qty = np.fix(order.qty * fill_fraction)
                _logger.info(f'{timestamp} {order.timestamp} {order.vwap_end_time} {fill_fraction} qty: {fill_qty}')
            order.fill(fill_qty)
            order.cancel()
            trade = Trade(order.contract, order, timestamp, fill_qty, vwap)
            _logger.info(f'Trade: {timestamp.astype("M8[m]")} {trade} {i}')
            trades.append(trade)
        return trades
    

ContractFilterType = Callable[
    [Contract, 
     int, 
     np.ndarray, 
     SimpleNamespace, 
     np.ndarray,
     Account, 
     Sequence[Order],
     StrategyContextType],
    list[str] | None]


@dataclass
class FiniteRiskEntryRule:
    '''
    A rule that generates orders with stops
    
    Args:
        reason_code: Reason for the orders created used for display
        price_func: A function that returns price given a contract and timestamp
        long: whether we want to go long or short
        percent_of_equity: How much to risk per trade as a percentage of current equity.
            Used to calculate order qty so that if we get stopped out, we don't lose 
            more than this amount. Of course if price gaps up or down rather than moving smoothly,
            we may lose more.
        stop_price_ind: An indicator containing the stop price so we exit the order when this is breached
        contract_filter: A function that takes similar arguments as a rule (with ContractGroup) replaced by 
            Contract but returns a list of contract names for each positive signal timestamp. For example, 
            for a strategy that trades 5000 stocks, you may want to construct a single signal and apply it 
            to different contracts at different times, rather than create 5000 signals that will call your rule
            5000 times every time the signal is true.
    '''
    reason_code: str
    price_func: PriceFunctionType
    long: bool
    percent_of_equity: float
    stop_price_ind: str | None
    min_price_diff: float
    single_entry_per_day: bool
    contract_filter: ContractFilterType | None
        
    def __init__(self, 
                 reason_code: str, 
                 price_func: PriceFunctionType,
                 long: bool = True,
                 percent_of_equity: float = 0.1,
                 stop_price_ind: str | None = None,
                 min_price_diff: float = 0,
                 single_entry_per_day: bool = False,
                 contract_filter: ContractFilterType | None = None) -> None:
        self.reason_code = reason_code
        self.price_func = price_func
        self.long = long
        self.percent_of_equity = percent_of_equity
        self.stop_price_ind = stop_price_ind
        self.min_price_diff = min_price_diff
        self.single_entry_per_day = single_entry_per_day
        self.contract_filter = contract_filter        

    def __call__(self,
                 contract_group: ContractGroup,
                 i: int,
                 timestamps: np.ndarray,
                 indicator_values: SimpleNamespace,
                 signal_values: np.ndarray,
                 account: Account,
                 current_orders: Sequence[Order],
                 strategy_context: StrategyContextType) -> list[Order]:
        timestamp = timestamps[i]
        if self.single_entry_per_day:
            date = timestamp.astype('M8[D]')
            trades = account.get_trades_for_date(contract_group.name, date)
            if len(trades): return []

        contracts = contract_group.get_contracts()
        orders: list[Order] = []
        for contract in contracts:
            if self.contract_filter is not None:
                relevant_contracts = self.contract_filter(
                    contract, i, timestamps, indicator_values, signal_values, account, current_orders, strategy_context)
                if relevant_contracts is None or contract.symbol not in relevant_contracts: continue

            entry_price_est = self.price_func(contract, timestamps, i, strategy_context)  # type: ignore
            if math.isnan(entry_price_est): return []

            if self.stop_price_ind:
                _stop_price_ind = getattr(indicator_values, self.stop_price_ind)
                stop_price = _stop_price_ind[i]
            else:
                stop_price = 0.

            if self.long and (entry_price_est - stop_price) < self.min_price_diff: return []
            if not self.long and (stop_price - entry_price_est) < self.min_price_diff: return []

            curr_equity = account.equity(timestamp)
            risk_amount = self.percent_of_equity * curr_equity
            order_qty = risk_amount / (entry_price_est - stop_price)
            order_qty /= len(contracts)  # divide up equity equally
            order_qty = math.floor(order_qty) if order_qty > 0 else math.ceil(order_qty)
            if math.isclose(order_qty, 0.): return []
            order = MarketOrder(contract=contract,  # type: ignore
                                timestamp=timestamp, 
                                qty=order_qty,
                                reason_code=self.reason_code)
            orders.append(order)
        return orders
    

@dataclass
class ClosePositionExitRule:
    '''
    A rule to close out an open position
    
    Args:
        reason_code: the reason for closing out used for display purposes
        price_func: the function this rule uses to get market prices
        limit_increment: if not nan, we add or subtract this number from current market price (if selling or buying respectively)
            and create a limit order
        log_orders: if set, we use the python logger to log each order as it is generated
    '''
    reason_code: str
    price_func: PriceFunctionType
    limit_increment: float
        
    def __init__(self, 
                 reason_code: str, 
                 price_func: PriceFunctionType,
                 limit_increment: float = math.nan,
                 log_orders: bool = True) -> None:
        self.reason_code = reason_code
        self.price_func = price_func
        assert_(math.isnan(limit_increment) or limit_increment >= 0, 
                f'limit_increment: {limit_increment} cannot be negative')
        self.limit_increment = limit_increment
        self.log_orders = log_orders
        
    def __call__(self,
                 contract_group: ContractGroup,
                 i: int,
                 timestamps: np.ndarray,
                 indicator_values: SimpleNamespace,
                 signal_values: np.ndarray,
                 account: Account,
                 current_orders: Sequence[Order],
                 strategy_context: StrategyContextType) -> list[Order]:
        timestamp = timestamps[i]
        positions = account.positions(contract_group, timestamp)
        # assert len(positions) == 1, f'expected 1 positions, got: {positions}'
        orders: list[Order] = []
        for (contract, qty) in positions:
            if math.isfinite(self.limit_increment):
                exit_price_est = self.price_func(contract, timestamps, i, strategy_context)
                if qty >= 0:
                    exit_price_est += self.limit_increment
                else:
                    exit_price_est -= self.limit_increment
                limit_order = LimitOrder(contract=contract, timestamp=timestamp, qty=-qty, limit_price=exit_price_est, reason_code=self.reason_code)
                orders.append(limit_order)
                continue
            order = MarketOrder(contract=contract, timestamp=timestamp, qty=-qty, reason_code=self.reason_code)
            orders.append(order)
        if self.log_orders: _logger.info(f'ORDER: {timestamp} {order}')
        return orders
    

if __name__ == "__main__":
    import doctest
    doctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS)
# $$_end_code
