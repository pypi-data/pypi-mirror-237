# Code autogenerated by StandardBots

from dataclasses import dataclass
from typing import List, Tuple, Union
from enum import Enum

def parse_float(data: object) -> float:
  return float(data)

def parse_int(data: object) -> int:
  return int(data)

def parse_bool(data: object) -> bool:
  return bool(data)

def parse_str(data: object) -> str:
  return str(data)

def serialize_float(data: float) -> object:
  return data

def serialize_int(data: int) -> object:
  return data

def serialize_bool(data: bool) -> object:
  return data

def serialize_str(data: str) -> object:
  return data

class ErrorResponseCode(Enum):
  AuthorizationRequired = "authorization_required"
  RoutineMustBeRunning = "routine_must_be_running"
  ApiControlRequired = "api_control_required"
  RobotBrakesDisengageFailed = "robot_brakes_disengage_failed"
  RobotBrakesEngageFailed = "robot_brakes_engage_failed"
  RequestFailedValidation = "request_failed_validation"
  BrakesMustBeEngaged = "brakes_must_be_engaged"
  BrakesMustBeDisengaged = "brakes_must_be_disengaged"

def parse_error_response_code(data: object) -> ErrorResponseCode:
  return ErrorResponseCode(data)

def serialize_error_response_code(data: Union[ErrorResponseCode, str]) -> object:
  return ErrorResponseCode(data).value

@dataclass
class ErrorResponse:
  """Error Response"""
  code: ErrorResponseCode
  message: str

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.code is None:
      raise ValueError("code is required for ErrorResponse")
    if not isinstance(self.code, ErrorResponseCode):
      raise TypeError("code must be of type ErrorResponseCode for ErrorResponse, got " + type(self.code).__name__)
    if self.message is None:
      raise ValueError("message is required for ErrorResponse")
    if not isinstance(self.message, str):
      raise TypeError("message must be of type str for ErrorResponse, got " + type(self.message).__name__)

def parse_error_response(data: object):
  return ErrorResponse(
    code=parse_error_response_code(data["code"]),
    message=parse_str(data["message"]),
  )

def serialize_error_response(data: ErrorResponse) -> object:
  return {
    "code": serialize_error_response_code(data.code),
    "message": serialize_str(data.message),
  }

class MoveRobotEventKind(Enum):
  Success = "success"
  Failure = "failure"
  Canceled = "canceled"
  Position = "position"
  Planning = "planning"

def parse_move_robot_event_kind(data: object) -> MoveRobotEventKind:
  return MoveRobotEventKind(data)

def serialize_move_robot_event_kind(data: Union[MoveRobotEventKind, str]) -> object:
  return MoveRobotEventKind(data).value

class MoveRobotFailureEventCode(Enum):
  MotionFailedUnknownReason = "motion_failed_unknown_reason"
  MotionFailedCollision = "motion_failed_collision"

def parse_move_robot_failure_event_code(data: object) -> MoveRobotFailureEventCode:
  return MoveRobotFailureEventCode(data)

def serialize_move_robot_failure_event_code(data: Union[MoveRobotFailureEventCode, str]) -> object:
  return MoveRobotFailureEventCode(data).value

@dataclass
class MoveRobotFailureEvent:
  """Move robot event when movement failed"""
  code: MoveRobotFailureEventCode
  reason: str

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.code is None:
      raise ValueError("code is required for MoveRobotFailureEvent")
    if not isinstance(self.code, MoveRobotFailureEventCode):
      raise TypeError("code must be of type MoveRobotFailureEventCode for MoveRobotFailureEvent, got " + type(self.code).__name__)
    if self.reason is None:
      raise ValueError("reason is required for MoveRobotFailureEvent")
    if not isinstance(self.reason, str):
      raise TypeError("reason must be of type str for MoveRobotFailureEvent, got " + type(self.reason).__name__)

def parse_move_robot_failure_event(data: object):
  return MoveRobotFailureEvent(
    code=parse_move_robot_failure_event_code(data["code"]),
    reason=parse_str(data["reason"]),
  )

def serialize_move_robot_failure_event(data: MoveRobotFailureEvent) -> object:
  return {
    "code": serialize_move_robot_failure_event_code(data.code),
    "reason": serialize_str(data.reason),
  }

@dataclass
class MoveRobotCanceledEvent:
  """Move robot event when motion is canceled"""
  code: Union[str, None] = None
  reason: Union[str, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.code is None or isinstance(self.code, str)):
      raise TypeError("code must be of type str for MoveRobotCanceledEvent, got " + type(self.code).__name__)
    if not (self.reason is None or isinstance(self.reason, str)):
      raise TypeError("reason must be of type str for MoveRobotCanceledEvent, got " + type(self.reason).__name__)

def parse_move_robot_canceled_event(data: object):
  return MoveRobotCanceledEvent(
    code=parse_str(data["code"]) if "code" in data else None,
    reason=parse_str(data["reason"]) if "reason" in data else None,
  )

def serialize_move_robot_canceled_event(data: MoveRobotCanceledEvent) -> object:
  return {
    "code": None if data.code is None else serialize_str(data.code),
    "reason": None if data.reason is None else serialize_str(data.reason),
  }

JointRotations = Tuple[float,float,float,float,float,float,]

def parse_joint_rotations(data: object) -> JointRotations:
  return (parse_float(data[0]),parse_float(data[1]),parse_float(data[2]),parse_float(data[3]),parse_float(data[4]),parse_float(data[5]),)

def serialize_joint_rotations(data: JointRotations) -> object:
  return [serialize_float(data[0]),serialize_float(data[1]),serialize_float(data[2]),serialize_float(data[3]),serialize_float(data[4]),serialize_float(data[5]),]

@dataclass
class Position:
  """Position of an object in 3D space"""
  x: float
  y: float
  z: float

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.x is None:
      raise ValueError("x is required for Position")
    if not isinstance(self.x, float):
      raise TypeError("x must be of type float for Position, got " + type(self.x).__name__)
    if self.y is None:
      raise ValueError("y is required for Position")
    if not isinstance(self.y, float):
      raise TypeError("y must be of type float for Position, got " + type(self.y).__name__)
    if self.z is None:
      raise ValueError("z is required for Position")
    if not isinstance(self.z, float):
      raise TypeError("z must be of type float for Position, got " + type(self.z).__name__)

def parse_position(data: object):
  return Position(
    x=parse_float(data["x"]),
    y=parse_float(data["y"]),
    z=parse_float(data["z"]),
  )

def serialize_position(data: Position) -> object:
  return {
    "x": serialize_float(data.x),
    "y": serialize_float(data.y),
    "z": serialize_float(data.z),
  }

class OrientationKind(Enum):
  Quaternion = "quaternion"

def parse_orientation_kind(data: object) -> OrientationKind:
  return OrientationKind(data)

def serialize_orientation_kind(data: Union[OrientationKind, str]) -> object:
  return OrientationKind(data).value

@dataclass
class OrientationQuaternion:
  x: float
  y: float
  z: float
  w: float

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.x is None:
      raise ValueError("x is required for OrientationQuaternion")
    if not isinstance(self.x, float):
      raise TypeError("x must be of type float for OrientationQuaternion, got " + type(self.x).__name__)
    if self.y is None:
      raise ValueError("y is required for OrientationQuaternion")
    if not isinstance(self.y, float):
      raise TypeError("y must be of type float for OrientationQuaternion, got " + type(self.y).__name__)
    if self.z is None:
      raise ValueError("z is required for OrientationQuaternion")
    if not isinstance(self.z, float):
      raise TypeError("z must be of type float for OrientationQuaternion, got " + type(self.z).__name__)
    if self.w is None:
      raise ValueError("w is required for OrientationQuaternion")
    if not isinstance(self.w, float):
      raise TypeError("w must be of type float for OrientationQuaternion, got " + type(self.w).__name__)

def parse_orientation_quaternion(data: object):
  return OrientationQuaternion(
    x=parse_float(data["x"]),
    y=parse_float(data["y"]),
    z=parse_float(data["z"]),
    w=parse_float(data["w"]),
  )

def serialize_orientation_quaternion(data: OrientationQuaternion) -> object:
  return {
    "x": serialize_float(data.x),
    "y": serialize_float(data.y),
    "z": serialize_float(data.z),
    "w": serialize_float(data.w),
  }

@dataclass
class Orientation:
  """Orientation of an object in 3D space"""
  kind: OrientationKind
  quaternion: Union[OrientationQuaternion, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.kind is None:
      raise ValueError("kind is required for Orientation")
    if not isinstance(self.kind, OrientationKind):
      raise TypeError("kind must be of type OrientationKind for Orientation, got " + type(self.kind).__name__)
    if not (self.quaternion is None or isinstance(self.quaternion, OrientationQuaternion)):
      raise TypeError("quaternion must be of type OrientationQuaternion for Orientation, got " + type(self.quaternion).__name__)

def parse_orientation(data: object):
  return Orientation(
    kind=parse_orientation_kind(data["kind"]),
    quaternion=parse_orientation_quaternion(data["quaternion"]) if "quaternion" in data else None,
  )

def serialize_orientation(data: Orientation) -> object:
  return {
    "kind": serialize_orientation_kind(data.kind),
    "quaternion": None if data.quaternion is None else serialize_orientation_quaternion(data.quaternion),
  }

@dataclass
class ArmTooltipPosition:
  """Position of the arm tooltip"""
  position: Position
  orientation: Orientation
  referenceFrame: Union[str, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.position is None:
      raise ValueError("position is required for ArmTooltipPosition")
    if not isinstance(self.position, Position):
      raise TypeError("position must be of type Position for ArmTooltipPosition, got " + type(self.position).__name__)
    if self.orientation is None:
      raise ValueError("orientation is required for ArmTooltipPosition")
    if not isinstance(self.orientation, Orientation):
      raise TypeError("orientation must be of type Orientation for ArmTooltipPosition, got " + type(self.orientation).__name__)
    if not (self.referenceFrame is None or isinstance(self.referenceFrame, str)):
      raise TypeError("referenceFrame must be of type str for ArmTooltipPosition, got " + type(self.referenceFrame).__name__)

def parse_arm_tooltip_position(data: object):
  return ArmTooltipPosition(
    position=parse_position(data["position"]),
    orientation=parse_orientation(data["orientation"]),
    referenceFrame=parse_str(data["referenceFrame"]) if "referenceFrame" in data else None,
  )

def serialize_arm_tooltip_position(data: ArmTooltipPosition) -> object:
  return {
    "position": serialize_position(data.position),
    "orientation": serialize_orientation(data.orientation),
    "referenceFrame": None if data.referenceFrame is None else serialize_str(data.referenceFrame),
  }

@dataclass
class CombinedArmPosition:
  joint_rotations: JointRotations
  tooltip_position: ArmTooltipPosition

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.joint_rotations is None:
      raise ValueError("joint_rotations is required for CombinedArmPosition")
    if not isinstance(self.joint_rotations, tuple):
      raise TypeError("joint_rotations must be of type tuple for CombinedArmPosition, got " + type(self.joint_rotations).__name__)
    if self.tooltip_position is None:
      raise ValueError("tooltip_position is required for CombinedArmPosition")
    if not isinstance(self.tooltip_position, ArmTooltipPosition):
      raise TypeError("tooltip_position must be of type ArmTooltipPosition for CombinedArmPosition, got " + type(self.tooltip_position).__name__)

def parse_combined_arm_position(data: object):
  return CombinedArmPosition(
    joint_rotations=parse_joint_rotations(data["joint_rotations"]),
    tooltip_position=parse_arm_tooltip_position(data["tooltip_position"]),
  )

def serialize_combined_arm_position(data: CombinedArmPosition) -> object:
  return {
    "joint_rotations": serialize_joint_rotations(data.joint_rotations),
    "tooltip_position": serialize_arm_tooltip_position(data.tooltip_position),
  }

@dataclass
class MoveRobotEvent:
  """Event emitted by the move robot API"""
  kind: Union[MoveRobotEventKind, None] = None
  failure: Union[MoveRobotFailureEvent, None] = None
  canceled: Union[MoveRobotCanceledEvent, None] = None
  position: Union[CombinedArmPosition, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.kind is None or isinstance(self.kind, MoveRobotEventKind)):
      raise TypeError("kind must be of type MoveRobotEventKind for MoveRobotEvent, got " + type(self.kind).__name__)
    if not (self.failure is None or isinstance(self.failure, MoveRobotFailureEvent)):
      raise TypeError("failure must be of type MoveRobotFailureEvent for MoveRobotEvent, got " + type(self.failure).__name__)
    if not (self.canceled is None or isinstance(self.canceled, MoveRobotCanceledEvent)):
      raise TypeError("canceled must be of type MoveRobotCanceledEvent for MoveRobotEvent, got " + type(self.canceled).__name__)
    if not (self.position is None or isinstance(self.position, CombinedArmPosition)):
      raise TypeError("position must be of type CombinedArmPosition for MoveRobotEvent, got " + type(self.position).__name__)

def parse_move_robot_event(data: object):
  return MoveRobotEvent(
    kind=parse_move_robot_event_kind(data["kind"]) if "kind" in data else None,
    failure=parse_move_robot_failure_event(data["failure"]) if "failure" in data else None,
    canceled=parse_move_robot_canceled_event(data["canceled"]) if "canceled" in data else None,
    position=parse_combined_arm_position(data["position"]) if "position" in data else None,
  )

def serialize_move_robot_event(data: MoveRobotEvent) -> object:
  return {
    "kind": None if data.kind is None else serialize_move_robot_event_kind(data.kind),
    "failure": None if data.failure is None else serialize_move_robot_failure_event(data.failure),
    "canceled": None if data.canceled is None else serialize_move_robot_canceled_event(data.canceled),
    "position": None if data.position is None else serialize_combined_arm_position(data.position),
  }

class ControlBrakesRequestState(Enum):
  Engaged = "engaged"
  Disengaged = "disengaged"

def parse_control_brakes_request_state(data: object) -> ControlBrakesRequestState:
  return ControlBrakesRequestState(data)

def serialize_control_brakes_request_state(data: Union[ControlBrakesRequestState, str]) -> object:
  return ControlBrakesRequestState(data).value

@dataclass
class ControlBrakesRequest:
  """Control the state of the robot joint brakes. Each joint contains a brake which can be engaged when the robot is at a standstill to prevent the robot from moving.
| State           | Purpose |
| -------------- | ------- |
| &#x60;engaged&#x60;      | Robot Brakes are engaged, robot is not able to move |
| &#x60;disengaged&#x60;   | Robot Brakes are disengaged, robot can move freely |
"""
  state: ControlBrakesRequestState

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.state is None:
      raise ValueError("state is required for ControlBrakesRequest")
    if not isinstance(self.state, ControlBrakesRequestState):
      raise TypeError("state must be of type ControlBrakesRequestState for ControlBrakesRequest, got " + type(self.state).__name__)

def parse_control_brakes_request(data: object):
  return ControlBrakesRequest(
    state=parse_control_brakes_request_state(data["state"]),
  )

def serialize_control_brakes_request(data: ControlBrakesRequest) -> object:
  return {
    "state": serialize_control_brakes_request_state(data.state),
  }

@dataclass
class EngageEmergencyStopRequest:
  """Engage Emergency Stop. This will immediately stop the robot and prevent it from moving until the robot is unbraked.
"""
  reason: Union[str, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.reason is None or isinstance(self.reason, str)):
      raise TypeError("reason must be of type str for EngageEmergencyStopRequest, got " + type(self.reason).__name__)

def parse_engage_emergency_stop_request(data: object):
  return EngageEmergencyStopRequest(
    reason=parse_str(data["reason"]) if "reason" in data else None,
  )

def serialize_engage_emergency_stop_request(data: EngageEmergencyStopRequest) -> object:
  return {
    "reason": None if data.reason is None else serialize_str(data.reason),
  }

class CommonLinearUnitKind(Enum):
  Mm = "mm"
  Cm = "cm"
  M = "m"
  Ft = "ft"

def parse_common_linear_unit_kind(data: object) -> CommonLinearUnitKind:
  return CommonLinearUnitKind(data)

def serialize_common_linear_unit_kind(data: Union[CommonLinearUnitKind, str]) -> object:
  return CommonLinearUnitKind(data).value

@dataclass
class CommonLinearUnit:
  """Common Linear Unit
"""
  kind: CommonLinearUnitKind
  mm: Union[float, None] = None
  cm: Union[float, None] = None
  m: Union[float, None] = None
  ft: Union[float, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.kind is None:
      raise ValueError("kind is required for CommonLinearUnit")
    if not isinstance(self.kind, CommonLinearUnitKind):
      raise TypeError("kind must be of type CommonLinearUnitKind for CommonLinearUnit, got " + type(self.kind).__name__)
    if not (self.mm is None or isinstance(self.mm, float)):
      raise TypeError("mm must be of type float for CommonLinearUnit, got " + type(self.mm).__name__)
    if not (self.cm is None or isinstance(self.cm, float)):
      raise TypeError("cm must be of type float for CommonLinearUnit, got " + type(self.cm).__name__)
    if not (self.m is None or isinstance(self.m, float)):
      raise TypeError("m must be of type float for CommonLinearUnit, got " + type(self.m).__name__)
    if not (self.ft is None or isinstance(self.ft, float)):
      raise TypeError("ft must be of type float for CommonLinearUnit, got " + type(self.ft).__name__)

def parse_common_linear_unit(data: object):
  return CommonLinearUnit(
    kind=parse_common_linear_unit_kind(data["kind"]),
    mm=parse_float(data["mm"]) if "mm" in data else None,
    cm=parse_float(data["cm"]) if "cm" in data else None,
    m=parse_float(data["m"]) if "m" in data else None,
    ft=parse_float(data["ft"]) if "ft" in data else None,
  )

def serialize_common_linear_unit(data: CommonLinearUnit) -> object:
  return {
    "kind": serialize_common_linear_unit_kind(data.kind),
    "mm": None if data.mm is None else serialize_float(data.mm),
    "cm": None if data.cm is None else serialize_float(data.cm),
    "m": None if data.m is None else serialize_float(data.m),
    "ft": None if data.ft is None else serialize_float(data.ft),
  }

class CommonForceUnitKind(Enum):
  Newtons = "newtons"
  Pounds = "pounds"

def parse_common_force_unit_kind(data: object) -> CommonForceUnitKind:
  return CommonForceUnitKind(data)

def serialize_common_force_unit_kind(data: Union[CommonForceUnitKind, str]) -> object:
  return CommonForceUnitKind(data).value

@dataclass
class CommonForceUnit:
  """Common Force Unit
"""
  kind: CommonForceUnitKind
  newtons: Union[float, None] = None
  pounds: Union[float, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.kind is None:
      raise ValueError("kind is required for CommonForceUnit")
    if not isinstance(self.kind, CommonForceUnitKind):
      raise TypeError("kind must be of type CommonForceUnitKind for CommonForceUnit, got " + type(self.kind).__name__)
    if not (self.newtons is None or isinstance(self.newtons, float)):
      raise TypeError("newtons must be of type float for CommonForceUnit, got " + type(self.newtons).__name__)
    if not (self.pounds is None or isinstance(self.pounds, float)):
      raise TypeError("pounds must be of type float for CommonForceUnit, got " + type(self.pounds).__name__)

def parse_common_force_unit(data: object):
  return CommonForceUnit(
    kind=parse_common_force_unit_kind(data["kind"]),
    newtons=parse_float(data["newtons"]) if "newtons" in data else None,
    pounds=parse_float(data["pounds"]) if "pounds" in data else None,
  )

def serialize_common_force_unit(data: CommonForceUnit) -> object:
  return {
    "kind": serialize_common_force_unit_kind(data.kind),
    "newtons": None if data.newtons is None else serialize_float(data.newtons),
    "pounds": None if data.pounds is None else serialize_float(data.pounds),
  }

class GripperCommandRequestKind(Enum):
  Onrobot2Fg7 = "onrobot_2fg7"
  Onrobot3Fg15 = "onrobot_3fg15"

def parse_gripper_command_request_kind(data: object) -> GripperCommandRequestKind:
  return GripperCommandRequestKind(data)

def serialize_gripper_command_request_kind(data: Union[GripperCommandRequestKind, str]) -> object:
  return GripperCommandRequestKind(data).value

class GripperCommandRequestOnrobot2Fg7GripDirection(Enum):
  Inward = "inward"
  Outward = "outward"

def parse_gripper_command_request_onrobot_2_fg_7_grip_direction(data: object) -> GripperCommandRequestOnrobot2Fg7GripDirection:
  return GripperCommandRequestOnrobot2Fg7GripDirection(data)

def serialize_gripper_command_request_onrobot_2_fg_7_grip_direction(data: Union[GripperCommandRequestOnrobot2Fg7GripDirection, str]) -> object:
  return GripperCommandRequestOnrobot2Fg7GripDirection(data).value

class GripperCommandRequestOnrobot2Fg7ControlKind(Enum):
  Move = "move"
  ForceGrip = "force_grip"

def parse_gripper_command_request_onrobot_2_fg_7_control_kind(data: object) -> GripperCommandRequestOnrobot2Fg7ControlKind:
  return GripperCommandRequestOnrobot2Fg7ControlKind(data)

def serialize_gripper_command_request_onrobot_2_fg_7_control_kind(data: Union[GripperCommandRequestOnrobot2Fg7ControlKind, str]) -> object:
  return GripperCommandRequestOnrobot2Fg7ControlKind(data).value

@dataclass
class GripperCommandRequestOnrobot2Fg7:
  grip_direction: GripperCommandRequestOnrobot2Fg7GripDirection
  control_kind: Union[GripperCommandRequestOnrobot2Fg7ControlKind, None] = None
  target_force: Union[CommonForceUnit, None] = None
  target_grip_width: Union[CommonLinearUnit, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.grip_direction is None:
      raise ValueError("grip_direction is required for GripperCommandRequestOnrobot2Fg7")
    if not isinstance(self.grip_direction, GripperCommandRequestOnrobot2Fg7GripDirection):
      raise TypeError("grip_direction must be of type GripperCommandRequestOnrobot2Fg7GripDirection for GripperCommandRequestOnrobot2Fg7, got " + type(self.grip_direction).__name__)
    if not (self.control_kind is None or isinstance(self.control_kind, GripperCommandRequestOnrobot2Fg7ControlKind)):
      raise TypeError("control_kind must be of type GripperCommandRequestOnrobot2Fg7ControlKind for GripperCommandRequestOnrobot2Fg7, got " + type(self.control_kind).__name__)
    if not (self.target_force is None or isinstance(self.target_force, CommonForceUnit)):
      raise TypeError("target_force must be of type CommonForceUnit for GripperCommandRequestOnrobot2Fg7, got " + type(self.target_force).__name__)
    if not (self.target_grip_width is None or isinstance(self.target_grip_width, CommonLinearUnit)):
      raise TypeError("target_grip_width must be of type CommonLinearUnit for GripperCommandRequestOnrobot2Fg7, got " + type(self.target_grip_width).__name__)

def parse_gripper_command_request_onrobot_2_fg_7(data: object):
  return GripperCommandRequestOnrobot2Fg7(
    grip_direction=parse_gripper_command_request_onrobot_2_fg_7_grip_direction(data["grip_direction"]),
    control_kind=parse_gripper_command_request_onrobot_2_fg_7_control_kind(data["control_kind"]) if "control_kind" in data else None,
    target_force=parse_common_force_unit(data["target_force"]) if "target_force" in data else None,
    target_grip_width=parse_common_linear_unit(data["target_grip_width"]) if "target_grip_width" in data else None,
  )

def serialize_gripper_command_request_onrobot_2_fg_7(data: GripperCommandRequestOnrobot2Fg7) -> object:
  return {
    "grip_direction": serialize_gripper_command_request_onrobot_2_fg_7_grip_direction(data.grip_direction),
    "control_kind": None if data.control_kind is None else serialize_gripper_command_request_onrobot_2_fg_7_control_kind(data.control_kind),
    "target_force": None if data.target_force is None else serialize_common_force_unit(data.target_force),
    "target_grip_width": None if data.target_grip_width is None else serialize_common_linear_unit(data.target_grip_width),
  }

class GripperCommandRequestOnrobot3Fg15GripDirection(Enum):
  Inward = "inward"
  Outward = "outward"

def parse_gripper_command_request_onrobot_3_fg_15_grip_direction(data: object) -> GripperCommandRequestOnrobot3Fg15GripDirection:
  return GripperCommandRequestOnrobot3Fg15GripDirection(data)

def serialize_gripper_command_request_onrobot_3_fg_15_grip_direction(data: Union[GripperCommandRequestOnrobot3Fg15GripDirection, str]) -> object:
  return GripperCommandRequestOnrobot3Fg15GripDirection(data).value

class GripperCommandRequestOnrobot3Fg15ControlKind(Enum):
  Move = "move"
  ForceGrip = "force_grip"
  FlexibleForceGrip = "flexible_force_grip"

def parse_gripper_command_request_onrobot_3_fg_15_control_kind(data: object) -> GripperCommandRequestOnrobot3Fg15ControlKind:
  return GripperCommandRequestOnrobot3Fg15ControlKind(data)

def serialize_gripper_command_request_onrobot_3_fg_15_control_kind(data: Union[GripperCommandRequestOnrobot3Fg15ControlKind, str]) -> object:
  return GripperCommandRequestOnrobot3Fg15ControlKind(data).value

@dataclass
class GripperCommandRequestOnrobot3Fg15:
  grip_direction: GripperCommandRequestOnrobot3Fg15GripDirection
  target_force: Union[CommonForceUnit, None] = None
  target_grip_diameter: Union[CommonLinearUnit, None] = None
  control_kind: Union[GripperCommandRequestOnrobot3Fg15ControlKind, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.grip_direction is None:
      raise ValueError("grip_direction is required for GripperCommandRequestOnrobot3Fg15")
    if not isinstance(self.grip_direction, GripperCommandRequestOnrobot3Fg15GripDirection):
      raise TypeError("grip_direction must be of type GripperCommandRequestOnrobot3Fg15GripDirection for GripperCommandRequestOnrobot3Fg15, got " + type(self.grip_direction).__name__)
    if not (self.target_force is None or isinstance(self.target_force, CommonForceUnit)):
      raise TypeError("target_force must be of type CommonForceUnit for GripperCommandRequestOnrobot3Fg15, got " + type(self.target_force).__name__)
    if not (self.target_grip_diameter is None or isinstance(self.target_grip_diameter, CommonLinearUnit)):
      raise TypeError("target_grip_diameter must be of type CommonLinearUnit for GripperCommandRequestOnrobot3Fg15, got " + type(self.target_grip_diameter).__name__)
    if not (self.control_kind is None or isinstance(self.control_kind, GripperCommandRequestOnrobot3Fg15ControlKind)):
      raise TypeError("control_kind must be of type GripperCommandRequestOnrobot3Fg15ControlKind for GripperCommandRequestOnrobot3Fg15, got " + type(self.control_kind).__name__)

def parse_gripper_command_request_onrobot_3_fg_15(data: object):
  return GripperCommandRequestOnrobot3Fg15(
    grip_direction=parse_gripper_command_request_onrobot_3_fg_15_grip_direction(data["grip_direction"]),
    target_force=parse_common_force_unit(data["target_force"]) if "target_force" in data else None,
    target_grip_diameter=parse_common_linear_unit(data["target_grip_diameter"]) if "target_grip_diameter" in data else None,
    control_kind=parse_gripper_command_request_onrobot_3_fg_15_control_kind(data["control_kind"]) if "control_kind" in data else None,
  )

def serialize_gripper_command_request_onrobot_3_fg_15(data: GripperCommandRequestOnrobot3Fg15) -> object:
  return {
    "grip_direction": serialize_gripper_command_request_onrobot_3_fg_15_grip_direction(data.grip_direction),
    "target_force": None if data.target_force is None else serialize_common_force_unit(data.target_force),
    "target_grip_diameter": None if data.target_grip_diameter is None else serialize_common_linear_unit(data.target_grip_diameter),
    "control_kind": None if data.control_kind is None else serialize_gripper_command_request_onrobot_3_fg_15_control_kind(data.control_kind),
  }

@dataclass
class GripperCommandRequest:
  """Control the gripper (end effector) of the robot
"""
  kind: GripperCommandRequestKind
  onrobot_2fg7: Union[GripperCommandRequestOnrobot2Fg7, None] = None
  onrobot_3fg15: Union[GripperCommandRequestOnrobot3Fg15, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.kind is None:
      raise ValueError("kind is required for GripperCommandRequest")
    if not isinstance(self.kind, GripperCommandRequestKind):
      raise TypeError("kind must be of type GripperCommandRequestKind for GripperCommandRequest, got " + type(self.kind).__name__)
    if not (self.onrobot_2fg7 is None or isinstance(self.onrobot_2fg7, GripperCommandRequestOnrobot2Fg7)):
      raise TypeError("onrobot_2fg7 must be of type GripperCommandRequestOnrobot2Fg7 for GripperCommandRequest, got " + type(self.onrobot_2fg7).__name__)
    if not (self.onrobot_3fg15 is None or isinstance(self.onrobot_3fg15, GripperCommandRequestOnrobot3Fg15)):
      raise TypeError("onrobot_3fg15 must be of type GripperCommandRequestOnrobot3Fg15 for GripperCommandRequest, got " + type(self.onrobot_3fg15).__name__)

def parse_gripper_command_request(data: object):
  return GripperCommandRequest(
    kind=parse_gripper_command_request_kind(data["kind"]),
    onrobot_2fg7=parse_gripper_command_request_onrobot_2_fg_7(data["onrobot_2fg7"]) if "onrobot_2fg7" in data else None,
    onrobot_3fg15=parse_gripper_command_request_onrobot_3_fg_15(data["onrobot_3fg15"]) if "onrobot_3fg15" in data else None,
  )

def serialize_gripper_command_request(data: GripperCommandRequest) -> object:
  return {
    "kind": serialize_gripper_command_request_kind(data.kind),
    "onrobot_2fg7": None if data.onrobot_2fg7 is None else serialize_gripper_command_request_onrobot_2_fg_7(data.onrobot_2fg7),
    "onrobot_3fg15": None if data.onrobot_3fg15 is None else serialize_gripper_command_request_onrobot_3_fg_15(data.onrobot_3fg15),
  }

class BrakesStateState(Enum):
  Engaged = "engaged"
  Disengaged = "disengaged"

def parse_brakes_state_state(data: object) -> BrakesStateState:
  return BrakesStateState(data)

def serialize_brakes_state_state(data: Union[BrakesStateState, str]) -> object:
  return BrakesStateState(data).value

@dataclass
class BrakesState:
  """State of the robot joint brakes. Each joint contains a brake which can be engaged when the robot is at a standstill to prevent the robot from moving.
| State           | Purpose |
| -------------- | ------- |
| &#x60;engaged&#x60;      | Robot Brakes are engaged, robot is not able to move |
| &#x60;disengaged&#x60;   | Robot Brakes are disengaged, robot can move freely |
"""
  state: BrakesStateState

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.state is None:
      raise ValueError("state is required for BrakesState")
    if not isinstance(self.state, BrakesStateState):
      raise TypeError("state must be of type BrakesStateState for BrakesState, got " + type(self.state).__name__)

def parse_brakes_state(data: object):
  return BrakesState(
    state=parse_brakes_state_state(data["state"]),
  )

def serialize_brakes_state(data: BrakesState) -> object:
  return {
    "state": serialize_brakes_state_state(data.state),
  }

class MoveRequestKind(Enum):
  TooltipPositions = "tooltip_positions"
  TooltipPosition = "tooltip_position"
  JointRotations = "joint_rotations"
  JointRotation = "joint_rotation"

def parse_move_request_kind(data: object) -> MoveRequestKind:
  return MoveRequestKind(data)

def serialize_move_request_kind(data: Union[MoveRequestKind, str]) -> object:
  return MoveRequestKind(data).value

MoveRequestTooltipPositions = List[ArmTooltipPosition]

def parse_move_request_tooltip_positions(data: object) -> MoveRequestTooltipPositions:
  return [parse_arm_tooltip_position(item) for item in data]

def serialize_move_request_tooltip_positions(data: MoveRequestTooltipPositions) -> List[object]:
  return [serialize_arm_tooltip_position(item) for item in data]

@dataclass
class ArmJointRotations:
  """Rotational positions of arm joints"""
  joints: JointRotations

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.joints is None:
      raise ValueError("joints is required for ArmJointRotations")
    if not isinstance(self.joints, tuple):
      raise TypeError("joints must be of type tuple for ArmJointRotations, got " + type(self.joints).__name__)

def parse_arm_joint_rotations(data: object):
  return ArmJointRotations(
    joints=parse_joint_rotations(data["joints"]),
  )

def serialize_arm_joint_rotations(data: ArmJointRotations) -> object:
  return {
    "joints": serialize_joint_rotations(data.joints),
  }

MoveRequestJointRotations = List[ArmJointRotations]

def parse_move_request_joint_rotations(data: object) -> MoveRequestJointRotations:
  return [parse_arm_joint_rotations(item) for item in data]

def serialize_move_request_joint_rotations(data: MoveRequestJointRotations) -> List[object]:
  return [serialize_arm_joint_rotations(item) for item in data]

class MoveRequestResponseKind(Enum):
  Sync = "sync"
  EventStream = "event_stream"

def parse_move_request_response_kind(data: object) -> MoveRequestResponseKind:
  return MoveRequestResponseKind(data)

def serialize_move_request_response_kind(data: Union[MoveRequestResponseKind, str]) -> object:
  return MoveRequestResponseKind(data).value

class MoveRequestResponseEventStreamSubscriptionsSubscriptions(Enum):
  All = "all"
  Events = "events"
  Positions = "positions"

def parse_move_request_response_event_stream_subscriptions_subscriptions(data: object) -> MoveRequestResponseEventStreamSubscriptionsSubscriptions:
  return MoveRequestResponseEventStreamSubscriptionsSubscriptions(data)

def serialize_move_request_response_event_stream_subscriptions_subscriptions(data: Union[MoveRequestResponseEventStreamSubscriptionsSubscriptions, str]) -> object:
  return MoveRequestResponseEventStreamSubscriptionsSubscriptions(data).value

MoveRequestResponseEventStreamSubscriptions = List[MoveRequestResponseEventStreamSubscriptionsSubscriptions]

def parse_move_request_response_event_stream_subscriptions(data: object) -> MoveRequestResponseEventStreamSubscriptions:
  return [parse_move_request_response_event_stream_subscriptions_subscriptions(item) for item in data]

def serialize_move_request_response_event_stream_subscriptions(data: MoveRequestResponseEventStreamSubscriptions) -> List[object]:
  return [serialize_move_request_response_event_stream_subscriptions_subscriptions(item) for item in data]

@dataclass
class MoveRequestResponseEventStream:
  subscriptions: MoveRequestResponseEventStreamSubscriptions

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.subscriptions is None:
      raise ValueError("subscriptions is required for MoveRequestResponseEventStream")
    if not isinstance(self.subscriptions, list):
      raise TypeError("subscriptions must be of type list for MoveRequestResponseEventStream, got " + type(self.subscriptions).__name__)

def parse_move_request_response_event_stream(data: object):
  return MoveRequestResponseEventStream(
    subscriptions=parse_move_request_response_event_stream_subscriptions(data["subscriptions"]),
  )

def serialize_move_request_response_event_stream(data: MoveRequestResponseEventStream) -> object:
  return {
    "subscriptions": serialize_move_request_response_event_stream_subscriptions(data.subscriptions),
  }

@dataclass
class MoveRequestResponse:
  """Specify how the response should be sent
"""
  kind: MoveRequestResponseKind
  event_stream: Union[MoveRequestResponseEventStream, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.kind is None:
      raise ValueError("kind is required for MoveRequestResponse")
    if not isinstance(self.kind, MoveRequestResponseKind):
      raise TypeError("kind must be of type MoveRequestResponseKind for MoveRequestResponse, got " + type(self.kind).__name__)
    if not (self.event_stream is None or isinstance(self.event_stream, MoveRequestResponseEventStream)):
      raise TypeError("event_stream must be of type MoveRequestResponseEventStream for MoveRequestResponse, got " + type(self.event_stream).__name__)

def parse_move_request_response(data: object):
  return MoveRequestResponse(
    kind=parse_move_request_response_kind(data["kind"]),
    event_stream=parse_move_request_response_event_stream(data["event_stream"]) if "event_stream" in data else None,
  )

def serialize_move_request_response(data: MoveRequestResponse) -> object:
  return {
    "kind": serialize_move_request_response_kind(data.kind),
    "event_stream": None if data.event_stream is None else serialize_move_request_response_event_stream(data.event_stream),
  }

@dataclass
class MoveRequest:
  """Move the robot"""
  kind: MoveRequestKind
  tooltip_positions: Union[MoveRequestTooltipPositions, None] = None
  tooltip_position: Union[ArmTooltipPosition, None] = None
  joint_rotations: Union[MoveRequestJointRotations, None] = None
  joint_rotation: Union[ArmJointRotations, None] = None
  response: Union[MoveRequestResponse, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if self.kind is None:
      raise ValueError("kind is required for MoveRequest")
    if not isinstance(self.kind, MoveRequestKind):
      raise TypeError("kind must be of type MoveRequestKind for MoveRequest, got " + type(self.kind).__name__)
    if not (self.tooltip_positions is None or isinstance(self.tooltip_positions, list)):
      raise TypeError("tooltip_positions must be of type list for MoveRequest, got " + type(self.tooltip_positions).__name__)
    if not (self.tooltip_position is None or isinstance(self.tooltip_position, ArmTooltipPosition)):
      raise TypeError("tooltip_position must be of type ArmTooltipPosition for MoveRequest, got " + type(self.tooltip_position).__name__)
    if not (self.joint_rotations is None or isinstance(self.joint_rotations, list)):
      raise TypeError("joint_rotations must be of type list for MoveRequest, got " + type(self.joint_rotations).__name__)
    if not (self.joint_rotation is None or isinstance(self.joint_rotation, ArmJointRotations)):
      raise TypeError("joint_rotation must be of type ArmJointRotations for MoveRequest, got " + type(self.joint_rotation).__name__)
    if not (self.response is None or isinstance(self.response, MoveRequestResponse)):
      raise TypeError("response must be of type MoveRequestResponse for MoveRequest, got " + type(self.response).__name__)

def parse_move_request(data: object):
  return MoveRequest(
    kind=parse_move_request_kind(data["kind"]),
    tooltip_positions=parse_move_request_tooltip_positions(data["tooltip_positions"]) if "tooltip_positions" in data else None,
    tooltip_position=parse_arm_tooltip_position(data["tooltip_position"]) if "tooltip_position" in data else None,
    joint_rotations=parse_move_request_joint_rotations(data["joint_rotations"]) if "joint_rotations" in data else None,
    joint_rotation=parse_arm_joint_rotations(data["joint_rotation"]) if "joint_rotation" in data else None,
    response=parse_move_request_response(data["response"]) if "response" in data else None,
  )

def serialize_move_request(data: MoveRequest) -> object:
  return {
    "kind": serialize_move_request_kind(data.kind),
    "tooltip_positions": None if data.tooltip_positions is None else serialize_move_request_tooltip_positions(data.tooltip_positions),
    "tooltip_position": None if data.tooltip_position is None else serialize_arm_tooltip_position(data.tooltip_position),
    "joint_rotations": None if data.joint_rotations is None else serialize_move_request_joint_rotations(data.joint_rotations),
    "joint_rotation": None if data.joint_rotation is None else serialize_arm_joint_rotations(data.joint_rotation),
    "response": None if data.response is None else serialize_move_request_response(data.response),
  }

class RobotControlModeKind(Enum):
  Api = "api"
  RoutineEditor = "routine_editor"

def parse_robot_control_mode_kind(data: object) -> RobotControlModeKind:
  return RobotControlModeKind(data)

def serialize_robot_control_mode_kind(data: Union[RobotControlModeKind, str]) -> object:
  return RobotControlModeKind(data).value

@dataclass
class RobotControlMode:
  """Definition of Robot Control State, which tells you which service or system is controlling the Robot"""
  kind: Union[RobotControlModeKind, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.kind is None or isinstance(self.kind, RobotControlModeKind)):
      raise TypeError("kind must be of type RobotControlModeKind for RobotControlMode, got " + type(self.kind).__name__)

def parse_robot_control_mode(data: object):
  return RobotControlMode(
    kind=parse_robot_control_mode_kind(data["kind"]) if "kind" in data else None,
  )

def serialize_robot_control_mode(data: RobotControlMode) -> object:
  return {
    "kind": None if data.kind is None else serialize_robot_control_mode_kind(data.kind),
  }

class GripperConfigurationKind(Enum):
  NoneConnected = "none_connected"
  Onrobot2Fg7 = "onrobot_2fg7"
  Onrobot3Fg15 = "onrobot_3fg15"

def parse_gripper_configuration_kind(data: object) -> GripperConfigurationKind:
  return GripperConfigurationKind(data)

def serialize_gripper_configuration_kind(data: Union[GripperConfigurationKind, str]) -> object:
  return GripperConfigurationKind(data).value

@dataclass
class GripperConfiguration:
  """Configuration of gripper, also known as End Effector"""
  kind: Union[GripperConfigurationKind, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.kind is None or isinstance(self.kind, GripperConfigurationKind)):
      raise TypeError("kind must be of type GripperConfigurationKind for GripperConfiguration, got " + type(self.kind).__name__)

def parse_gripper_configuration(data: object):
  return GripperConfiguration(
    kind=parse_gripper_configuration_kind(data["kind"]) if "kind" in data else None,
  )

def serialize_gripper_configuration(data: GripperConfiguration) -> object:
  return {
    "kind": None if data.kind is None else serialize_gripper_configuration_kind(data.kind),
  }

@dataclass
class RoutineEnvironmentVariablesEnvironmentVariables:
  id: Union[str, None] = None
  name: Union[str, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.id is None or isinstance(self.id, str)):
      raise TypeError("id must be of type str for RoutineEnvironmentVariablesEnvironmentVariables, got " + type(self.id).__name__)
    if not (self.name is None or isinstance(self.name, str)):
      raise TypeError("name must be of type str for RoutineEnvironmentVariablesEnvironmentVariables, got " + type(self.name).__name__)

def parse_routine_environment_variables_environment_variables(data: object):
  return RoutineEnvironmentVariablesEnvironmentVariables(
    id=parse_str(data["id"]) if "id" in data else None,
    name=parse_str(data["name"]) if "name" in data else None,
  )

def serialize_routine_environment_variables_environment_variables(data: RoutineEnvironmentVariablesEnvironmentVariables) -> object:
  return {
    "id": None if data.id is None else serialize_str(data.id),
    "name": None if data.name is None else serialize_str(data.name),
  }

RoutineEnvironmentVariables = List[RoutineEnvironmentVariablesEnvironmentVariables]

def parse_routine_environment_variables(data: object) -> RoutineEnvironmentVariables:
  return [parse_routine_environment_variables_environment_variables(item) for item in data]

def serialize_routine_environment_variables(data: RoutineEnvironmentVariables) -> List[object]:
  return [serialize_routine_environment_variables_environment_variables(item) for item in data]

@dataclass
class Routine:
  """Robot Routine containing steps to automate robot movement and operations"""
  id: Union[str, None] = None
  name: Union[str, None] = None
  environmentVariables: Union[RoutineEnvironmentVariables, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.id is None or isinstance(self.id, str)):
      raise TypeError("id must be of type str for Routine, got " + type(self.id).__name__)
    if not (self.name is None or isinstance(self.name, str)):
      raise TypeError("name must be of type str for Routine, got " + type(self.name).__name__)
    if not (self.environmentVariables is None or isinstance(self.environmentVariables, list)):
      raise TypeError("environmentVariables must be of type list for Routine, got " + type(self.environmentVariables).__name__)

def parse_routine(data: object):
  return Routine(
    id=parse_str(data["id"]) if "id" in data else None,
    name=parse_str(data["name"]) if "name" in data else None,
    environmentVariables=parse_routine_environment_variables(data["environmentVariables"]) if "environmentVariables" in data else None,
  )

def serialize_routine(data: Routine) -> object:
  return {
    "id": None if data.id is None else serialize_str(data.id),
    "name": None if data.name is None else serialize_str(data.name),
    "environmentVariables": None if data.environmentVariables is None else serialize_routine_environment_variables(data.environmentVariables),
  }

@dataclass
class RuntimeVariable:
  """Runtime Variable state"""
  value: Union[str, None] = None

  def __post_init__(self):
    # Type check incoming model - raise error if invalid (required or wrong type)
    if not (self.value is None or isinstance(self.value, str)):
      raise TypeError("value must be of type str for RuntimeVariable, got " + type(self.value).__name__)

def parse_runtime_variable(data: object):
  return RuntimeVariable(
    value=parse_str(data["value"]) if "value" in data else None,
  )

def serialize_runtime_variable(data: RuntimeVariable) -> object:
  return {
    "value": None if data.value is None else serialize_str(data.value),
  }

