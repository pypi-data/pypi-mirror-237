# datamodel-codegen --input extensions/unit/unit-openapi.yaml --output extensions/unit/model.py   --target-python-version 3.11 --enum-field-as-literal all
# generated by datamodel-codegen:
#   filename:  unit-openapi.yaml
#   timestamp: 2023-10-09T05:17:14+00:00

from __future__ import annotations

from typing import Dict, List, Literal, Optional, Union

from pydantic import BaseModel, Field


class StringArray(BaseModel):
    __root__: List[str] = Field(..., description="An array of strings.")


class StringOrStringArray(BaseModel):
    __root__: Union[str, StringArray] = Field(
        ..., description="A string or an array of strings."
    )


class JsonSuccessMessage(BaseModel):
    __root__: Optional[Dict[str, str]] = None


class JsonErrorMessage(BaseModel):
    __root__: Optional[Dict[str, str]] = None


class CertBundleChainCertSubj(BaseModel):
    common_name: Optional[str] = None
    country: Optional[str] = None
    state_or_province: Optional[str] = None
    organization: Optional[str] = None
    alt_names: Optional[StringArray] = None


class CertBundleChainCertIssuer(BaseModel):
    common_name: Optional[str] = None
    country: Optional[str] = None
    state_or_province: Optional[str] = None
    organization: Optional[str] = None


class CertBundleChainCertValidity(BaseModel):
    since: Optional[str] = None
    until: Optional[str] = None


class ConfigAccessLogObject(BaseModel):
    format: Optional[str] = Field(
        '$remote_addr - - [$time_local] "$request_line" $status $body_bytes_sent "$header_referer" "$header_user_agent"',
        description="Sets the log format. Besides arbitrary text, can contain any variables Unit supports.",
    )
    path: Optional[str] = Field(None, description="Pathname of the access log file.")


class Automount(BaseModel):
    language_deps: Optional[bool] = Field(
        True,
        description="Controls whether the language runtime dependencies are automounted.",
    )
    procfs: Optional[bool] = Field(
        True, description="Controls whether the procfs is automounted."
    )
    tmpfs: Optional[bool] = Field(
        True, description="Controls whether the tmpfs is automounted."
    )


class Cgroup(BaseModel):
    path: str = Field(
        ...,
        description="Configures absolute or relative path of the app in the cgroups v2 hierarchy.",
    )


class GidmapItem(BaseModel):
    container: int = Field(
        ..., description="Starts the group ID mapping range in the app’s namespace."
    )
    host: int = Field(
        ..., description="Starts the group ID mapping range in the OS namespace."
    )
    size: int = Field(..., description="Size of the ID range in both namespaces.")


class Namespaces(BaseModel):
    cgroup: Optional[bool] = Field(
        False, description="Creates a new cgroup namespace for the app."
    )
    credential: Optional[bool] = Field(
        False, description="Creates a new user namespace for the app."
    )
    mount: Optional[bool] = Field(
        False, description="Creates a new mount namespace for the app."
    )
    network: Optional[bool] = Field(
        False, description="Creates a new network namespace for the app."
    )
    pid: Optional[bool] = Field(
        False, description="Creates a new PID namespace for the app."
    )
    uname: Optional[bool] = Field(
        False, description="Creates a new UTS namespace for the app."
    )


class UidmapItem(BaseModel):
    container: int = Field(
        ..., description="Starts the user ID mapping range in the app’s namespace."
    )
    host: int = Field(
        ..., description="Starts the user ID mapping range in the OS namespace."
    )
    size: int = Field(..., description="Size of the ID range in both namespaces.")


class Isolation(BaseModel):
    automount: Optional[Automount] = Field(
        None, description="Controls mount behavior if rootfs is enabled."
    )
    cgroup: Optional[Cgroup] = Field(None, description="Defines the app’s cgroup.")
    gidmap: Optional[List[GidmapItem]] = Field(
        None, description="Array of group ID mapping objects."
    )
    namespaces: Optional[Namespaces] = None
    rootfs: Optional[str] = Field(
        None,
        description="pathname of the directory to be used as the new file system root for the app.",
    )
    uidmap: Optional[List[UidmapItem]] = Field(
        None, description="Array of user ID mapping objects."
    )


class Limits(BaseModel):
    requests: Optional[int] = Field(
        None, description="Maximum number of requests an app process can serve."
    )
    timeout: Optional[int] = Field(None, description="Request timeout in seconds.")


class Process(BaseModel):
    idle_timeout: Optional[int] = Field(
        None,
        description="Number of seconds Unit waits for before terminating an idle process that exceeds `spare`.",
    )
    max: Optional[int] = Field(
        1,
        description="Maximum number of application processes that Unit maintains (busy and idle).",
    )
    idle: Optional[int] = Field(
        None,
        description="Minimum number of idle processes that Unit tries to maintain for an app.",
    )


class ConfigApplicationCommon(BaseModel):
    type: Literal["external", "java", "perl", "php", "python", "ruby"] = Field(
        ..., description="Application type and language version."
    )
    environment: Optional[Dict[str, str]] = Field(
        None, description="Environment variables to be passed to the app."
    )
    group: Optional[str] = Field(
        None, description="Group name that runs the app process."
    )
    isolation: Optional[Isolation] = Field(
        None, description="Manages the isolation of an application process."
    )
    limits: Optional[Limits] = Field(
        None, description="Governs the life cycle of an application process."
    )
    processes: Optional[Union[int, Process]] = Field(
        1, description="Governs the behavior of app processes."
    )
    user: Optional[str] = Field(None, description="Username that runs the app process.")
    stderr: Optional[str] = Field(
        None, description="Filename where Unit redirects the app's stderr stream."
    )
    stdout: Optional[str] = Field(
        None, description="Filename where Unit redirects the app's stdout stream."
    )
    working_directory: Optional[str] = Field(
        None, description="The app’s working directory."
    )


class ConfigApplicationExternal(ConfigApplicationCommon):
    executable: str = Field(
        ...,
        description="Pathname of the app, absolute or relative to `working_directory`.",
    )
    arguments: Optional[StringArray] = Field(
        None, description="Command-line arguments to be passed to the app."
    )


class ConfigApplicationJava(ConfigApplicationCommon):
    webapp: str = Field(
        ...,
        description="Pathname of the application’s .war file (packaged or unpackaged).",
    )
    classpath: Optional[StringArray] = Field(
        None,
        description="Paths to your app’s required libraries (may point to directories or individual .jar files).",
    )
    options: Optional[StringArray] = None
    thread_stack_size: Optional[int] = Field(
        None, description="Stack size of a worker thread in bytes."
    )
    threads: Optional[int] = Field(
        1, description="Number of worker threads per app process."
    )


class ConfigApplicationPerl(ConfigApplicationCommon):
    script: str = Field(..., description="PSGI script path.")
    thread_stack_size: Optional[int] = Field(
        None, description="Stack size of a worker thread in bytes."
    )
    threads: Optional[int] = Field(
        1, description="Number of worker threads per app process."
    )


class Options(BaseModel):
    admin: Optional[Dict[str, str]] = Field(
        None, description="Extra directives set in PHP_INI_SYSTEM mode."
    )
    file: Optional[str] = Field(None, description="Pathname of the php.ini file.")
    user: Optional[Dict[str, str]] = Field(
        None, description="Extra directives set in PHP_INI_USER mode."
    )


class Targets(BaseModel):
    root: str = Field(..., description="Base directory of the target’s file structure.")
    index: Optional[str] = Field(
        "index.php",
        description="Filename added to URI paths that point to directories if no `script` is set.",
    )
    script: Optional[str] = Field(
        None,
        description="Filename of a `root`-based PHP script that serves all requests to the target.",
    )


class ConfigApplicationPHP(ConfigApplicationCommon):
    root: str = Field(..., description="Base directory of the app’s file structure.")
    index: Optional[str] = Field(
        "index.php",
        description="Filename added to URI paths that point to directories if no `script` is set.",
    )
    options: Optional[Options] = Field(
        None, description="Defines the php.ini location and options."
    )
    script: Optional[str] = Field(
        None,
        description="Filename of a `root`-based PHP script that serves all requests to the app.",
    )
    targets: Optional[Dict[str, Targets]] = Field(
        None,
        description="Application sections with custom `root`, `script`, and `index` values.",
    )


class Targets1(BaseModel):
    module: str = Field(..., description="Target's module name.")
    callable: Optional[str] = Field(
        "application",
        description="Name of the `module`-based callable that Unit runs as the target.",
    )
    prefix: Optional[str] = Field(
        None,
        description="SCRIPT_NAME context value for WSGI or the root_path context value for ASGI.",
    )


class ConfigApplicationPython(ConfigApplicationCommon):
    module: str = Field(..., description="App’s module name.")
    callable: Optional[str] = Field(
        "application",
        description="Name of the `module`-based callable that Unit runs as the app.",
    )
    home: Optional[str] = Field(
        None,
        description="Path to the app’s virtual environment, absolute or relative to `working_directory`.",
    )
    path: Optional[Union[str, StringArray]] = Field(
        None, description="Additional Python module lookup paths."
    )
    prefix: Optional[str] = Field(
        None,
        description="SCRIPT_NAME context value for WSGI or the root_path context value for ASGI.",
    )
    protocol: Optional[Literal["asgi", "wsgi"]] = Field(
        None, description="Hints Unit that the app uses a certain interface."
    )
    targets: Optional[Dict[str, Targets1]] = Field(
        None, description="App sections with custom `module` and `callable` values."
    )
    thread_stack_size: Optional[int] = Field(
        None, description="Stack size of a worker thread in bytes."
    )
    threads: Optional[int] = Field(
        1, description="Number of worker threads per app process."
    )


class ConfigApplicationRuby(ConfigApplicationCommon):
    script: str = Field(
        ..., description="Rack script pathname, including the .ru extension."
    )
    hooks: Optional[str] = Field(
        None,
        description="Pathname of the .rb file setting the event hooks invoked during the app’s lifecycle.",
    )
    threads: Optional[int] = Field(
        1, description="Number of worker threads per app process."
    )


class ConfigRouteStepMatchObject(BaseModel):
    __root__: Optional[Dict[str, StringOrStringArray]] = None


class ConfigRouteStepMatchObjectArray(BaseModel):
    __root__: List[ConfigRouteStepMatchObject] = Field(
        ..., description="An array whose items define sets of conditions."
    )


class ConfigRouteStepActionPass(BaseModel):
    pass_: str = Field(
        ...,
        alias="pass",
        description="Destination to which the action passes incoming requests.",
    )


class ConfigRouteStepActionProxy(BaseModel):
    proxy: str = Field(
        ...,
        description="Socket address of an HTTP server to where the request is proxied.",
    )


class ConfigRouteStepActionReturn(BaseModel):
    return_: int = Field(
        ...,
        alias="return",
        description="Defines the HTTP response status code to be returned.",
    )
    location: Optional[str] = Field(
        None, description="URI; used if the return value implies redirection."
    )


class ConfigListenerTlsCertificate(BaseModel):
    __root__: Union[str, StringArray] = Field(
        ..., description="Refers to one or more certificate bundles uploaded earlier."
    )


class ConfigListenerTlsConfCommands(BaseModel):
    __root__: Optional[Dict[str, str]] = None


class ConfigListenerTlsSessionTickets(BaseModel):
    __root__: Union[bool, str, StringArray] = Field(
        ..., description="Configures TLS session tickets."
    )


class ConfigListenerForwarded(BaseModel):
    client_ip: Optional[str] = Field(
        None,
        description="Defines the HTTP header fields to expect in the request; uses the `X-Forwarded-For` format.",
    )
    source: Union[str, StringArray] = Field(
        ..., description="Defines address-based patterns for trusted addresses."
    )
    recursive: Optional[bool] = Field(
        False, description="Controls how the `client_ip` fields are traversed."
    )
    protocol: Optional[Literal["http", "https", "on"]] = Field(
        None,
        description="Defines the relevant HTTP header field to expect in the request; uses the `X-Forwarded-Proto` format.",
    )


class ConfigSettingsHttpStaticMimeType(BaseModel):
    __root__: Union[str, StringArray] = Field(
        ...,
        description="An entity that defines an individual MIME type by listing file extensions.",
    )


class StatusApplicationsAppProcesses(BaseModel):
    running: Optional[int] = Field(None, description="Current running app processes.")
    starting: Optional[int] = Field(None, description="Current starting app processes.")
    idle: Optional[int] = Field(None, description="Current idle app processes.")


class StatusApplicationsAppRequests(BaseModel):
    active: Optional[int] = Field(None, description="Active app requests.")


class StatusRequests(BaseModel):
    total: Optional[int] = Field(
        None, description="Total non-API requests during the instance’s lifetime."
    )


class StatusConnections(BaseModel):
    accepted: Optional[int] = Field(
        None, description="Total accepted connections during the instance’s lifetime."
    )
    active: Optional[int] = Field(
        None, description="Current active connections for the instance."
    )
    idle: Optional[int] = Field(
        None, description="Current idle connections for the instance."
    )
    closed: Optional[int] = Field(
        None, description="Total closed connections during the instance’s lifetime."
    )


class CertBundleChainCert(BaseModel):
    subject: Optional[CertBundleChainCertSubj] = None
    issuer: Optional[CertBundleChainCertIssuer] = None
    validity: Optional[CertBundleChainCertValidity] = None


class ConfigAccessLog(BaseModel):
    __root__: Union[str, ConfigAccessLogObject] = Field(
        ..., description="Configures the access log."
    )


class ConfigApplication(BaseModel):
    __root__: Union[
        ConfigApplicationExternal,
        ConfigApplicationJava,
        ConfigApplicationPerl,
        ConfigApplicationPHP,
        ConfigApplicationPython,
        ConfigApplicationRuby,
    ] = Field(
        ...,
        description="An object that defines an individual application.",
        discriminator="type",
    )


class ConfigRouteStepMatch(BaseModel):
    arguments: Optional[
        Union[ConfigRouteStepMatchObject, ConfigRouteStepMatchObjectArray]
    ] = Field(None, description="Arguments supplied with the request’s query string.")
    cookies: Optional[
        Union[ConfigRouteStepMatchObject, ConfigRouteStepMatchObjectArray]
    ] = Field(None, description="Cookies supplied with the request.")
    destination: Optional[StringOrStringArray] = Field(
        None, description="Target IP address and optional port of the request."
    )
    headers: Optional[
        Union[ConfigRouteStepMatchObject, ConfigRouteStepMatchObjectArray]
    ] = Field(None, description="Header fields supplied with the request.")
    host: Optional[StringOrStringArray] = Field(None, description="Host header field.")
    method: Optional[StringOrStringArray] = Field(
        None, description="Method from the request line."
    )
    query: Optional[StringOrStringArray] = Field(None, description="Query string.")
    scheme: Optional[Literal["http", "https"]] = Field(
        None,
        description="URI scheme. Accepts only two patterns, either `http` or `https`.",
    )
    source: Optional[StringOrStringArray] = Field(
        None, description="Source IP address and optional port of the request."
    )
    uri: Optional[StringOrStringArray] = Field(None, description="Request target.")


class ConfigListenerTlsSession(BaseModel):
    cache_size: Optional[int] = Field(
        0, description="Number of sessions in the TLS session cache."
    )
    timeout: Optional[int] = Field(
        300, description="Session timeout for the TLS session cache in seconds."
    )
    tickets: Optional[ConfigListenerTlsSessionTickets] = None


class ConfigSettingsHttpStaticMimeTypes(BaseModel):
    __root__: Optional[Dict[str, ConfigSettingsHttpStaticMimeType]] = None


class StatusApplicationsApp(BaseModel):
    processes: Optional[StatusApplicationsAppProcesses] = None
    requests: Optional[StatusApplicationsAppRequests] = None


class CertBundleChain(BaseModel):
    __root__: List[CertBundleChainCert] = Field(
        ..., description="An array whose items represent certificates in a bundle."
    )


class ConfigApplications(BaseModel):
    __root__: Optional[Dict[str, ConfigApplication]] = None


class ConfigListenerTls(BaseModel):
    conf_commands: Optional[ConfigListenerTlsConfCommands] = None
    session: Optional[ConfigListenerTlsSession] = None
    certificate: ConfigListenerTlsCertificate


class ConfigSettingsHttpStatic(BaseModel):
    mime_types: Optional[ConfigSettingsHttpStaticMimeTypes] = None


class StatusApplications(BaseModel):
    __root__: Optional[Dict[str, StatusApplicationsApp]] = None


class CertBundle(BaseModel):
    key: Optional[str] = Field(
        None, description="Certificate bundle's key type, i. e. RSA, ECDSA, etc."
    )
    chain: Optional[CertBundleChain] = None


class ConfigListener(BaseModel):
    tls: Optional[ConfigListenerTls] = None
    forwarded: Optional[ConfigListenerForwarded] = None
    pass_: Optional[str] = Field(
        None,
        alias="pass",
        description="Destination to which the listener passes incoming requests.",
    )


class ConfigSettingsHttp(BaseModel):
    body_read_timeout: Optional[int] = Field(
        30,
        description="Maximum number of seconds to read data from the body of a client’s request.",
    )
    discard_unsafe_fields: Optional[bool] = Field(
        True,
        description="If `true`, Unit only processes header names made of alphanumerics and hyphens.",
    )
    header_read_timeout: Optional[int] = Field(
        30,
        description="Maximum number of seconds to read the header of a client’s request.",
    )
    idle_timeout: Optional[int] = Field(
        180,
        description="Maximum number of seconds between requests in a keep-alive connection.",
    )
    log_route: Optional[bool] = Field(
        False, description="Enables or disables router logging."
    )
    max_body_size: Optional[int] = Field(
        8388608,
        description="Maximum number of bytes in the body of a client’s request.",
    )
    send_timeout: Optional[int] = Field(
        30,
        description="Maximum number of seconds to transmit data as a response to the client.",
    )
    server_version: Optional[bool] = Field(
        True,
        description="Enables or disables version numbers in Unit's `Server` header fields.",
    )
    static: Optional[ConfigSettingsHttpStatic] = Field(
        None, description="Configures static asset handling."
    )


class Status(BaseModel):
    connections: Optional[StatusConnections] = None
    requests: Optional[StatusRequests] = None
    applications: Optional[StatusApplications] = None


class Cert(BaseModel):
    __root__: Optional[Dict[str, CertBundle]] = None


class ConfigListeners(BaseModel):
    __root__: Optional[Dict[str, ConfigListener]] = None


class ConfigSettings(BaseModel):
    http: Optional[ConfigSettingsHttp] = Field(
        None, description="Represents global HTTP settings in Unit."
    )


class Config(BaseModel):
    access_log: Optional[ConfigAccessLog] = None
    applications: Optional[ConfigApplications] = None
    routes: Optional[ConfigRoutes] = None
    listeners: Optional[ConfigListeners] = None
    settings: Optional[ConfigSettings] = None


class ConfigRoutes(BaseModel):
    __root__: Union[ConfigRouteArray, ConfigRoutesObject] = Field(
        ..., description="Configures the routes."
    )


class ConfigRouteArray(BaseModel):
    __root__: List[ConfigRouteStep] = Field(
        ..., description="An array whose items define individual route steps."
    )


class ConfigRoutesObject(BaseModel):
    __root__: Optional[Dict[str, ConfigRouteArray]] = Field(
        None, description="Individual route arrays."
    )


class ConfigRouteStep(BaseModel):
    action: ConfigRouteStepAction = Field(
        ..., description="Defines how matching requests are handled."
    )
    match: Optional[ConfigRouteStepMatch] = Field(
        None, description="Defines the step’s conditions to be matched."
    )


class ConfigRouteStepAction(BaseModel):
    __root__: Union[
        ConfigRouteStepActionPass,
        ConfigRouteStepActionProxy,
        ConfigRouteStepActionReturn,
        ConfigRouteStepActionShare,
    ] = Field(..., description="An object whose options define a step's action.")


class ConfigRouteStepActionShare(BaseModel):
    share: StringOrStringArray = Field(
        ..., description="Lists file paths that are tried until a file is found."
    )
    index: Optional[str] = Field(
        "index.html", description="Filename; tried if share is a directory."
    )
    fallback: Optional[ConfigRouteStepAction] = Field(
        None, description="Used if the request can’t be served by share or index."
    )
    types: Optional[StringArray] = Field(
        None, description="Used to filter the shared files."
    )
    chroot: Optional[str] = Field(
        None, description="Directory pathname that restricts the shareable paths."
    )
    follow_symlinks: Optional[bool] = Field(
        True, description="Turns on and off symbolic link resolution."
    )
    traverse_mounts: Optional[bool] = Field(
        True, description="Turns on and off mount point resolution."
    )


Config.update_forward_refs()
ConfigRoutes.update_forward_refs()
ConfigRouteArray.update_forward_refs()
ConfigRouteStep.update_forward_refs()
ConfigRouteStepAction.update_forward_refs()
