"""Autogenerated SQLAlchemy models based on OpenAlchemy models."""
# pylint: disable=no-member,super-init-not-called,unused-argument

import typing

import sqlalchemy
from sqlalchemy import orm

from open_alchemy import models

Base = models.Base  # type: ignore


class _FlaskAppFileDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    id: int
    name: str
    flaskapp: "FlaskAppDict"


class FlaskAppFileDict(_FlaskAppFileDictBase, total=False):
    """TypedDict for properties that are not required."""

    content: typing.Optional[str]
    flaskapp_id: int


class TFlaskAppFile(typing.Protocol):
    """
    SQLAlchemy model protocol.

    The files for a FlaskApp.

    Attrs:
        id: Unique identifier for the FlaskAppFiles.
        name: The name of the FlaskAppFile.
        content: The contents of the FlaskAppFile.
        flaskapp_id: The flaskapp_id of the FlaskAppFile.
        flaskapp: The flaskapp of the FlaskAppFile.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[str]'
    content: 'sqlalchemy.Column[typing.Optional[str]]'
    flaskapp_id: 'sqlalchemy.Column[int]'
    flaskapp: 'sqlalchemy.Column["TFlaskApp"]'

    def __init__(self, id: int, name: str, flaskapp: "TFlaskApp", content: typing.Optional[str] = None, flaskapp_id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: Unique identifier for the FlaskAppFiles.
            name: The name of the FlaskAppFile.
            content: The contents of the FlaskAppFile.
            flaskapp_id: The flaskapp_id of the FlaskAppFile.
            flaskapp: The flaskapp of the FlaskAppFile.

        """
        ...

    @classmethod
    def from_dict(cls, id: int, name: str, flaskapp: "FlaskAppDict", content: typing.Optional[str] = None, flaskapp_id: typing.Optional[int] = None) -> "TFlaskAppFile":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: Unique identifier for the FlaskAppFiles.
            name: The name of the FlaskAppFile.
            content: The contents of the FlaskAppFile.
            flaskapp_id: The flaskapp_id of the FlaskAppFile.
            flaskapp: The flaskapp of the FlaskAppFile.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TFlaskAppFile":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> FlaskAppFileDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


FlaskAppFile: typing.Type[TFlaskAppFile] = models.FlaskAppFile  # type: ignore


class _FlaskAppDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    id: int
    name: str
    app_py: str


class FlaskAppDict(_FlaskAppDictBase, total=False):
    """TypedDict for properties that are not required."""

    requirements_txt: typing.Optional[str]
    settings_yaml: typing.Optional[str]
    route: typing.Optional[str]


class TFlaskApp(typing.Protocol):
    """
    SQLAlchemy model protocol.

    A Flask application.

    Attrs:
        id: Unique identifier for the FlaskApp.
        name: The name of the Flask App.
        requirements_txt: The contents of a requirements.txt file for the app
        app_py: The contents of a app.py file for the app. The file should
            contain an 'app' callable
        settings_yaml: The contents of a settings.yaml file for the app.
        route: The route to the app.
        files: The files of the FlaskApp.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[str]'
    requirements_txt: 'sqlalchemy.Column[typing.Optional[str]]'
    app_py: 'sqlalchemy.Column[str]'
    settings_yaml: 'sqlalchemy.Column[typing.Optional[str]]'
    route: 'sqlalchemy.Column[typing.Optional[str]]'
    files: 'sqlalchemy.Column[typing.Sequence["TFlaskAppFile"]]'

    def __init__(self, id: int, name: str, app_py: str, requirements_txt: typing.Optional[str] = None, settings_yaml: typing.Optional[str] = None, route: typing.Optional[str] = None, files: typing.Optional[typing.Sequence["TFlaskAppFile"]] = None) -> None:
        """
        Construct.

        Args:
            id: Unique identifier for the FlaskApp.
            name: The name of the Flask App.
            requirements_txt: The contents of a requirements.txt file for the
                app
            app_py: The contents of a app.py file for the app. The file should
                contain an 'app' callable
            settings_yaml: The contents of a settings.yaml file for the app.
            route: The route to the app.
            files: The files of the FlaskApp.

        """
        ...

    @classmethod
    def from_dict(cls, id: int, name: str, app_py: str, requirements_txt: typing.Optional[str] = None, settings_yaml: typing.Optional[str] = None, route: typing.Optional[str] = None) -> "TFlaskApp":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: Unique identifier for the FlaskApp.
            name: The name of the Flask App.
            requirements_txt: The contents of a requirements.txt file for the
                app
            app_py: The contents of a app.py file for the app. The file should
                contain an 'app' callable
            settings_yaml: The contents of a settings.yaml file for the app.
            route: The route to the app.
            files: The files of the FlaskApp.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TFlaskApp":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> FlaskAppDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


FlaskApp: typing.Type[TFlaskApp] = models.FlaskApp  # type: ignore
