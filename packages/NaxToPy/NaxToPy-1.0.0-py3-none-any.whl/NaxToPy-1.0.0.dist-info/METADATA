Metadata-Version: 2.1
Name: NaxToPy
Version: 1.0.0
Summary: Package for postprocessing FEM results in Python
Home-page: https://idaerosolutions.com/
Download-URL: https://idaerosolutions.com/Home/NaxTo
Author-email: Idaero Solutions <manuel.sanchez@idaerosolutions.com>
License: Copyright (c) 2023 Idaero Solutions
        
        This freeware license agreement (“agreement”) is a legally binding contract
        between the individual who downloads the software (“you”) and the licensor,
        that should be read in its entirety. This is an agreement governing your use
        this software own by Idaero Solutions, further defined herein as “software”,
        and the licensor of the software is willing to provide you with access to the
        software only on the condition that you accept all of the terms and conditions
        contained in this agreement. You are deemed to have read, understood and accepted
        all such terms and conditions upon executing a download of any free software.
        
        1. License Grant:
        
        	Subject to the terms and conditions of this Agreement, Idaero Solutions grants
        	the User a limited, non-exclusive, non-transferable license to use the Software
        	solely for non commercial purposes. This license does not grant any rights to the
        	source code of the Software. It is only free for non-professional and non-commercial
        	purposes.
        
        2. Ownership:
        
        	The User acknowledges that the Software, including any and all intellectual
        	property rights associated with it, is the sole property of Idaero Solutions.
        	The User agrees not to claim ownership or proprietary rights over the Software.
        
        3. Distribution:
        
        	The User is allowed to distribute the Software to third parties free of charge,
        	ONLY under .exe files that use the software as a dependence of the script,
        	provided that the distribution includes the complete and unmodified Software
        	package as originally provided by Idaero Solutions. The User must not charge
        	any fees or payments for the distribution of the Software.
        
        4. Modifications:
        
        	The User agrees not to modify, adapt, reverse engineer, decompile or disassemble,
        	the Software. Any attempt to do so shall be a violation of this Agreement. The
        	User is allowed to develop further code based on the Software. However, the
        	User agrees that the new software shall be subject to the same license terms
        	as this Agreement, including the prohibition on modification, reverse
        	engineering, and proprietization.
        
        5. Proprietization:
        
        	The User agrees not to use the Software or any part thereof to develop a
        	competing product or service or engage in any activities that may lead to
        	the proprietization of the Software.
        
        6. Termination:
        
        	This Agreement is effective until terminated. Idaero Solutions may terminate this
        	Agreement immediately and without notice if the User fails to comply with any
        	of the terms and conditions herein. Upon termination, the User must cease all
        	use of the Software and destroy all copies in their possession.
        
        7. Warranty and Liability:
        
        	The software is provided "as is", without warranty of any kind, express or
        	implied, including but not limited to the warranties of merchantability,
        	fitness for a particular purpose and noninfringement. In no event shall the
        	authors or copyright holders be liable for any claim, damages or other
        	liability, whether in an action of contract, tort or otherwise, arising from,
        	out of or in connection with the software or the use or other dealings in the
        	software.
        	
        8. An extension of NaxTo(c) from Idaero:
        
        	The software is an extension of the NaxTo software from Idaero Solutions.
        	Therefore, the terms of use of this software are an extension of the
        	NaxTo license.
        
        9. Governing Law:
        
        	This Agreement shall be governed by and construed in accordance with the laws
        	of the jurisdiction in which Idaero Solutions is located.
        
        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.
Project-URL: Documentation, https://idaerosolutions.com/Home/NaxTo
Project-URL: LinkedIn, https://www.linkedin.com/company/idaero/
Keywords: NaxTo,Postprocessing,FEM
Classifier: Intended Audience :: Science/Research
Classifier: Programming Language :: Python :: 3.9
Classifier: License :: Other/Proprietary License
Classifier: Operating System :: Microsoft :: Windows :: Windows 10
Classifier: Topic :: Scientific/Engineering
Requires-Python: >=3.9
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: pythonnet >=3.0.1
Requires-Dist: numpy >=1.22.0

![](https://idaerosolutions.com/images/external/NaxToPy/Logo%20NaxToPy_Black.png "NaxToPy")

# NaxToPy

**NaxToPy** is a package developed by Idaero Solutions© as a part of the **NaxTo** software.
It reads the data from the results files of the more common FEM tools and keep them
in an easy python structure. It also read inpu files from nastran (commonly named .bdf) Combined with other packages such as pandas and matplotlib it is a
powerful tool to postprocess the FEM analysis.

## Installation

If python is callable from the command line:

`py -m pip install NaxToPy`

For **Visual Studio** users:
- Open "Python Environments" window
- Change the "general information" label to "Packages(Pypi)"
- Write the name of the package and press enter:

- `NaxToPy` + enter

For **Spyder** users:
- If pip is installed: `!pip install NaxToPy`
- If pip is not installed, download and run `get-pip.py` located in  https://bootstrap.pypa.io/get-pip.py . Then, run the
`!pip ...` command
- If no method worked, download the sorce ditribution of the package *NaxToPy* from Test PyPi and the source
distribution of the packages from PyPi *pythonnet*, *clr-loader*, *cffi*, *pycparser*. Copy and paste the five folder in the 
same directory. When ever you want to use the NaxToPy package add the following lines to your script:

      import sys
      sys.path.append("...\directory")
      import NaxToPy as n2p
## Updating NaxToPy

If python is callable from the command line:

`py -m pip install -U NaxToPy`

For Visual Studio users:
- Open "Python Environments" window
- Change the "general information" label to "Packages(Pypi)"
- Write the following command on the search bar and press enter:

`-U NaxToPy` + enter


## Version updates:

To see previous version see the pre-release versions in https://test.pypi.org/project/NaxToPy/

# Documentation

This version is only compatible with **NaxTo 2024.0.0**.
Check in Programs and Features the NaxTo version that is installed.
NaxToPy only use two dependeces:
- NumPy: https://numpy.org/
- PythonNET: https://pythonnet.github.io/

## Supported Files

### Result files:
- **Nastran:** .op2, .h5, .xdb
- **Optistruct:** .op2, .h3d
- **Abaqus:** .odb
- **Ansys:** .rst, .rth(beta)

### Input files:
- **Nastran** (bdf)

## Initialize your model

Load your model:

```python
# results_fem.py
import NaxToPy as N2P

path = "results_fem.op2"

model = N2P.load_model(path)
```

## Load mesh items

```python
# results_fem.py

# Load a list with all the nodes (as N2PNode object) of the model
nodes = model.get_nodes()

# Load the nodes in the list [1, 2, 3] (as a list of N2PNode objects)
nodelist = model.get_nodes([1, 2, 3]) 

# Load the node with the id 1000 (as a N2PNode object)
node1000 = model.get_nodes(1000)

# Load a list with all the elements (as N2PElement object) of the model
element = model.get_elements()

# Load the elements in the list [10, 20, 30] (as a list of N2PElement objects)
elementlist = model.get_nodes([10, 20, 30])

# Load the connectors as N2PConnector:
connectorslist = model.get_connectors()

# Load the coordinate systems of the model:
coordslist = model.get_coords()
```
## Add your own messages to the .log

```python
# results_fem.py

N2P.N2PLog.Info.user("INFO-1000: Running results_fem.py")
```

## Look for LoadCases, Results and Components

```python
# results_fem.py

# Load the list of load cases as N2PLoadCase object
loadcaseslist = model.LoadCases

# Look for the Load Case with the name pressure
pressure_lc = model.get_load_case("pressure")

# Change the active increment (by default is the last one):
pressure_lc.ActiveIncrement = 10

# Look for all results
all_results = pressure_lc.Results

# Look for the Result with the name DISPLACEMENT
displacement = pressure_lc.get_result("DISPLACEMENT")

# Load all the components of the result
all_components = displacement.Components

# Look for the component X:
x_coord = displacement.get_component("X")
```

## Load the result data as a list

```python
# results_fem.py

# Obtain the result array as a list for a component
x_list = x_coord.get_result_array()[0]
```

## Load the result data as a NumPy array

```python
# results_fem.py

# Call the get_result_ndarray method of a N2PComponent to obtain a numpy array
# with the results of the component.
x_df = x_coord.get_result_ndarray()
```

## Create an executable of your code
Using a different script:
```python
# extra_script.py

import NaxToPy as N2P
path1 = "results_fem.py"
path2 = "results_fem_abaqus.py"

N2P.n2ptoexe(path1, console=True, solver="NASTRAN")
N2P.n2ptoexe(path2, console=True, solver="ABAQUS", abaqusversion=["2021", "2022"])
```

## Create your own functions to work with other python packages:
Private function that generates the proper index for a data frame using the elemnts or nodes ids:
```python
# results_fem.py

import pandas as pd

def _index_dataframe(model: "N2PModelContent", component: "N2PComponent", sections, aveSections, cornerData, aveNodes,
                     variation, realPolar, coordsys, v1, v2) -> pd.Index:
    """ Function that returns the proper index for each component asked
    """
    # It is look if there is one part or several's:
    parts = len(model.Parts) - (model.Solver == "Abaqus")

    # Then the result array and where there results are placed is obtained
    on_items = component.get_result_ndarray(sections, aveSections, cornerData, aveNodes,
                                            variation, realPolar, coordsys, v1, v2)[1]

    # The ids and the index are selected. It takes into account where the results are and the number of parts
    if on_items == "NODES":
        nodes = model.get_nodes()
        ids = [(nodo.PartID, nodo.ID) if parts > 1 else nodo.ID for nodo in nodes]
        indexname = ["Part", "Grid"] if parts > 1 else ["Grid"]

    elif on_items == "ELEMENTS":
        elements = model.get_elements()
        connectors = model.get_connectors()
        ids = [(element.PartID, element.ID) if parts > 1 else element.ID for element in elements] + \
              [(co.PartID, co.ID) if parts > 1 else co.ID for con in connectors for co in (con if isinstance(con, list) else [con])]
        indexname = ["Part", "Element"] if parts > 1 else ["Element"]

    elif on_items == "ELEMENT NODAL":
        ids = model.elementnodal().values()
        indexname = ["Part", "Grid", "Element"]

    else:
        return None

    # If there are several parts, or it is corner data, MultiIndex is used:
    if isinstance(ids[0], tuple):
        index = pd.MultiIndex.from_tuples(ids, names=indexname)
    else:
        index = ids

    return index
```
Function that generates a DataFrame with the results of a component
```python
# results_fem.py

def dataframe_result(model: "N2PModelContent", component: "N2PComponent",sections=None, aveSections=-1, cornerData=False,
                     aveNodes=-1, variation=100, realPolar=0, coordsys: int = -1000,
                     v1: tuple = (1,0,0), v2: tuple = (0,1,0)) -> pd.DataFrame:
    """Function that returns as a dataframe of pandas the result array of a component
    """

    # DataFrame generation
    return pd.DataFrame(data={component.Name:
                              component.get_result_ndarray(sections, aveSections, cornerData, aveNodes, variation,
                                                           realPolar, coordsys, v1, v2)[0]},
                        index=_index_dataframe(model, component, sections, aveSections, cornerData, aveNodes, variation,
                                               realPolar, coordsys, v1, v2),
                        columns=[component.Name])
```
Function that generates a DataFrame for all the components of a result
```python
# results_fem.py

def dataframe_results(model: "N2PModelContent", result: "N2PResult", sections=None, aveSections=-1, cornerData=False,
                     aveNodes=-1, variation=100, realPolar=0, coordsys: int = -1000,
                     v1: tuple = (1,0,0), v2: tuple = (0,1,0)) -> pd.DataFrame:
    """Function that generates a DataFrame of pandas with all the components of a result. It uses dataframe_result.
    It uses sequential computing.
    """
    return pd.DataFrame(data={component.Name:
                                  component.get_result_ndarray(sections, aveSections, cornerData, aveNodes, variation,
                                                               realPolar, coordsys, v1, v2)[0]
                                                               for component in result.Components.values()},
                        index=_index_dataframe(model, next(iter(result.Components.values())), sections, aveSections,
                                               cornerData, aveNodes, variation, realPolar, coordsys, v1, v2),
                        columns=[component.Name for component in result.Components.values()])
```

##
For more documentation visit https://idaerosolutions.com/Home/NaxTo


# License

Copyright is owned by Idaero Solutions©
