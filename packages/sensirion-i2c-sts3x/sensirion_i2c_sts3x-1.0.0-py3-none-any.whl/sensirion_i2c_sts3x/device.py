#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# (c) Copyright 2023 Sensirion AG, Switzerland
#
#     THIS FILE IS AUTOMATICALLY GENERATED!
#
# Generator:     sensirion-driver-generator 0.33.0
# Product:       sts3x
# Model-Version: 1.0.0
#
"""
The class Sts3xDeviceBase implements the low level interface of the sensor.
The class Sts3xDevice extends the Sts3xDeviceBase. It provides additional functions to ease the use of the
sensor.
"""

import time
from sensirion_driver_adapters.transfer import execute_transfer
from sensirion_driver_support_types.mixin_access import MixinAccess
from sensirion_i2c_sts3x.commands import (ClearStatusRegister, MeasureSingleShotHighRepeatability,
                                          MeasureSingleShotHighRepeatabilityClockStretching,
                                          MeasureSingleShotLowRepeatability,
                                          MeasureSingleShotLowRepeatabilityClockStretching,
                                          MeasureSingleShotMediumRepeatability,
                                          MeasureSingleShotMediumRepeatabilityClockStretching, Mps, ReadMeasurement,
                                          ReadStatusRegister, Repeatability, SoftReset,
                                          StartMeasurement05MpsHighRepeatability,
                                          StartMeasurement05MpsLowRepeatability,
                                          StartMeasurement05MpsMediumRepeatability,
                                          StartMeasurement10MpsHighRepeatability,
                                          StartMeasurement10MpsLowRepeatability,
                                          StartMeasurement10MpsMediumRepeatability,
                                          StartMeasurement1MpsHighRepeatability, StartMeasurement1MpsLowRepeatability,
                                          StartMeasurement1MpsMediumRepeatability,
                                          StartMeasurement2MpsHighRepeatability, StartMeasurement2MpsLowRepeatability,
                                          StartMeasurement2MpsMediumRepeatability,
                                          StartMeasurement4MpsHighRepeatability, StartMeasurement4MpsLowRepeatability,
                                          StartMeasurement4MpsMediumRepeatability, StatusRegisterT, StopMeasurement)

from sensirion_i2c_sts3x.result_types import (SignalTemperature)


class Sts3xDeviceBase:
    """Low level API implementation of STS3X"""

    def __init__(self, channel):
        self._channel = channel

    @property
    def channel(self):
        return self._channel

    def measure_single_shot_high_repeatability(self):
        """
        Single shot measurement with high repeatability

        :return temperature_ticks:
            Temperature ticks. Convert to degrees celsius by -45 + 175 * value / 65535
        """
        transfer = MeasureSingleShotHighRepeatability()
        return execute_transfer(self._channel, transfer)[0]

    def measure_single_shot_high_repeatability_clock_stretching(self):
        """
        Single shot measurement with high repeatability and clock stretching enabled.

        :return temperature_ticks:
            Temperature ticks. Convert to degrees celsius by -45 + (175 * value / 65535)
        """
        transfer = MeasureSingleShotHighRepeatabilityClockStretching()
        return execute_transfer(self._channel, transfer)[0]

    def measure_single_shot_medium_repeatability(self):
        """
        Single shot measurement with medium repeatability

        :return temperature_ticks:
            Temperature ticks. Convert to degrees celsius by -45 + 175 * value / 65535
        """
        transfer = MeasureSingleShotMediumRepeatability()
        return execute_transfer(self._channel, transfer)[0]

    def measure_single_shot_medium_repeatability_clock_stretching(self):
        """
        Single shot measurement with medium repeatability and clock stretching enabled

        :return temperature_ticks:
            Temperature ticks. Convert to degrees celsius by -45 + (175 * value / 65535)
        """
        transfer = MeasureSingleShotMediumRepeatabilityClockStretching()
        return execute_transfer(self._channel, transfer)[0]

    def measure_single_shot_low_repeatability(self):
        """
        Single shot measurement with low repeatability

        :return temperature_ticks:
            Temperature ticks. Convert to degrees celsius by -45 + 175 * value / 65535
        """
        transfer = MeasureSingleShotLowRepeatability()
        return execute_transfer(self._channel, transfer)[0]

    def measure_single_shot_low_repeatability_clock_stretching(self):
        """
        Single shot measurement with low repeatability and clock stretching enabled

        :return temperature_ticks:
            Temperature ticks. Convert to degrees celsius by -45 + (175 * value / 65535)
        """
        transfer = MeasureSingleShotLowRepeatabilityClockStretching()
        return execute_transfer(self._channel, transfer)[0]

    def start_measurement_0_5_mps_high_repeatability(self):
        """Start periodic measurement mode with 0.5 mps and high repeatability."""
        transfer = StartMeasurement05MpsHighRepeatability()
        return execute_transfer(self._channel, transfer)

    def start_measurement_0_5_mps_medium_repeatability(self):
        """Start periodic measurement mode with 0.5 mps and medium repeatability."""
        transfer = StartMeasurement05MpsMediumRepeatability()
        return execute_transfer(self._channel, transfer)

    def start_measurement_0_5_mps_low_repeatability(self):
        """Start periodic measurement mode with 0.5 mps and low repeatability."""
        transfer = StartMeasurement05MpsLowRepeatability()
        return execute_transfer(self._channel, transfer)

    def start_measurement_1_mps_high_repeatability(self):
        """Start periodic measurement mode with 1 mps and high repeatability."""
        transfer = StartMeasurement1MpsHighRepeatability()
        return execute_transfer(self._channel, transfer)

    def start_measurement_1_mps_medium_repeatability(self):
        """Start periodic measurement mode with 1 mps and medium repeatability."""
        transfer = StartMeasurement1MpsMediumRepeatability()
        return execute_transfer(self._channel, transfer)

    def start_measurement_1_mps_low_repeatability(self):
        """Start periodic measurement mode with 1 mps and low repeatability."""
        transfer = StartMeasurement1MpsLowRepeatability()
        return execute_transfer(self._channel, transfer)

    def start_measurement_2_mps_high_repeatability(self):
        """Start periodic measurement mode with 2 mps and high repeatability."""
        transfer = StartMeasurement2MpsHighRepeatability()
        return execute_transfer(self._channel, transfer)

    def start_measurement_2_mps_medium_repeatability(self):
        """Start periodic measurement mode with 2 mps and medium repeatability."""
        transfer = StartMeasurement2MpsMediumRepeatability()
        return execute_transfer(self._channel, transfer)

    def start_measurement_2_mps_low_repeatability(self):
        """Start periodic measurement mode with 2 mps and low repeatability."""
        transfer = StartMeasurement2MpsLowRepeatability()
        return execute_transfer(self._channel, transfer)

    def start_measurement_4_mps_high_repeatability(self):
        """Start periodic measurement mode with 4 mps and high repeatability."""
        transfer = StartMeasurement4MpsHighRepeatability()
        return execute_transfer(self._channel, transfer)

    def start_measurement_4_mps_medium_repeatability(self):
        """Start periodic measurement mode with 4 mps and medium repeatability."""
        transfer = StartMeasurement4MpsMediumRepeatability()
        return execute_transfer(self._channel, transfer)

    def start_measurement_4_mps_low_repeatability(self):
        """Start periodic measurement mode with 4 mps and low repeatability."""
        transfer = StartMeasurement4MpsLowRepeatability()
        return execute_transfer(self._channel, transfer)

    def start_measurement_10_mps_high_repeatability(self):
        """Start periodic measurement mode with 10 mps and high repeatability."""
        transfer = StartMeasurement10MpsHighRepeatability()
        return execute_transfer(self._channel, transfer)

    def start_measurement_10_mps_medium_repeatability(self):
        """Start periodic measurement mode with 10 mps and medium repeatability."""
        transfer = StartMeasurement10MpsMediumRepeatability()
        return execute_transfer(self._channel, transfer)

    def start_measurement_10_mps_low_repeatability(self):
        """Start periodic measurement mode with 10 mps and low repeatability."""
        transfer = StartMeasurement10MpsLowRepeatability()
        return execute_transfer(self._channel, transfer)

    def read_measurement(self):
        """
        Read out data after a "start measurement" command has been issued.

        :return temperature_ticks:
            Temperature ticks. Convert to degrees celsius by -45 + 175 * value / 65535

        .. note::
            After the read out command fetch data has been issued, the data memory is cleared, i.e. no measurement data is present.
        """
        transfer = ReadMeasurement()
        return execute_transfer(self._channel, transfer)[0]

    def stop_measurement(self):
        """
        Stop the periodic measurement mode.

        .. note::
            Upon reception of this command the sensor will abort the ongoing measurement and enter the single shot mode.
        """
        transfer = StopMeasurement()
        return execute_transfer(self._channel, transfer)

    def read_status_register(self):
        """
        Read out the status register

        :return status_register:
            The contents of the status register

        .. note::
            The status register contains information on the operational status of the heater,
            the alert mode and on the execution status of the last command and the last write sequence.
        """
        transfer = ReadStatusRegister()
        return execute_transfer(self._channel, transfer)[0]

    def clear_status_register(self):
        """Clear (set to zero) all flags (Bit 15, 10, 4) in the status register."""
        transfer = ClearStatusRegister()
        return execute_transfer(self._channel, transfer)

    def soft_reset(self):
        """
        Perform a soft reset.

        .. note::
            A system reset of the STS3x can be achieved in multiple ways:
            - Soft reset: use this command
            - I2C general call: all devices on the I2C bus are reset by sending
            the command 0x06 to the I2C address 0x00
            - Reset pin: send a pulse to the dedicated nReset pin. The nReset pin has
            to be pulled low for a minimum of 1 µs to generate a reset of the sensor.
            - Hard reset: Power down (incl. pulling SDA, SCL and ADDR low)

            During the reset procedure the sensor will not process commands.
        """
        transfer = SoftReset()
        return execute_transfer(self._channel, transfer)


class Sts3xDevice(Sts3xDeviceBase):
    """Driver class implementation of STS3X"""

    #: Access to base class
    sts3x = MixinAccess()

    def __init__(self, channel):
        super().__init__(channel)
        self._internal_mps = Mps.ONE_PER_SECOND

    def measure_single_shot(self, measurement_repeatability, is_clock_stretching):
        """
        Single shot measurement with the specified properties

        :param measurement_repeatability:
            The repeatability of the periodic measurement
        :param is_clock_stretching:
            Toggle clock stretching

        :return a_temperature:
            Converted from ticks to degrees celsius by -45 + (175 * value / 65535)
        """
        if is_clock_stretching:
            if measurement_repeatability == Repeatability.HIGH:
                raw_temp = self.sts3x.measure_single_shot_high_repeatability_clock_stretching()
            elif measurement_repeatability == Repeatability.MEDIUM:
                raw_temp = self.sts3x.measure_single_shot_medium_repeatability_clock_stretching()
            elif measurement_repeatability == Repeatability.LOW:
                raw_temp = self.sts3x.measure_single_shot_low_repeatability_clock_stretching()
        elif measurement_repeatability == Repeatability.HIGH:
            raw_temp = self.sts3x.measure_single_shot_high_repeatability()
        elif measurement_repeatability == Repeatability.MEDIUM:
            raw_temp = self.sts3x.measure_single_shot_medium_repeatability()
        elif measurement_repeatability == Repeatability.LOW:
            raw_temp = self.sts3x.measure_single_shot_low_repeatability()
        return SignalTemperature(raw_temp)

    def start_periodic_measurement(self, measurement_repeatability, messages_per_second):
        """
        Start the periodic measurement measurement mode with the specified properties.

        This is a convenience method that can be used together with the 'blocking_read_measurement'
        command.

        :param measurement_repeatability:
            The repeatability of the periodic measurement
        :param messages_per_second:
            The messages per second of the periodic measurement
        """
        if messages_per_second == Mps.EVERY_TWO_SECONDS:
            if measurement_repeatability == Repeatability.HIGH:
                self.sts3x.start_measurement_0_5_mps_high_repeatability()
            elif measurement_repeatability == Repeatability.MEDIUM:
                self.sts3x.start_measurement_0_5_mps_medium_repeatability()
            elif measurement_repeatability == Repeatability.LOW:
                self.sts3x.start_measurement_0_5_mps_low_repeatability()
        elif messages_per_second == Mps.ONE_PER_SECOND:
            if measurement_repeatability == Repeatability.HIGH:
                self.sts3x.start_measurement_1_mps_high_repeatability()
            elif measurement_repeatability == Repeatability.MEDIUM:
                self.sts3x.start_measurement_1_mps_medium_repeatability()
            elif measurement_repeatability == Repeatability.LOW:
                self.sts3x.start_measurement_1_mps_low_repeatability()
        elif messages_per_second == Mps.TWO_PER_SECOND:
            if measurement_repeatability == Repeatability.HIGH:
                self.sts3x.start_measurement_2_mps_high_repeatability()
            elif measurement_repeatability == Repeatability.MEDIUM:
                self.sts3x.start_measurement_2_mps_medium_repeatability()
            elif measurement_repeatability == Repeatability.LOW:
                self.sts3x.start_measurement_2_mps_low_repeatability()
        elif messages_per_second == Mps.FOUR_PER_SECOND:
            if measurement_repeatability == Repeatability.HIGH:
                self.sts3x.start_measurement_4_mps_high_repeatability()
            elif measurement_repeatability == Repeatability.MEDIUM:
                self.sts3x.start_measurement_4_mps_medium_repeatability()
            elif measurement_repeatability == Repeatability.LOW:
                self.sts3x.start_measurement_4_mps_low_repeatability()
        elif messages_per_second == Mps.TEN_PER_SECOND:
            if measurement_repeatability == Repeatability.HIGH:
                self.sts3x.start_measurement_10_mps_high_repeatability()
            elif measurement_repeatability == Repeatability.MEDIUM:
                self.sts3x.start_measurement_10_mps_medium_repeatability()
            elif measurement_repeatability == Repeatability.LOW:
                self.sts3x.start_measurement_10_mps_low_repeatability()
        self._internal_mps = messages_per_second
        return

    def blocking_read_measurement(self):
        """
        Reads the measurement initiated with the 'start_periodic_measurement' command.

        This is a convenience method that takes into consideration the configured messages per second with
        which the 'start_periodic_measurement' command was called and blocks accordingly.

        :return a_temperature:
            Converted from ticks to degrees celsius by -45 + (175 * value / 65535)
        """
        if self._internal_mps == Mps.EVERY_TWO_SECONDS:
            time.sleep(2.0)
        elif self._internal_mps == Mps.ONE_PER_SECOND:
            time.sleep(1.0)
        elif self._internal_mps == Mps.TWO_PER_SECOND:
            time.sleep(0.5)
        elif self._internal_mps == Mps.FOUR_PER_SECOND:
            time.sleep(0.25)
        elif self._internal_mps == Mps.TEN_PER_SECOND:
            time.sleep(0.095)
        raw_temp = self.sts3x.read_measurement()
        return SignalTemperature(raw_temp)

    def read_status_register(self):
        """
        Read the contents of the status register

        :return a_status_register:

        """
        status = self.sts3x.read_status_register()
        return StatusRegisterT(status)
